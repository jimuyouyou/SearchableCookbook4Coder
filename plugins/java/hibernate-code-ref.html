<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>hibernate-refer</title>
	<link rel="stylesheet" href="../../css/main.css"> 
	<script src='../../lib/jquery-1.8.0.min.js'></script>
	<script src='../../lib/table_search.js'></script>
</head>
<body>
	<h2>Hibernate:</h2>

	official url: http://docs.jboss.org/hibernate/orm/4.2/manual/en-US/html/
	<table>
		<tr>
			<th>name</th>
			<th>code</th>
		</tr>
		<tr>
			<td>hsqldb</td>
			<td>mvn exec:java -Dexec.mainClass="org.hsqldb.Server" -Dexec.args="-database.0 file:target/data/tutorial" </td>
			
		</tr>
		<tr>
			<td>run</td>
			<td>mvn exec:java -Dexec.mainClass="com.qin.domain.EventManager" -Dexec.args="store"</td>
			
		</tr>
		<tr>
			<td>xml simple</td>
			<td>
				<xmp>
public class Person {
    private Set events = new HashSet();
    public Set getEvents() {
        return events;
    }
    public void setEvents(Set events) {
        this.events = events;
    }
}
					
<hibernate-mapping package="org.hibernate.tutorial.domain">
<class name="Person" table="PERSON">
	<id name="id" column="PERSON_ID">
		<generator class="native"/>
	</id>
	<property name="age"/>
	<property name="firstname"/>
	<property name="lastname"/>
</class>
</hibernate-mapping>
<mapping resource="org/hibernate/tutorial/domain/Person.hbm.xml"/>
			</xmp>				
			</td>
			
		</tr>
		<tr>
			<td>xml unidirectional Set-based association</td>
			<td>
				<xmp>
<class name="Person" table="PERSON">
    <id name="id" column="PERSON_ID">
        <generator class="native"/>
    </id>
    <property name="age"/>
    <property name="firstname"/>
    <property name="lastname"/>
    <set name="events" table="PERSON_EVENT">
        <key column="PERSON_ID"/>
        <many-to-many column="EVENT_ID" class="Event"/>
    </set>
</class>					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>xml - many-to-many</td>
			<td>
				<xmp>
private Set participants = new HashSet();
public Set getParticipants() {
    return participants;
}
public void setParticipants(Set participants) {
    this.participants = participants;
}
<set name="participants" table="PERSON_EVENT" inverse="true">
    <key column="EVENT_ID"/>
    <many-to-many column="PERSON_ID" class="Person"/>
</set>    					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>Programmatic configuration</td>
			<td>
				<pre>
Configuration cfg = new Configuration()
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml");
Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);
Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");        					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Obtaining a SessionFactory</td>
			<td>SessionFactory sessions = cfg.buildSessionFactory();</td>
			
		</tr>
		<tr>
			<td>JDBC connections</td>
			<td>Session session = sessions.openSession(); // open a new Session</td>
			
		</tr>
		<tr>
			<td>hibernate.properties file for c3p0</td>
			<td>
				<pre>
hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = org.hibernate.dialect.PostgreSQL82Dialect					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Hibernate SQL Dialects (hibernate.dialect)</td>
			<td>
				<pre>
CUBRID 8.3 and later	org.hibernate.dialect.CUBRIDDialect
DB2	org.hibernate.dialect.DB2Dialect
DB2 AS/400	org.hibernate.dialect.DB2400Dialect
DB2 OS390	org.hibernate.dialect.DB2390Dialect
Firebird	org.hibernate.dialect.FirebirdDialect
FrontBase	org.hibernate.dialect.FrontbaseDialect
H2	org.hibernate.dialect.H2Dialect
HyperSQL (HSQL)	org.hibernate.dialect.HSQLDialect
Informix	org.hibernate.dialect.InformixDialect
Ingres	org.hibernate.dialect.IngresDialect
Ingres 9	org.hibernate.dialect.Ingres9Dialect
Ingres 10	org.hibernate.dialect.Ingres10Dialect
Interbase	org.hibernate.dialect.InterbaseDialect
InterSystems Cache 2007.1	org.hibernate.dialect.Cache71Dialect
JDataStore	org.hibernate.dialect.JDataStoreDialect
Mckoi SQL	org.hibernate.dialect.MckoiDialect
Microsoft SQL Server 2000	org.hibernate.dialect.SQLServerDialect
Microsoft SQL Server 2005	org.hibernate.dialect.SQLServer2005Dialect
Microsoft SQL Server 2008	org.hibernate.dialect.SQLServer2008Dialect
Microsoft SQL Server 2012	org.hibernate.dialect.SQLServer2012Dialect
Mimer SQL	org.hibernate.dialect.MimerSQLDialect
MySQL	org.hibernate.dialect.MySQLDialect
MySQL with InnoDB	org.hibernate.dialect.MySQLInnoDBDialect
MySQL with MyISAM	org.hibernate.dialect.MySQLMyISAMDialect
MySQL5	org.hibernate.dialect.MySQL5Dialect
MySQL5 with InnoDB	org.hibernate.dialect.MySQL5InnoDBDialect
Oracle 8i	org.hibernate.dialect.Oracle8iDialect
Oracle 9i	org.hibernate.dialect.Oracle9iDialect
Oracle 10g and later	org.hibernate.dialect.Oracle10gDialect
Oracle TimesTen	org.hibernate.dialect.TimesTenDialect
Pointbase	org.hibernate.dialect.PointbaseDialect
PostgreSQL 8.1	org.hibernate.dialect.PostgreSQL81Dialect
PostgreSQL 8.2	org.hibernate.dialect.PostgreSQL82Dialect
PostgreSQL 9 and later	org.hibernate.dialect.PostgreSQL9Dialect
Progress	org.hibernate.dialect.ProgressDialect
SAP DB	org.hibernate.dialect.SAPDBDialect
SAP HANA (column store)	org.hibernate.dialect.HANAColumnStoreDialect
SAP HANA (row store)	org.hibernate.dialect.HANARowStoreDialect
Sybase	org.hibernate.dialect.SybaseDialect
Sybase 11	org.hibernate.dialect.Sybase11Dialect
Sybase ASE 15.5	org.hibernate.dialect.SybaseASE15Dialect
Sybase ASE 15.7	org.hibernate.dialect.SybaseASE157Dialect
Sybase Anywhere	org.hibernate.dialect.SybaseAnywhereDialect
Teradata	org.hibernate.dialect.TeradataDialect
Unisys OS 2200 RDMS	org.hibernate.dialect.RDMSOS2200Dialect					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>MySQLDialect</td>
			<td>
				<pre>
MySQL	org.hibernate.dialect.MySQLDialect
MySQL with InnoDB	org.hibernate.dialect.MySQLInnoDBDialect
MySQL with MyISAM	org.hibernate.dialect.MySQLMyISAMDialect
MySQL5	org.hibernate.dialect.MySQL5Dialect
MySQL5 with InnoDB	org.hibernate.dialect.MySQL5InnoDBDialec					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Hibernate Log Categories</td>
			<td>
				<pre>
org.hibernate.SQL	Log all SQL DML statements as they are executed
org.hibernate.type	Log all JDBC parameters
org.hibernate.tool.hbm2ddl	Log all SQL DDL statements as they are executed
org.hibernate.pretty	Log the state of all entities (max 20 entities) associated with the session at flush time
org.hibernate.cache	Log all second-level cache activity
org.hibernate.transaction	Log transaction related activity
org.hibernate.jdbc	Log all JDBC resource acquisition
org.hibernate.hql.internal.ast.AST	Log HQL and SQL ASTs during query parsing
org.hibernate.secure	Log all JAAS authorization requests
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>sample xml hibernate-configuration</td>
			<td>
				<xmp>
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <!-- a SessionFactory instance listed as /jndi/name -->
    <session-factory
        name="java:hibernate/SessionFactory">
        <!-- properties -->
        <property name="connection.datasource">java:/comp/env/jdbc/MyDB</property>
        <property name="dialect">org.hibernate.dialect.MySQLDialect</property>
        <property name="show_sql">false</property>
        <property name="transaction.factory_class">
            org.hibernate.transaction.JTATransactionFactory
        </property>
        <property name="jta.UserTransaction">java:comp/UserTransaction</property>
        <!-- mapping files -->
        <mapping resource="org/hibernate/auction/Item.hbm.xml"/>
        <mapping resource="org/hibernate/auction/Bid.hbm.xml"/>
        <!-- cache settings -->
        <class-cache class="org.hibernate.auction.Item" usage="read-write"/>
        <class-cache class="org.hibernate.auction.Bid" usage="read-only"/>
        <collection-cache collection="org.hibernate.auction.Item.bids" usage="read-write"/>
    </session-factory>
</hibernate-configuration>					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>lazy - Disabling proxies</td>
			<td>
				<pre>
<class name="Cat" lazy="false"...>...</class>
@Entity @Proxy(lazy=false) public class Cat { ... }					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Proxying an interface</td>
			<td>
				<pre>
<class name="Cat" proxy="ICat"...>...</class>
@Entity @Proxy(proxyClass=ICat.class) public class Cat implements ICat { ... }					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Dynamic models - using maps</td>
			<td>
				<xmp>
<hibernate-mapping>
    <class entity-name="Customer">
        <id name="id"
            type="long"
            column="ID">
            <generator class="sequence"/>
        </id>
        <property name="name"
            column="NAME"
            type="string"/>
        <property name="address"
            column="ADDRESS"
            type="string"/>
        <many-to-one name="organization"
            column="ORGANIZATION_ID"
            class="Organization"/>
        <bag name="orders"
            inverse="true"
            lazy="false"
            cascade="all">
            <key column="CUSTOMER_ID"/>
            <one-to-many class="Order"/>
        </bag>
    </class>
</hibernate-mapping>	
Session s = openSession();
Transaction tx = s.beginTransaction();
// Create a customer
Map david = new HashMap();
david.put("name", "David");
// Create an organization
Map foobar = new HashMap();
foobar.put("name", "Foobar Inc.");
// Link both
david.put("organization", foobar);
// Save both
s.save("Customer", david);
s.save("Organization", foobar);
tx.commit();
s.close();
Session dynamicSession = pojoSession.getSession(EntityMode.MAP);
// Create a customer
Map david = new HashMap();
david.put("name", "David");
dynamicSession.save("Customer", david);
...
dynamicSession.flush();
dynamicSession.close()
...
// Continue on pojoSessio				
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>Specify custom tuplizers</td>
			<td>
				<xmp>
@Entity
@Tuplizer(impl = DynamicEntityTuplizer.class)
public interface Cuisine {
    @Id
    @GeneratedValue
    public Long getId();
    public void setId(Long id);
    public String getName();
    public void setName(String name);
    @Tuplizer(impl = DynamicComponentTuplizer.class)
    public Country getCountry();
    public void setCountry(Country country);
}
<hibernate-mapping>
    <class entity-name="Customer">
        <!--
            Override the dynamic-map entity-mode
            tuplizer for the customer entity
        -->
        <tuplizer entity-mode="dynamic-map"
                class="CustomMapTuplizerImpl"/>
        <id name="id" type="long" column="ID">
            <generator class="sequence"/>
        </id>
        <!-- other properties -->
        ...
    </class>
</hibernate-mapping>					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>EntityNameResolvers</td>
			<td>
				<pre>
/**
 * A very trivial JDK Proxy InvocationHandler implementation where we proxy an
 * interface as the domain model and simply store persistent state in an internal
 * Map.  This is an extremely trivial example meant only for illustration.
 */
public final class DataProxyHandler implements InvocationHandler {
	private String entityName;
	private HashMap data = new HashMap();
	public DataProxyHandler(String entityName, Serializable id) {
		this.entityName = entityName;
		data.put( "Id", id );
	}
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		String methodName = method.getName();
		if ( methodName.startsWith( "set" ) ) {
			String propertyName = methodName.substring( 3 );
			data.put( propertyName, args[0] );
		}
		else if ( methodName.startsWith( "get" ) ) {
			String propertyName = methodName.substring( 3 );
			return data.get( propertyName );
		}
		else if ( "toString".equals( methodName ) ) {
			return entityName + "#" + data.get( "Id" );
		}
		else if ( "hashCode".equals( methodName ) ) {
			return new Integer( this.hashCode() );
		}
		return null;
	}
	public String getEntityName() {
		return entityName;
	}
	public HashMap getData() {
		return data;
	}
}
public class ProxyHelper {
    public static String extractEntityName(Object object) {
        // Our custom java.lang.reflect.Proxy instances actually bundle
        // their appropriate entity name, so we simply extract it from there
        // if this represents one of our proxies; otherwise, we return null
        if ( Proxy.isProxyClass( object.getClass() ) ) {
            InvocationHandler handler = Proxy.getInvocationHandler( object );
            if ( DataProxyHandler.class.isAssignableFrom( handler.getClass() ) ) {
                DataProxyHandler myHandler = ( DataProxyHandler ) handler;
                return myHandler.getEntityName();
            }
        }
        return null;
    }
    // various other utility methods ....
}
/**
 * The EntityNameResolver implementation.
 *
 * IMPL NOTE : An EntityNameResolver really defines a strategy for how entity names
 * should be resolved.  Since this particular impl can handle resolution for all of our
 * entities we want to take advantage of the fact that SessionFactoryImpl keeps these
 * in a Set so that we only ever have one instance registered.  Why?  Well, when it
 * comes time to resolve an entity name, Hibernate must iterate over all the registered
 * resolvers.  So keeping that number down helps that process be as speedy as possible.
 * Hence the equals and hashCode implementations as is
 */
public class MyEntityNameResolver implements EntityNameResolver {
    public static final MyEntityNameResolver INSTANCE = new MyEntityNameResolver();
    public String resolveEntityName(Object entity) {
        return ProxyHelper.extractEntityName( entity );
    }
    public boolean equals(Object obj) {
        return getClass().equals( obj.getClass() );
    }
    public int hashCode() {
        return getClass().hashCode();
    }
}
public class MyEntityTuplizer extends PojoEntityTuplizer {
	public MyEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
		super( entityMetamodel, mappedEntity );
	}
	public EntityNameResolver[] getEntityNameResolvers() {
		return new EntityNameResolver[] { MyEntityNameResolver.INSTANCE };
	}
    public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
        String entityName = ProxyHelper.extractEntityName( entityInstance );
        if ( entityName == null ) {
            entityName = super.determineConcreteSubclassEntityName( entityInstance, factory );
        }
        return entityName;
    }
					
				</pre>
			</td>
			<td>org.hibernate.EntityNameResolver</td>
		</tr>
		<tr>
			<td>@Entity</td>
			<td>
				<xmp>
@Entity
public class Flight implements Serializable {
    Long id;
    @Id
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
}  		
@Entity
@Table(name="TBL_FLIGHT", 
       schema="AIR_COMMAND", 
       uniqueConstraints=
           @UniqueConstraint(
               name="flight_number", 
               columnNames={"comp_prefix", "flight_number"} ) )
public class Flight implements Serializable {
    @Column(name="comp_prefix")
    public String getCompagnyPrefix() { return companyPrefix; }
    @Column(name="flight_number")
    public String getNumber() { return number; }
}			
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>@Subselect - view</td>
			<td>
				<xmp>
@Entity
@Subselect("select item.name, max(bid.amount), count(*) "
        + "from item "
        + "join bid on bid.item_id = item.id "
        + "group by item.name")
@Synchronize( {"item", "bid"} ) //tables impacted
public class Summary {
    @Id
    public String getId() { return id; }
    ...
}
<class
        name="ClassName"                                   (1)
        table="tableName"                                  (2)
        discriminator-value="discriminator_value"          (3)
        mutable="true|false"                               (4)
        schema="owner"                                     (5)
        catalog="catalog"                                  (6)
        proxy="ProxyInterface"                             (7)
        dynamic-update="true|false"                        (8)
        dynamic-insert="true|false"                        (9)
        select-before-update="true|false"                  (10)
        polymorphism="implicit|explicit"                   (11)
        where="arbitrary sql where condition"              (12)
        persister="PersisterClass"                         (13)
        batch-size="N"                                     (14)
        optimistic-lock="none|version|dirty|all"           (15)
        lazy="true|false"                                  (16)
        entity-name="EntityName"                           (17)
        check="arbitrary sql check condition"              (18)
        rowxml:id="rowid"                                  (19)
        subselect="SQL expression"                         (20)
        abstract="true|false"                              (21)
        node="element-name"
/>					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>@Id Identifiers</td>
			<td>
				<xmp>
@Entity
public class Person {
   @Id Integer getId() { ... }
   ...
}
<id
        name="propertyName"                                (1)
        type="typename"                                    (2)
        column="column_name"                               (3)
        unsaved-value="null|any|none|undefined|id_value"   (4)
        access="field|property|ClassName">                 (5)
        node="element-name|@attribute-name|element/@attribute|."
        <generator class="generatorClass"/>
</id>					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>id as a property using a component type - primary key</td>
			<td>
				<xmp>
@Entity
class User {
   @EmbeddedId
   @AttributeOverride(name="firstName", column=@Column(name="fld_firstname")
   UserId id;
   Integer age;
}
@Embeddable
class UserId implements Serializable {
   String firstName;
   String lastName;
}					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>An embedded id can itself contains the primary key of an associated entity - component</td>
			<td>
				<xmp>
@Entity
class Customer {
   @EmbeddedId CustomerId id;
   boolean preferredCustomer;
   @MapsId("userId")
   @JoinColumns({
      @JoinColumn(name="userfirstname_fk", referencedColumnName="firstName"),
      @JoinColumn(name="userlastname_fk", referencedColumnName="lastName")
   })
   @OneToOne User user;
}
@Embeddable
class CustomerId implements Serializable {
   UserId userId;
   String customerNumber;
   //implements equals and hashCode
}
@Entity 
class User {
   @EmbeddedId UserId id;
   Integer age;
}
@Embeddable
class UserId implements Serializable {
   String firstName;
   String lastName;
   //implements equals and hashCode
}				
 
component type used as identifier must implement equals() and hashCode().	
<class name="Customer">
   <composite-id name="id" class="CustomerId">
      <key-property name="firstName" column="userfirstname_fk"/>
      <key-property name="lastName" column="userfirstname_fk"/>
      <key-property name="customerNumber"/>
   </composite-id>
   <property name="preferredCustomer"/>
   <many-to-one name="user">
      <column name="userfirstname_fk" updatable="false" insertable="false"/>
      <column name="userlastname_fk" updatable="false" insertable="false"/>
   </many-to-one>
</class>
<class name="User">
   <composite-id name="id" class="UserId">
      <key-property name="firstName"/>
      <key-property name="lastName"/>
   </composite-id>
   <property name="age"/>
</class>
<class name="Customer">
   <composite-id name="id" class="CustomerId">
      <key-many-to-one name="user">
         <column name="userfirstname_fk"/>
         <column name="userlastname_fk"/>
      </key-many-to-one>
      <key-property name="customerNumber"/>
   </composite-id>
   <property name="preferredCustomer"/>
</class>
<class name="User">
   <composite-id name="id" class="UserId">
      <key-property name="firstName"/>
      <key-property name="lastName"/>
   </composite-id>
   <property name="age"/>
</class>
				</xmp>	
			</td>
			
		</tr>
		<tr>
			<td>Multiple id properties without identifier type</td>
			<td>
				<xmp>
@Entity
class Customer implements Serializable {
   @Id @OneToOne
   @JoinColumns({
      @JoinColumn(name="userfirstname_fk", referencedColumnName="firstName"),
      @JoinColumn(name="userlastname_fk", referencedColumnName="lastName")
   })
   User user;
  
   @Id String customerNumber;
   boolean preferredCustomer;
   //implements equals and hashCode
}
@Entity 
class User {
   @EmbeddedId UserId id;
   Integer age;
}
@Embeddable
class UserId implements Serializable {
   String firstName;
   String lastName;
   //implements equals and hashCode
}
<class name="Customer">
   <composite-id>
      <key-many-to-one name="user">
         <column name="userfirstname_fk"/>
         <column name="userlastname_fk"/>
      </key-many-to-one>
      <key-property name="customerNumber"/>
   </composite-id>
   <property name="preferredCustomer"/>
</class>
<class name="User">
   <composite-id name="id" class="UserId">
      <key-property name="firstName"/>
      <key-property name="lastName"/>
   </composite-id>
   <property name="age"/>
</class>				
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>element attributes</td>
			<td>
				<pre>
length	number	Column length
precision	number	Decimal precision of column
scale	number	Decimal scale of column
not-null	true or false	Whether a column is allowed to hold null values
unique	true or false	Whether values in the column must be unique
index	string	The name of a multi-column index
unique-key	string	The name of a multi-column unique constraint
foreign-key	string	The name of the foreign key constraint generated for an association. This applies to <one-to-one>, <many-to-one>, <key>, and <many-to-many> mapping elements. inverse="true" sides are skipped by SchemaExport.
sql-type	string	Overrides the default column type. This applies to the <column> element only.
default	string	Default value for the column
check	string	An SQL check constraint on either a column or atabl					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>auto-commit</td>
			<td>
				<pre>
Using auto-commit does not circumvent database transactions. Instead, when in auto-commit mode, 
JDBC drivers simply perform each call in an implicit transaction call. It is as if your application
 called commit after each and every JDBC call.					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Obtain an entity reference without initializing its data
			</td>
			<td>
				<pre>
Book book = new Book();
book.setAuthor( session.byId( Author.class ).getReference( authorId ) );
Book book = new Book();
book.setAuthor( entityManager.getReference( Author.class, authorId ) );					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Obtain an entity with its data initialized</td>
			<td>
				<pre>
session.byId( Author.class ).load( authorId );
entityManager.find( Author.class, authorId );					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>simple natural-id access</td>
			<td>
				<pre>
@Entity
public class User {
	@Id
	@GeneratedValue
	Long id;
	@NaturalId
	String userName;
	...
}
// use getReference() to create associations...
Resource aResource = (Resource) session.byId( Resource.class ).getReference( 123 );
User aUser = (User) session.bySimpleNaturalId( User.class ).getReference( "steve" );
aResource.assignTo( user );
// use load() to pull initialzed data
return session.bySimpleNaturalId( User.class ).load( "steve" );					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Refresh entity state</td>
			<td>
				<pre>
Cat cat = session.get( Cat.class, catId );
...
session.refresh( cat );
Cat cat = entityManager.find( Cat.class, catId );
...
entityManager.refresh( cat );					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>session.saveOrUpdate</td>
			<td>session.saveOrUpdate( someDetachedCat );</td>
			<td>
				<pre>
It does not mean that an SQL UPDATE is immediately performed. It does, however, mean that an SQL UPDATE will 
be performed when the persistence context is flushed since Hibernate does not know its previous state against 
which to compare for changes. Unless the entity is mapped with select-before-update, in which case Hibernate
 will pull the current state from the database and see if an update is needed.					
				</pre>
			</td>
		</tr>
		<tr>
			<td>merging a detached entity</td>
			<td>
				<pre>
Cat theManagedInstance = session.merge( someDetachedCat );
Cat theManagedInstance = entityManager.merge( someDetachedCat );					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>verifying laziness</td>
			<td>
				<pre>
if ( Hibernate.isInitialized( customer.getAddress() ) {
    //display address if loaded
}
if ( Hibernate.isInitialized( customer.getOrders()) ) ) {
    //display orders if loaded
}
if (Hibernate.isPropertyInitialized( customer, "detailedBio" ) ) {
    //display property detailedBio if loaded
}
javax.persistence.PersistenceUnitUtil jpaUtil = entityManager.getEntityManagerFactory().getPersistenceUnitUtil();
if ( jpaUtil.isLoaded( customer.getAddress() ) {
    //display address if loaded
}
if ( jpaUtil.isLoaded( customer.getOrders()) ) ) {
    //display orders if loaded
}
if (jpaUtil.isLoaded( customer, "detailedBio" ) ) {
    //display property detailedBio if loaded
}
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Entity states</td>
			<td>
				<pre>
Entity states
new, or transient - the entity has just been instantiated and is not associated with a persistence context. It
 has no persistent representation in the database and no identifier value has been assigned.
managed, or persistent - the entity has an associated identifier and is associated with a persistence context.
detached - the entity has an associated identifier, but is no longer associated with a persistence context (
usually because the persistence context was closed or the instance was evicted from the context)
removed - the entity has an associated identifier and is associated with a persistence context, however it is 
scheduled for removal from the database.
In Hibernate native APIs, the persistence context is defined as the org.hibernate.Session. In JPA, the 
persistence context is defined by javax.persistence.EntityManager. Much of the org.hibernate.Session and javax.
persistence.EntityManager methods deal with moving entities between these states.					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>unwrap  - Accessing Hibernate APIs from JPA</td>
			<td>
				<pre>
Session session = entityManager.unwrap( Session.class );
SessionImplementor sessionImplementor = entityManager.unwrap( SessionImplementor.class );					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Batch inserts</td>
			<td>
				<xmp>
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
for ( int i=0; i<100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
    if ( i % 20 == 0 ) { //20, same as the JDBC batch size
        //flush a batch of inserts and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();
alternation: To enable JDBC batching, set the property hibernate.jdbc.batch_size to an integer between 10 and 50.
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>cache operation</td>
			<td>
				<pre>
evit() clear cache for one object
clear() clear cache for all
contains() whether objec in cache or not
flush() flush from cache to database					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Batch updates</td>
			<td>
				<pre>
When you retriev and update data, flush() and clear() the session regularly. In addition, use method scroll() to take advantage of server-side cursors for queries that return many rows of data.
Example 4.3. Using scroll()
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .setCacheMode(CacheMode.IGNORE)
    .scroll(ScrollMode.FORWARD_ONLY);
int count=0;
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    if ( ++count % 20 == 0 ) {
        //flush a batch of updates and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>StatelessSession</td>
			<td>
				<pre>
Features and behaviors not provided by StatelessSession
a first-level cache
interaction with any second-level or query cache
transactional write-behind or automatic dirty checking		
StatelessSession session = sessionFactory.openStatelessSession();
Transaction tx = session.beginTransaction();
   
ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .scroll(ScrollMode.FORWARD_ONLY);
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    session.update(customer);
}
   
tx.commit();
session.close();
The Customer instances returned by the query are immediately detached. They are never associated with any persistence context.			
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>HQL UPDATE, using the Query.executeUpdate() method</td>
			<td>
				<pre>
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
String hqlUpdate = "update Customer c set c.name = :newName where c.name = :oldName";
// or String hqlUpdate = "update Customer set name = :newName where name = :oldName";
int updatedEntities = session.createQuery( hqlUpdate )
        .setString( "newName", newName )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>HQL DELETE</td>
			<td>
				<pre>
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
String hqlDelete = "delete Customer c where c.name = :oldName";
// or String hqlDelete = "delete Customer where name = :oldName";
int deletedEntities = session.createQuery( hqlDelete )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>HQL INSERT</td>
			<td>
				<pre>
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
String hqlInsert = "insert into DelinquentAccount (id, name) select c.id, c.name from Customer c where ...";
int createdEntities = session.createQuery( hqlInsert )
        .executeUpdate();
tx.commit();
session.close();					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>@Version</td>
			<td>
				<pre>
@Entity
public class Flight implements Serializable {
...
    @Version
    @Column(name="OPTLOCK")
    public Integer getVersion() { ... }
}   
Here, the version property is mapped to the OPTLOCK column, and the entity manager uses it to detect conflicting
 updates, and prevent the loss of updates that would be overwritten by a last-commit-wins strategy.					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>version property in hbm.xml</td>
			<td>
				<xmp>
<version
        column="version_column"
        name="propertyName"
        type="typename"
        access="field|property|ClassName"
        unsaved-value="null|negative|undefined"
        generated="never|always"
        insert="true|false"
        node="element-name|@attribute-name|element/@attribute|."
/>
column	The name of the column holding the version number. Optional, defaults to the property name.
name	The name of a property of the persistent class.
type	The type of the version number. Optional, defaults to integer.
access	Hibernate's strategy for accessing the property value. Optional, defaults to property.
unsaved-value	Indicates that an instance is newly instantiated and thus unsaved. This distinguishes it from detached instances that were saved or loaded in a previous session. The default value, undefined, indicates that the identifier property value should be used. Optional.
generated	Indicates that the version property value is generated by the database. Optional, defaults to never.
insert	Whether or not to include the version column in SQL insert statements. Defaults to true, but you can set it to false if the database column is defined with a default value of 0.					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>LockMode</td>
			<td>
				<pre>
The LockMode class defines the different lock levels that Hibernate can acquire.
LockMode.WRITE	acquired automatically when Hibernate updates or inserts a row.
LockMode.UPGRADE	acquired upon explicit user request using SELECT ... FOR UPDATE on databases which support that syntax.
LockMode.UPGRADE_NOWAIT	acquired upon explicit user request using a SELECT ... FOR UPDATE NOWAIT in Oracle.
LockMode.READ	acquired automatically when Hibernate reads data under Repeatable Read or Serializable isolation level. It can be re-acquired by explicit user request.
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Enabling the query cache</td>
			<td>
				<pre>
Set the hibernate.cache.use_query_cache property to true.
This setting creates two new cache regions:
org.hibernate.cache.internal.StandardQueryCache holds the cached query results.
org.hibernate.cache.spi.UpdateTimestampsCache holds timestamps of the most recent updates to queryable tables. These timestamps validate results served from the query cache.
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>HQL Query cache regions</td>
			<td>
				<pre>
Example 6.1. Method setCacheRegion
List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
        .setEntity("blogger", blogger)
        .setMaxResults(15)
        .setCacheable(true)
        .setCacheRegion("frontpages")
        .list();
To force the query cache to refresh one of its regions and disregard any cached results in the region, call org.hibernate.Query.setCacheMode(CacheMode.REFRESH). In conjunction with the region defined for the given query, Hibernate selectively refreshes the results cached in that particular region. This is much more efficient than bulk eviction of the region via org.hibernate.SessionFactory.evictQueries().					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Configuring your cache providers - second level</td>
			<td>
				<pre>
Note: When possible, define the cache concurrency strategy per entity rather than globally. Use the @org.hibernate.annotations.Cache annotation.
You can configure your cache providers using either annotations or mapping files.
Entities.  By default, entities are not part of the second-level cache, and their use is not recommended. If you absolutely must use entities, set the shared-cache-mode element in persistence.xml, or use property javax.persistence.sharedCache.mode in your configuration. Use one of the values in Table 6.1, “Possible values for Shared Cache Mode”.
Table 6.1. Possible values for Shared Cache Mode
Value	Description
ENABLE_SELECTIVE	Entities are not cached unless you explicitly mark them as cachable. This is the default and recommended value.
DISABLE_SELECTIVE	Entities are cached unless you explicitly mark them as not cacheable.
ALL	All entities are always cached even if you mark them as not cacheable.
NONE	No entities are cached even if you mark them as cacheable. This option basically disables second-level caching.					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td> Configuring cache providers</td>
			<td>
				<xmp>
@Entity 
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
public class Forest { ... }
Attributes of @Cache annotation
usage The given cache concurrency strategy, which may be:
NONE
READ_ONLY
NONSTRICT_READ_WRITE
READ_WRITE
TRANSACTIONAL
region
	The cache region. This attribute is optional, and defaults to the fully-qualified class name of the class, or the qually-qualified role name of the collection.
include Whether or not to include all properties.. Optional, and can take one of two possible values.
A value of all includes all properties. This is the default.
A value of non-lazy only includes non-lazy properties.
<cache
    usage="transactional"
    region="RegionName"
    include="all"
/>					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>Managing the cache</td>
			<td>
				<pre>
Saving or updating an item
save()
update()
saveOrUpdate()
Retrieving an item
load()
get()
list()
iterate()
scroll()					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Evicting an item from the first-level cache</td>
			<td>
				<pre>
ScrollableResult cats = sess.createQuery("from Cat as cat").scroll(); //a huge result set
while ( cats.next() ) {
    Cat cat = (Cat) cats.get(0);
    doSomethingWithACat(cat);
    sess.evict(cat);
}					
				</pre>
			</td>
			
		</tr>
		<tr>
			<td>Second-level cache eviction</td>
			<td>
				<xmp>
You can evict the cached state of an instance, entire class, collection instance or entire collection role, using methods of SessionFactory.
sessionFactory.getCache().containsEntity(Cat.class, catId); // is this particular Cat currently in the cache
sessionFactory.getCache().evictEntity(Cat.class, catId); // evict a particular Cat
sessionFactory.getCache().evictEntityRegion(Cat.class);  // evict all Cats
sessionFactory.getCache().evictEntityRegions();  // evict all entity data
sessionFactory.getCache().containsCollection("Cat.kittens", catId); // is this particular collection currently in the cache
sessionFactory.getCache().evictCollection("Cat.kittens", catId); // evict a particular collection of kittens
sessionFactory.getCache().evictCollectionRegion("Cat.kittens"); // evict all kitten collections
sessionFactory.getCache().evictCollectionRegions(); // evict all collection data					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>Browsing the contents of a second-level or query cache region - Enabling Statistics</td>
			<td>
				<xmp>
After enabling statistics, you can browse the contents of a second-level cache or query cache region.
Procedure 6.2. Enabling Statistics
Set hibernate.generate_statistics to true.
Optionally, set hibernate.cache.use_structured_entries to true, to cause Hibernate to store the cache entries in a human-readable format.
Example 6.6. Browsing the second-level cache entries via the Statistics API
Map cacheEntries = sessionFactory.getStatistics()
        .getSecondLevelCacheStatistics(regionName)
        .getEntries();					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>@Nationalized</td>
			<td>
				<xmp>
National Language Support enables you retrieve data or insert data into a database in any character set that the underlying database supports.						
@Entity( name="NationalizedEntity")
                public static class NationalizedEntity {
                    @Id
                    private Integer id;
                    @Nationalized
                    private String nvarcharAtt;
                    @Lob
                    @Nationalized
                    private String materializedNclobAtt;
                    @Lob
                    @Nationalized
                    private NClob nclobAtt;
                    @Nationalized
                    private Character ncharacterAtt;
                    @Nationalized
                    private Character[] ncharArrAtt;
                    @Type(type = "ntext")
                    private String nlongvarcharcharAtt;
                }						
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>HQL UPDATE query statements</td>
			<td>
				<xmp>
String hqlUpdate =
		"update Customer c " +
		"set c.name = :newName " +
		"where c.name = :oldName";
int updatedEntities = session.createQuery( hqlUpdate )
        .setString( "newName", newName )
        .setString( "oldName", oldName )
        .executeUpdate();
String jpqlUpdate =
		"update Customer c " +
		"set c.name = :newName " +
		"where c.name = :oldName";
int updatedEntities = entityManager.createQuery( jpqlUpdate )
        .setString( "newName", newName )
        .setString( "oldName", oldName )
        .executeUpdate();
String hqlVersionedUpdate =
		"update versioned Customer c " +
		"set c.name = :newName " +
		"where c.name = :oldName";
int updatedEntities = s.createQuery( hqlUpdate )
        .setString( "newName", newName )
        .setString( "oldName", oldName )
        .executeUpdate();					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>HQL inner join</td>
			<td>
				<xmp>
select c
from Customer c
    join c.chiefExecutive ceo
where ceo.age < 25
// same query but specifying join type as 'inner' explicitly
select c
from Customer c
    inner join c.chiefExecutive ceo
where ceo.age < 25					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>HQL left (outer) join examples</td>
			<td>
				<xmp>
// get customers who have orders worth more than $5000
// or who are in "preferred" status
select distinct c
from Customer c
    left join c.orders o
where o.value > 5000.00
  or c.status = 'preferred'
// functionally the same query but using the
// 'left outer' phrase
select distinct c
from Customer c
    left outer join c.orders o
where o.value > 5000.00
  or c.status = 'preferred'					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>HQL Fetch join - lazy</td>
			<td>
				<xmp>
select c
from Customer c
    left join fetch c.orders o
An important use case for explicit joins is to define FETCH JOINS which override the laziness of the joined association. As an example, given an entity named Customer with a collection-valued association named orders    	
Fetch joins are not valid in sub-queries.
Care should be taken when fetch joining a collection-valued association which is in any way further restricted; the fetched collection will be restricted too! For this reason it is usually considered best practice to not assign an identification variable to fetched joins except for the purpose of specifying nested fetch joins.
Fetch joins should not be used in paged queries (aka, setFirstResult/ setMaxResults). Nor should they be used with the HQL scroll or iterate features.			
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>with-clause join</td>
			<td>
				<xmp>
select distinct c
from Customer c
    left join c.orders o
        with o.value > 5000.00
HQL also defines a WITH clause to qualify the join conditions. Again, this is specific to HQL; JPQL does not define this feature.        					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>HQL Collection member references - join</td>
			<td>
				<xmp>
select c
from Customer c
    join c.orders o
    join o.lineItems l
    join l.product p
where o.status = 'pending'
  and p.status = 'backorder'
// alternate syntax
select c
from Customer c,
    in(c.orders) o,
    in(o.lineItems) l
    join l.product p
where o.status = 'pending'
  and p.status = 'backorder					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>HQL Qualified collection references example</td>
			<td>
				<xmp>
/ Product.images is a Map<String,String> : key = a name, value = file path
// select all the image file paths (the map value) for Product#123
select i
from Product p
    join p.images i
where p.id = 123
// same as above
select value(i)
from Product p
    join p.images i
where p.id = 123
// select all the image names (the map key) for Product#123
select key(i)
from Product p
    join p.images i
where p.id = 123
// select all the image names and file paths (the 'Map.Entry') for Product#123
select entry(i)
from Product p
    join p.images i
where p.id = 123
// total the value of the initial line items for all orders for a customer
select sum( li.amount )
from Customer c
        join c.orders o
        join o.lineItems li
where c.id = 123
  and index(li) = 1					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>HQL String literal escape</td>
			<td>
				<xmp>
select c
from Customer c
where c.name = 'Acme'
select c
from Customer c
where c.name = 'Acme''s Pretzel Logic'					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>HQL Numeric literal</td>
			<td>
				<xmp>
// simple integer literal
select o
from Order o
where o.referenceNumber = 123
// simple integer literal, typed as a long
select o
from Order o
where o.referenceNumber = 123L
// decimal notation
select o
from Order o
where o.total > 5000.00
// decimal notation, typed as a float
select o
from Order o
where o.total > 5000.00F
// scientific notation
select o
from Order o
where o.total > 5e+3
// scientific notation, typed as a float
select o
from Order o
where o.total > 5e+3F					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>HQL Named parameter</td>
			<td>
				<xmp>
String queryString =
        "select c " +
        "from Customer c " +
        "where c.name = :name " +
        "   or c.nickName = :name";
// HQL
List customers = session.createQuery( queryString )
        .setParameter( "name", theNameOfInterest )
        .list();
// JPQL
List<Customer> customers = entityManager.createQuery( queryString, Customer.class )
        .setParameter( "name", theNameOfInterest )
        .getResultList();					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>HQL Positional (JPQL) parameter</td>
			<td>
				<xmp>
String queryString =
        "select c " +
        "from Customer c " +
        "where c.name = ?1 " +
        "   or c.nickName = ?1";
// HQL - as you can see, handled just like named parameters
//      in terms of API
List customers = session.createQuery( queryString )
        .setParameter( "1", theNameOfInterest )
        .list();
// JPQL
List<Customer> customers = entityManager.createQuery( queryString, Customer.class )
        .setParameter( 1, theNameOfInterest )
        .getResultList();					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>HQL Numeric arithmetic</td>
			<td>
				<xmp>
select year( current_date() ) - year( c.dateOfBirth )
from Customer c
select c
from Customer c
where year( current_date() ) - year( c.dateOfBirth ) < 30
select o.customer, o.total + ( o.total * :salesTax )
from Order o					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>HQL Concatenation</td>
			<td>
				<xmp>
select 'Mr. ' || c.name.first || ' ' || c.name.last
from Customer c
where c.gender = Gender.MALE					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>Aggregate - math - statistic</td>
			<td>
				<xmp>
select count(*), sum( o.total ), avg( o.total ), min( o.total ), max( o.total )
from Order o
select count( distinct c.name )
from Customer c
select c.id, c.name, sum( o.total )
from Customer c
    left join c.orders o
group by c.id, c.name					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>functions - math - string</td>
			<td>
				<xmp>
CONCAT SUBSTRING UPPER LOWER TRIM LENGTH LOCATE ABS MOD SQRT 
CURRENT_DATE CURRENT_TIME CURRENT_TIMESTAMP BIT_LENGTH CAST 
EXTRACT SECOND MINUTE HOUR DAY MONTH YEAR STR				
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>HQL Collection-related expressions</td>
			<td>
				<xmp>
SIZE
Calculate the size of a collection. Equates to a subquery!
MAXELEMENT
Available for use on collections of basic type. Refers to the maximum value as determined by applying the max SQL aggregation.
MAXINDEX
Available for use on indexed collections. Refers to the maximum index (key/position) as determined by applying the max SQL aggregation.
MINELEMENT
Available for use on collections of basic type. Refers to the minimum value as determined by applying the min SQL aggregation.
MININDEX
Available for use on indexed collections. Refers to the minimum index (key/position) as determined by applying the min SQL aggregation.
ELEMENTS
Used to refer to the elements of a collection as a whole. Only allowed in the where clause. Often used in conjunction with ALL, ANY or SOME restrictions.
INDICES
Similar to elements except that indices refers to the collections indices (keys/positions) as a whole.
Example 11.21. Collection-related expressions examples
select cal
from Calendar cal
where maxelement(cal.holidays) > current_date()
select o
from Order o
where maxindex(o.items) > 100
select o
from Order o
where minelement(o.items) > 10000
select m
from Cat as m, Cat as kit
where kit in elements(m.kittens)
// the above query can be re-written in jpql standard way:
select m
from Cat as m, Cat as kit
where kit member of m.kittens
select p
from NameList l, Person p
where p.name = some elements(l.names)
select cat
from Cat cat
where exists elements(cat.kittens)
select p
from Player p
where 3 > all elements(p.scores)
select show
from Show show
where 'fizard' in indices(show.acts)					
				</xmp>
			</td>
			
		</tr>
		<tr>
			<td>HQL Index operator</td>
			<td>
				<xmp>
Elements of indexed collections (arrays, lists, and maps) can be referred to by index operator.
select o
from Order o
where o.items[0].id = 1234
select p
from Person p, Calendar c
where c.holidays['national day'] = p.birthDay
  and p.nationality.calendar = c
select i
from Item i, Order o
where o.items[ o.deliveredItemIndices[0] ] = i
  and o.id = 11
select i
from Item i, Order o
where o.items[ maxindex(o.items) ] = i
  and o.id = 11
select i
from Item i, Order o
where o.items[ size(o.items) - 1 ] = i					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>HQL Entity type</td>
			<td>
				<xmp>
select p
from Payment p
where type(p) = CreditCardPayment

select p
from Payment p
where type(p) = :aType
				</xmp>
			</td>
		</tr>
		<tr>
			<td>CASE expressions</td>
			<td>
				<xmp>
select case c.nickName when null then '<no nick name>' else c.nickName end
from Customer c

// This NULL checking is such a common case that most dbs
// define an abbreviated CASE form.  For example:
select nvl( c.nickName, '<no nick name>' )
from Customer c

// or:
select isnull( c.nickName, '<no nick name>' )
from Customer c

// the standard coalesce abbreviated form can be used
// to achieve the same result:
select coalesce( c.nickName, '<no nick name>' )
from Customer c					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>Searched CASE expressions - else</td>
			<td>
				<xmp>
select case when c.name.first is not null then c.name.first
            when c.nickName is not null then c.nickName
            else '<no first name>' end
from Customer c

// Again, the abbreviated form coalesce can handle this a
// little more succinctly
select coalesce( c.name.first, c.nickName, '<no first name>' )
from Customer c					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>NULLIF</td>
			<td>
				<xmp>
// return customers who have changed their last name
select nullif( c.previousName.last, c.name.last )
from Customer c

// equivalent CASE expression
select case when c.previousName.last = c.name.last then null
            else c.previousName.last end
from Customer c					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>Dynamic instantiation example - constructor</td>
			<td>
				<xmp>
select new Family( mother, mate, offspr )
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>Dynamic instantiation example - list - constructor</td>
			<td>
				<xmp>
select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr

    The results from this query will be a List<List> as opposed to a List<Object[]>					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>HQL Dynamic instantiation example - map</td>
			<td>
				<xmp>
select new map( mother as mother, offspr as offspr, mate as mate )
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr

select new map( max(c.bodyWeight) as max, min(c.bodyWeight) as min, count(*) as n )
from Cat c

The results from this query will be a List<Map<String,Object>> as opposed to a List<Object[]>. The keys of the map are defined by the aliases given to the select expressions.					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>HQL  Nullness checking </td>
			<td>
				<xmp>
select p
from Person p
where p.address is not null

// select everyone without an associated address
select p
from Person p
where p.address is null					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>HQL Like predicate</td>
			<td>
				<xmp>
select p
from Person p
where p.name like '%Schmidt'

select p
from Person p
where p.name not like 'Jingleheimmer%'

// find any with name starting with "sp_"
select sp
from StoredProcedureMetadata sp
where sp.name like 'sp|_%' escape '|'					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>HQL Between predicate</td>
			<td>
				<xmp>
select p
from Customer c
    join c.paymentHistory p
where c.id = 123
  and index(p) between 0 and 9

select c
from Customer c
where c.president.dateOfBirth
        between {d '1945-01-01'}
            and {d '1965-01-01'}

select o
from Order o
where o.total between 500 and 5000

select p
from Person p
where p.name between 'A' and 'E' 					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>HQL In predicate</td>
			<td>
				<xmp>
select p
from Payment p
where type(p) in (CreditCardPayment, WireTransferPayment)

select c
from Customer c
where c.hqAddress.state in ('TX', 'OK', 'LA', 'NM')

select c
from Customer c
where c.hqAddress.state in ?

select c
from Customer c
where c.hqAddress.state in (
    select dm.state
    from DeliveryMetadata dm
    where dm.salesTax is not null
)

// Not JPQL compliant!
select c
from Customer c
where c.name in (
    ('John','Doe'),
    ('Jane','Doe')
)

// Not JPQL compliant!
select c
from Customer c
where c.chiefExecutive in (
    select p
    from Person p
    where ...
)					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>HQL Empty collection predicate</td>
			<td>
				<xmp>
select o
from Order o
where o.lineItems is empty

select c
from Customer c
where c.pastDueBills is not empty					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>HQL Member-of collection predicate</td>
			<td>
				<xmp>
select p
from Person p
where 'John' member of p.nickNames

select p
from Person p
where p.name.first = 'Joseph'
  and 'Joey' not member of p.nickNames					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>Grouping</td>
			<td>
				<xmp>
// retrieve the total for all orders
select sum( o.total )
from Order o

// retrieve the total of all orders
// *grouped by* customer
select c.id, sum( o.total )
from Order o
    inner join o.customer c
group by c.id					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>Having illustration</td>
			<td>
				<xmp>
select c.id, sum( o.total )
from Order o
    inner join o.customer c
group by c.id
having sum( o.total ) > 10000.00					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>Ordering</td>
			<td>
				<xmp>
// legal because p.name is implicitly part of p
select p
from Person p
order by p.name

select c.id, sum( o.total ) as t
from Order o
    inner join o.customer c
group by c.id
order by t					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>native SQLQuery</td>
			<td>
				<xmp>
sess.createSQLQuery("SELECT * FROM CATS").list();
sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").list();
sess.createSQLQuery("SELECT * FROM CATS")
 .addScalar("ID", Hibernate.LONG)
 .addScalar("NAME", Hibernate.STRING)
 .addScalar("BIRTHDATE", Hibernate.DATE)
sess.createSQLQuery("SELECT * FROM CATS")
 .addScalar("ID", Hibernate.LONG)
 .addScalar("NAME")
 .addScalar("BIRTHDATE") 					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>Entity queries</td>
			<td>
				<xmp>
sess.createSQLQuery("SELECT * FROM CATS").addEntity(Cat.class);
sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").addEntity(Cat.class);	
sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS").addEntity(Cat.class);				
				</xmp>
			</td>
		</tr>
		<tr>
			<td>HQL associations and collections - query</td>
			<td>
				<xmp>
sess.createSQLQuery("SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID")
 .addEntity("cat", Cat.class)
 .addJoin("cat.dog");
sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID")
 .addEntity("cat", Cat.class)
 .addJoin("cat.dogs");
 In this example, the returned Cat's will have their dog property fully initialized without any extra roundtrip to the database. Notice that you added an alias name ("cat") to be able to specify the target property path of the join. It is possible to do the same eager joining for collections, e.g. if the Cat had a one-to-many to Dog instead. 					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>HQL multiple entities</td>
			<td>
				<xmp>
sess.createSQLQuery("SELECT c.*, m.*  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID")
 .addEntity("cat", Cat.class)
 .addEntity("mother", Cat.class)
sess.createSQLQuery("SELECT {cat.*}, {m.*}  FROM CATS c, CATS m WHERE c.MOTHER_ID = m.ID")
 .addEntity("cat", Cat.class)
 .addEntity("mother", Cat.class)
 {} is not vulnerable to column name duplication: 					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>HQL non-managed entities</td>
			<td>
				<xmp>
sess.createSQLQuery("SELECT NAME, BIRTHDATE FROM CATS")
        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>HQL Native SQL Parameters</td>
			<td>
				<xmp>
Native SQL queries support positional as well as named parameters:					
Query query = sess.createSQLQuery("SELECT * FROM CATS WHERE NAME like ?").addEntity(Cat.class);
List pusList = query.setString(0, "Pus%").list();

query = sess.createSQLQuery("SELECT * FROM CATS WHERE NAME like :name").addEntity(Cat.class);
List pusList = query.setString("name", "Pus%").list();    					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>JPA Custom CRUD via annotations</td>
			<td>
				<xmp>
@Entity
@Table(name="CHAOS")
@SQLInsert( sql="INSERT INTO CHAOS(size, name, nickname, id) VALUES(?,upper(?),?,?)")
@SQLUpdate( sql="UPDATE CHAOS SET size = ?, name = upper(?), nickname = ? WHERE id = ?")
@SQLDelete( sql="DELETE CHAOS WHERE id = ?")
@SQLDeleteAll( sql="DELETE CHAOS")
@Loader(namedQuery = "chaos")
@NamedNativeQuery(name="chaos", query="select id, size, name, lower( nickname ) as nickname from CHAOS where id= ?", resultClass = Chaos.class)
public class Chaos {
    @Id
    private Long id;
    private Long size;
    private String name;
    private String nickname;					
				</xmp>
			</td>
		</tr>
		<tr>
			<td> Custom CRUD XML</td>
			<td>
				<xmp>
<class name="Person">
    <id name="id">
        <generator class="increment"/>
    </id>
    <property name="name" not-null="true"/>
    <sql-insert>INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )</sql-insert>
    <sql-update>UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?</sql-update>
    <sql-delete>DELETE FROM PERSON WHERE ID=?</sql-delete>
</class>					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>Envers - audit data</td>
			<td>
				<xmp>
To audit changes that are performed on an entity, you only need two things: 
the hibernate-envers jar on the classpath and an @Audited annotation on the entity.					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>RevisionEntity - audit</td>
			<td>
				<xmp>
import org.hibernate.envers.RevisionEntity;
import org.hibernate.envers.DefaultRevisionEntity;

import javax.persistence.Entity;

@Entity
@RevisionEntity(ExampleListener.class)
public class ExampleRevEntity extends DefaultRevisionEntity {
    private String username;

    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
}					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>HQL QUERY SELECT UPDATE INSERT</td>
			<td>
				<xmp>
package com.king.dao;

import java.util.List;

import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.Transaction;

import com.king.entity.Blog;
import com.king.test.HibernateTest;

public class BlogDao {
	public Blog findBlogById(String id) {
		Session session = HibernateTest.getSession();

		String hql = "from Blog b where b.id = :id";
		Blog blog = (Blog) (session.createQuery(hql).setString("id", id).uniqueResult());

		session.close();
		return blog;
	}

	public List<Blog> getAllBlogs() {
		Session session = HibernateTest.getSession();

		String hql = "from Blog";
		Query qry = session.createQuery(hql);
		List<Blog> list = qry.list();

		session.close();
		return list;
	}

	public void updateBlog(Blog blog) {
		Session session = HibernateTest.getSession();
		Transaction ts = session.beginTransaction();
		session.saveOrUpdate(blog);
		session.flush();
		ts.commit();
		session.close();
	}
}
					
				</xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
	</table>
	
</body>
</html>