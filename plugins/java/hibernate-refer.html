<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>hibernate-refer</title>
	<link rel="stylesheet" href="../../css/main.css"> 
	<script src='../../lib/jquery-1.8.0.min.js'></script>
	<script src='../../lib/table_search.js'></script>
</head>
<body>
	<h2>Hibernate:</h2>
	Search By <input type='text' id='table_search' size='40' onkeyup='table_search();'><p>
	official url: http://docs.jboss.org/hibernate/orm/4.2/manual/en-US/html/
	<table>
		<tr>
			<th>name</th>
			<th>code</th>
			<th>explanation</th>
		</tr>
		<tr>
			<td>hsqldb</td>
			<td>mvn exec:java -Dexec.mainClass="org.hsqldb.Server" -Dexec.args="-database.0 file:target/data/tutorial" </td>
			<td></td>
		</tr>
		<tr>
			<td>run</td>
			<td>mvn exec:java -Dexec.mainClass="com.qin.domain.EventManager" -Dexec.args="store"</td>
			<td></td>
		</tr>
		<tr>
			<td>xml simple</td>
			<td>
				<xmp>
public class Person {
    private Set events = new HashSet();
    public Set getEvents() {
        return events;
    }
    public void setEvents(Set events) {
        this.events = events;
    }
}
					
<hibernate-mapping package="org.hibernate.tutorial.domain">
<class name="Person" table="PERSON">
	<id name="id" column="PERSON_ID">
		<generator class="native"/>
	</id>
	<property name="age"/>
	<property name="firstname"/>
	<property name="lastname"/>
</class>
</hibernate-mapping>
<mapping resource="org/hibernate/tutorial/domain/Person.hbm.xml"/>
			</xmp>				
			</td>
			<td></td>
		</tr>
		<tr>
			<td>xml unidirectional Set-based association</td>
			<td>
				<xmp>
<class name="Person" table="PERSON">
    <id name="id" column="PERSON_ID">
        <generator class="native"/>
    </id>
    <property name="age"/>
    <property name="firstname"/>
    <property name="lastname"/>
    <set name="events" table="PERSON_EVENT">
        <key column="PERSON_ID"/>
        <many-to-many column="EVENT_ID" class="Event"/>
    </set>
</class>					
				</xmp>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>xml - many-to-many</td>
			<td>
				<xmp>
private Set participants = new HashSet();
public Set getParticipants() {
    return participants;
}
public void setParticipants(Set participants) {
    this.participants = participants;
}
<set name="participants" table="PERSON_EVENT" inverse="true">
    <key column="EVENT_ID"/>
    <many-to-many column="PERSON_ID" class="Person"/>
</set>    					
				</xmp>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>Programmatic configuration</td>
			<td>
				<pre>
Configuration cfg = new Configuration()
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml");
Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);
Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");        					
				</pre>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>Obtaining a SessionFactory</td>
			<td>SessionFactory sessions = cfg.buildSessionFactory();</td>
			<td></td>
		</tr>
		<tr>
			<td>JDBC connections</td>
			<td>Session session = sessions.openSession(); // open a new Session</td>
			<td></td>
		</tr>
		<tr>
			<td>hibernate.properties file for c3p0</td>
			<td>
				<pre>
hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = org.hibernate.dialect.PostgreSQL82Dialect					
				</pre>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>Hibernate SQL Dialects (hibernate.dialect)</td>
			<td>
				<pre>
CUBRID 8.3 and later	org.hibernate.dialect.CUBRIDDialect
DB2	org.hibernate.dialect.DB2Dialect
DB2 AS/400	org.hibernate.dialect.DB2400Dialect
DB2 OS390	org.hibernate.dialect.DB2390Dialect
Firebird	org.hibernate.dialect.FirebirdDialect
FrontBase	org.hibernate.dialect.FrontbaseDialect
H2	org.hibernate.dialect.H2Dialect
HyperSQL (HSQL)	org.hibernate.dialect.HSQLDialect
Informix	org.hibernate.dialect.InformixDialect
Ingres	org.hibernate.dialect.IngresDialect
Ingres 9	org.hibernate.dialect.Ingres9Dialect
Ingres 10	org.hibernate.dialect.Ingres10Dialect
Interbase	org.hibernate.dialect.InterbaseDialect
InterSystems Cache 2007.1	org.hibernate.dialect.Cache71Dialect
JDataStore	org.hibernate.dialect.JDataStoreDialect
Mckoi SQL	org.hibernate.dialect.MckoiDialect
Microsoft SQL Server 2000	org.hibernate.dialect.SQLServerDialect
Microsoft SQL Server 2005	org.hibernate.dialect.SQLServer2005Dialect
Microsoft SQL Server 2008	org.hibernate.dialect.SQLServer2008Dialect
Microsoft SQL Server 2012	org.hibernate.dialect.SQLServer2012Dialect
Mimer SQL	org.hibernate.dialect.MimerSQLDialect
MySQL	org.hibernate.dialect.MySQLDialect
MySQL with InnoDB	org.hibernate.dialect.MySQLInnoDBDialect
MySQL with MyISAM	org.hibernate.dialect.MySQLMyISAMDialect
MySQL5	org.hibernate.dialect.MySQL5Dialect
MySQL5 with InnoDB	org.hibernate.dialect.MySQL5InnoDBDialect
Oracle 8i	org.hibernate.dialect.Oracle8iDialect
Oracle 9i	org.hibernate.dialect.Oracle9iDialect
Oracle 10g and later	org.hibernate.dialect.Oracle10gDialect
Oracle TimesTen	org.hibernate.dialect.TimesTenDialect
Pointbase	org.hibernate.dialect.PointbaseDialect
PostgreSQL 8.1	org.hibernate.dialect.PostgreSQL81Dialect
PostgreSQL 8.2	org.hibernate.dialect.PostgreSQL82Dialect
PostgreSQL 9 and later	org.hibernate.dialect.PostgreSQL9Dialect
Progress	org.hibernate.dialect.ProgressDialect
SAP DB	org.hibernate.dialect.SAPDBDialect
SAP HANA (column store)	org.hibernate.dialect.HANAColumnStoreDialect
SAP HANA (row store)	org.hibernate.dialect.HANARowStoreDialect
Sybase	org.hibernate.dialect.SybaseDialect
Sybase 11	org.hibernate.dialect.Sybase11Dialect
Sybase ASE 15.5	org.hibernate.dialect.SybaseASE15Dialect
Sybase ASE 15.7	org.hibernate.dialect.SybaseASE157Dialect
Sybase Anywhere	org.hibernate.dialect.SybaseAnywhereDialect
Teradata	org.hibernate.dialect.TeradataDialect
Unisys OS 2200 RDMS	org.hibernate.dialect.RDMSOS2200Dialect					
				</pre>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>MySQLDialect</td>
			<td>
				<pre>
MySQL	org.hibernate.dialect.MySQLDialect
MySQL with InnoDB	org.hibernate.dialect.MySQLInnoDBDialect
MySQL with MyISAM	org.hibernate.dialect.MySQLMyISAMDialect
MySQL5	org.hibernate.dialect.MySQL5Dialect
MySQL5 with InnoDB	org.hibernate.dialect.MySQL5InnoDBDialec					
				</pre>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>Hibernate Log Categories</td>
			<td>
				<pre>
org.hibernate.SQL	Log all SQL DML statements as they are executed
org.hibernate.type	Log all JDBC parameters
org.hibernate.tool.hbm2ddl	Log all SQL DDL statements as they are executed
org.hibernate.pretty	Log the state of all entities (max 20 entities) associated with the session at flush time
org.hibernate.cache	Log all second-level cache activity
org.hibernate.transaction	Log transaction related activity
org.hibernate.jdbc	Log all JDBC resource acquisition
org.hibernate.hql.internal.ast.AST	Log HQL and SQL ASTs during query parsing
org.hibernate.secure	Log all JAAS authorization requests
				</pre>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>sample xml hibernate-configuration</td>
			<td>
				<xmp>
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <!-- a SessionFactory instance listed as /jndi/name -->
    <session-factory
        name="java:hibernate/SessionFactory">
        <!-- properties -->
        <property name="connection.datasource">java:/comp/env/jdbc/MyDB</property>
        <property name="dialect">org.hibernate.dialect.MySQLDialect</property>
        <property name="show_sql">false</property>
        <property name="transaction.factory_class">
            org.hibernate.transaction.JTATransactionFactory
        </property>
        <property name="jta.UserTransaction">java:comp/UserTransaction</property>
        <!-- mapping files -->
        <mapping resource="org/hibernate/auction/Item.hbm.xml"/>
        <mapping resource="org/hibernate/auction/Bid.hbm.xml"/>
        <!-- cache settings -->
        <class-cache class="org.hibernate.auction.Item" usage="read-write"/>
        <class-cache class="org.hibernate.auction.Bid" usage="read-only"/>
        <collection-cache collection="org.hibernate.auction.Item.bids" usage="read-write"/>
    </session-factory>
</hibernate-configuration>					
				</xmp>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>lazy - Disabling proxies</td>
			<td>
				<pre>
<class name="Cat" lazy="false"...>...</class>
@Entity @Proxy(lazy=false) public class Cat { ... }					
				</pre>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>Proxying an interface</td>
			<td>
				<pre>
<class name="Cat" proxy="ICat"...>...</class>
@Entity @Proxy(proxyClass=ICat.class) public class Cat implements ICat { ... }					
				</pre>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>Dynamic models - using maps</td>
			<td>
				<xmp>
<hibernate-mapping>
    <class entity-name="Customer">
        <id name="id"
            type="long"
            column="ID">
            <generator class="sequence"/>
        </id>
        <property name="name"
            column="NAME"
            type="string"/>
        <property name="address"
            column="ADDRESS"
            type="string"/>
        <many-to-one name="organization"
            column="ORGANIZATION_ID"
            class="Organization"/>
        <bag name="orders"
            inverse="true"
            lazy="false"
            cascade="all">
            <key column="CUSTOMER_ID"/>
            <one-to-many class="Order"/>
        </bag>
    </class>
</hibernate-mapping>	

Session s = openSession();
Transaction tx = s.beginTransaction();

// Create a customer
Map david = new HashMap();
david.put("name", "David");

// Create an organization
Map foobar = new HashMap();
foobar.put("name", "Foobar Inc.");

// Link both
david.put("organization", foobar);

// Save both
s.save("Customer", david);
s.save("Organization", foobar);

tx.commit();
s.close();

Session dynamicSession = pojoSession.getSession(EntityMode.MAP);

// Create a customer
Map david = new HashMap();
david.put("name", "David");
dynamicSession.save("Customer", david);
...
dynamicSession.flush();
dynamicSession.close()
...
// Continue on pojoSessio				
				</xmp>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>Specify custom tuplizers</td>
			<td>
				<xmp>
@Entity
@Tuplizer(impl = DynamicEntityTuplizer.class)
public interface Cuisine {
    @Id
    @GeneratedValue
    public Long getId();
    public void setId(Long id);

    public String getName();
    public void setName(String name);

    @Tuplizer(impl = DynamicComponentTuplizer.class)
    public Country getCountry();
    public void setCountry(Country country);
}
<hibernate-mapping>
    <class entity-name="Customer">
        <!--
            Override the dynamic-map entity-mode
            tuplizer for the customer entity
        -->
        <tuplizer entity-mode="dynamic-map"
                class="CustomMapTuplizerImpl"/>

        <id name="id" type="long" column="ID">
            <generator class="sequence"/>
        </id>

        <!-- other properties -->
        ...
    </class>
</hibernate-mapping>					
				</xmp>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>EntityNameResolvers</td>
			<td>
				<pre>
/**
 * A very trivial JDK Proxy InvocationHandler implementation where we proxy an
 * interface as the domain model and simply store persistent state in an internal
 * Map.  This is an extremely trivial example meant only for illustration.
 */
public final class DataProxyHandler implements InvocationHandler {
	private String entityName;
	private HashMap data = new HashMap();

	public DataProxyHandler(String entityName, Serializable id) {
		this.entityName = entityName;
		data.put( "Id", id );
	}

	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		String methodName = method.getName();
		if ( methodName.startsWith( "set" ) ) {
			String propertyName = methodName.substring( 3 );
			data.put( propertyName, args[0] );
		}
		else if ( methodName.startsWith( "get" ) ) {
			String propertyName = methodName.substring( 3 );
			return data.get( propertyName );
		}
		else if ( "toString".equals( methodName ) ) {
			return entityName + "#" + data.get( "Id" );
		}
		else if ( "hashCode".equals( methodName ) ) {
			return new Integer( this.hashCode() );
		}
		return null;
	}

	public String getEntityName() {
		return entityName;
	}

	public HashMap getData() {
		return data;
	}
}

public class ProxyHelper {
    public static String extractEntityName(Object object) {
        // Our custom java.lang.reflect.Proxy instances actually bundle
        // their appropriate entity name, so we simply extract it from there
        // if this represents one of our proxies; otherwise, we return null
        if ( Proxy.isProxyClass( object.getClass() ) ) {
            InvocationHandler handler = Proxy.getInvocationHandler( object );
            if ( DataProxyHandler.class.isAssignableFrom( handler.getClass() ) ) {
                DataProxyHandler myHandler = ( DataProxyHandler ) handler;
                return myHandler.getEntityName();
            }
        }
        return null;
    }

    // various other utility methods ....

}

/**
 * The EntityNameResolver implementation.
 *
 * IMPL NOTE : An EntityNameResolver really defines a strategy for how entity names
 * should be resolved.  Since this particular impl can handle resolution for all of our
 * entities we want to take advantage of the fact that SessionFactoryImpl keeps these
 * in a Set so that we only ever have one instance registered.  Why?  Well, when it
 * comes time to resolve an entity name, Hibernate must iterate over all the registered
 * resolvers.  So keeping that number down helps that process be as speedy as possible.
 * Hence the equals and hashCode implementations as is
 */
public class MyEntityNameResolver implements EntityNameResolver {
    public static final MyEntityNameResolver INSTANCE = new MyEntityNameResolver();

    public String resolveEntityName(Object entity) {
        return ProxyHelper.extractEntityName( entity );
    }

    public boolean equals(Object obj) {
        return getClass().equals( obj.getClass() );
    }

    public int hashCode() {
        return getClass().hashCode();
    }
}

public class MyEntityTuplizer extends PojoEntityTuplizer {
	public MyEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
		super( entityMetamodel, mappedEntity );
	}

	public EntityNameResolver[] getEntityNameResolvers() {
		return new EntityNameResolver[] { MyEntityNameResolver.INSTANCE };
	}

    public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
        String entityName = ProxyHelper.extractEntityName( entityInstance );
        if ( entityName == null ) {
            entityName = super.determineConcreteSubclassEntityName( entityInstance, factory );
        }
        return entityName;
    }
					
				</pre>
			</td>
			<td>org.hibernate.EntityNameResolver</td>
		</tr>
		<tr>
			<td>@Entity</td>
			<td>
				<xmp>
@Entity
public class Flight implements Serializable {
    Long id;

    @Id
    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }
}  		

@Entity
@Table(name="TBL_FLIGHT", 
       schema="AIR_COMMAND", 
       uniqueConstraints=
           @UniqueConstraint(
               name="flight_number", 
               columnNames={"comp_prefix", "flight_number"} ) )
public class Flight implements Serializable {
    @Column(name="comp_prefix")
    public String getCompagnyPrefix() { return companyPrefix; }

    @Column(name="flight_number")
    public String getNumber() { return number; }
}			
				</xmp>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>@Subselect - view</td>
			<td>
				<xmp>
@Entity
@Subselect("select item.name, max(bid.amount), count(*) "
        + "from item "
        + "join bid on bid.item_id = item.id "
        + "group by item.name")
@Synchronize( {"item", "bid"} ) //tables impacted
public class Summary {
    @Id
    public String getId() { return id; }
    ...
}

<class
        name="ClassName"                                   (1)
        table="tableName"                                  (2)
        discriminator-value="discriminator_value"          (3)
        mutable="true|false"                               (4)
        schema="owner"                                     (5)
        catalog="catalog"                                  (6)
        proxy="ProxyInterface"                             (7)
        dynamic-update="true|false"                        (8)
        dynamic-insert="true|false"                        (9)
        select-before-update="true|false"                  (10)
        polymorphism="implicit|explicit"                   (11)
        where="arbitrary sql where condition"              (12)
        persister="PersisterClass"                         (13)
        batch-size="N"                                     (14)
        optimistic-lock="none|version|dirty|all"           (15)
        lazy="true|false"                                  (16)
        entity-name="EntityName"                           (17)
        check="arbitrary sql check condition"              (18)
        rowxml:id="rowid"                                  (19)
        subselect="SQL expression"                         (20)
        abstract="true|false"                              (21)
        node="element-name"
/>					
				</xmp>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>@Id Identifiers</td>
			<td>
				<xmp>
@Entity
public class Person {
   @Id Integer getId() { ... }
   ...
}

<id
        name="propertyName"                                (1)
        type="typename"                                    (2)
        column="column_name"                               (3)
        unsaved-value="null|any|none|undefined|id_value"   (4)
        access="field|property|ClassName">                 (5)
        node="element-name|@attribute-name|element/@attribute|."

        <generator class="generatorClass"/>
</id>					
				</xmp>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>id as a property using a component type - primary key</td>
			<td>
				<xmp>
@Entity
class User {
   @EmbeddedId
   @AttributeOverride(name="firstName", column=@Column(name="fld_firstname")
   UserId id;

   Integer age;
}

@Embeddable
class UserId implements Serializable {
   String firstName;
   String lastName;
}					
				</xmp>
			</td>
			<td></td>
		</tr>
		<tr>
			<td>An embedded id can itself contains the primary key of an associated entity - component</td>
			<td>
				<xmp>
@Entity
class Customer {
   @EmbeddedId CustomerId id;
   boolean preferredCustomer;

   @MapsId("userId")
   @JoinColumns({
      @JoinColumn(name="userfirstname_fk", referencedColumnName="firstName"),
      @JoinColumn(name="userlastname_fk", referencedColumnName="lastName")
   })
   @OneToOne User user;
}

@Embeddable
class CustomerId implements Serializable {
   UserId userId;
   String customerNumber;

   //implements equals and hashCode
}

@Entity 
class User {
   @EmbeddedId UserId id;
   Integer age;
}

@Embeddable
class UserId implements Serializable {
   String firstName;
   String lastName;

   //implements equals and hashCode
}				
 
component type used as identifier must implement equals() and hashCode().	

<class name="Customer">
   <composite-id name="id" class="CustomerId">
      <key-property name="firstName" column="userfirstname_fk"/>
      <key-property name="lastName" column="userfirstname_fk"/>
      <key-property name="customerNumber"/>
   </composite-id>

   <property name="preferredCustomer"/>

   <many-to-one name="user">
      <column name="userfirstname_fk" updatable="false" insertable="false"/>
      <column name="userlastname_fk" updatable="false" insertable="false"/>
   </many-to-one>
</class>

<class name="User">
   <composite-id name="id" class="UserId">
      <key-property name="firstName"/>
      <key-property name="lastName"/>
   </composite-id>

   <property name="age"/>
</class>

<class name="Customer">
   <composite-id name="id" class="CustomerId">
      <key-many-to-one name="user">
         <column name="userfirstname_fk"/>
         <column name="userlastname_fk"/>
      </key-many-to-one>
      <key-property name="customerNumber"/>
   </composite-id>

   <property name="preferredCustomer"/>
</class>

<class name="User">
   <composite-id name="id" class="UserId">
      <key-property name="firstName"/>
      <key-property name="lastName"/>
   </composite-id>

   <property name="age"/>
</class>
				</xmp>	
			</td>
			<td></td>
		</tr>
		<tr>
			<td>Multiple id properties without identifier type</td>
			<td>
				<xmp>
@Entity
class Customer implements Serializable {
   @Id @OneToOne
   @JoinColumns({
      @JoinColumn(name="userfirstname_fk", referencedColumnName="firstName"),
      @JoinColumn(name="userlastname_fk", referencedColumnName="lastName")
   })
   User user;
  
   @Id String customerNumber;

   boolean preferredCustomer;

   //implements equals and hashCode
}

@Entity 
class User {
   @EmbeddedId UserId id;
   Integer age;
}

@Embeddable
class UserId implements Serializable {
   String firstName;
   String lastName;

   //implements equals and hashCode
}

<class name="Customer">
   <composite-id>
      <key-many-to-one name="user">
         <column name="userfirstname_fk"/>
         <column name="userlastname_fk"/>
      </key-many-to-one>
      <key-property name="customerNumber"/>
   </composite-id>

   <property name="preferredCustomer"/>
</class>

<class name="User">
   <composite-id name="id" class="UserId">
      <key-property name="firstName"/>
      <key-property name="lastName"/>
   </composite-id>

   <property name="age"/>
</class>				
				</xmp>
			</td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
			<td></td>
		</tr>
	</table>
	
</body>
</html>