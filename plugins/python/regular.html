<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>regular.html</title>
	<link rel="stylesheet" href="../../css/main.css">
	<script src='../../lib/jquery-1.8.0.min.js'></script>
	<script src='../../lib/pCfg.js'></script>
	<script src='../../lib/table_search.js'></script>
	<script type="text/javascript">
	var cfg = {
		labels: ['slash', 'raw', 'match', 'find', 'modify', 'greedy', 'number', 'string', 'range', 'list', 'tuple', 'class', 'exception', 'assert'] 
	};
	</script>
</head>
<body>
	<table>
		<tr>
			<td>metacharacters</td>
			<td>
				. ^ $ * + ? { } [ ] \ | ( )
			</td>
		</tr>
		<tr>
			<td>slash</td>
			<td>
				<xmp>
\d
    Matches any decimal digit; this is equivalent to the class [0-9].
\D
    Matches any non-digit character; this is equivalent to the class [^0-9].
\s
    Matches any whitespace character; this is equivalent to the class [ \t\n\r\f\v].
\S
    Matches any non-whitespace character; this is equivalent to the class [^ \t\n\r\f\v].
\w
    Matches any alphanumeric character; this is equivalent to the class [a-zA-Z0-9_].
\W
    Matches any non-alphanumeric character; this is equivalent to the class [^a-zA-Z0-9_]. 	

[\s,.] is a character class that will match any whitespace character, or ',' or '.'.

The final metacharacter in this section is .. It matches anything except a newline character, and there’s an alternate mode (re.DOTALL) where it will match even a newline. '.' is often used where you want to match “any character”.    				
				</xmp>
			</td>
		</tr>
		<tr>
			<td>Raw string</td>
			<td>
				<xmp>
Regular String 	Raw string
"ab*" 	r"ab*"
"\\\\section" 	r"\\section"
"\\w+\\s+\\1" 	r"\w+\s+\1"					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>match</td>
			<td>
				<xmp>
Method/Attribute 	Purpose
match() 	Determine if the RE matches at the beginning of the string.
search() 	Scan through a string, looking for any location where this RE matches.
findall() 	Find all substrings where the RE matches, and returns them as a list.
finditer() 	Find all substrings where the RE matches, and returns them as an iterator.	

Method/Attribute 	Purpose
group() 	Return the string matched by the RE
start() 	Return the starting position of the match
end() 	Return the ending position of the match
span() 	Return a tuple containing the (start, end) positions of the match				
				</xmp>
			</td>
		</tr>
		<tr>
			<td>findall</td>
			<td>
				<xmp>
p = re.compile('\d+')
>>> p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')
['12', '11', '10']					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>finditer</td>
			<td>
				<xmp>
iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')
>>> iterator  
<callable-iterator object at 0x...>
>>> for match in iterator:
...     print match.span()
...
(0, 2)
(22, 24)
(29, 31)					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>match</td>
			<td>
			print re.match(r'From\s+', 'From amk Thu May 14 19:12:10 1998') 
			</td>
		</tr>
		<tr>
			<td>flag</td>
			<td>
				<xmp>
Flag 	Meaning
DOTALL, S 	Make . match any character, including newlines
IGNORECASE, I 	Do case-insensitive matches
LOCALE, L 	Do a locale-aware match
MULTILINE, M 	Multi-line matching, affecting ^ and $
VERBOSE, X 	Enable verbose REs, which can be organized more cleanly and understandably.
UNICODE, U 	Makes several escapes like \w, \b, \s and \d dependent on the Unicode character database.					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>modify</td>
			<td>
				<xmp>
Method/Attribute 	Purpose
split() 	Split the string into a list, splitting it wherever the RE matches
sub() 	Find all substrings where the RE matches, and replace them with a different string
subn() 	Does the same thing as sub(), but returns the new string and the number of replacements					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>split</td>
			<td>
				<xmp>
p = re.compile(r'\W+')
>>> p.split('This is a test, short and sweet, of split().')
['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']
>>> p.split('This is a test, short and sweet, of split().', 3)
['This', 'is', 'a', 'test, short and sweet, of split().']
					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>replace</td>
			<td>
				<xmp>
>>> p = re.compile( '(blue|white|red)')
>>> p.sub( 'colour', 'blue socks and red shoes')
'colour socks and colour shoes'
>>> p.sub( 'colour', 'blue socks and red shoes', count=1)
'colour socks and red shoes'

>>> p = re.compile( '(blue|white|red)')
>>> p.subn( 'colour', 'blue socks and red shoes')
('colour socks and colour shoes', 2)
>>> p.subn( 'colour', 'no colours at all')
('no colours at all', 0)					
				</xmp>
			</td>
		</tr>
		<tr>
			<td>greedy</td>
			<td>
				<xmp>
import re
s = ‘<html><head><title>Title</title>’
print(re.match(‘<.*>’, s).group())

会返回一个匹配<html><head><title>Title</title>而不是<html>

而

import re
s = ‘<html><head><title>Title</title>’
print(re.match(‘<.*?>’, s).group())

则会返回<html>

<.*>这种匹配称作贪心匹配 <.*?>称作非贪心匹配					
				</xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<xmp></xmp>
			</td>
		</tr>
	</table>
</body>
</html>