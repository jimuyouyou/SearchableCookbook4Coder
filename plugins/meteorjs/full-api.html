<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>full-api</title>
	<script src='../../lib/jquery-1.8.0.min.js'></script>
  	<script src='../../lib/h_search.js'></script>
  	<script src='../../lib/a_search.js'></script>
</head>
<body>
	<div class="body sidebar-closed">
<div class="main-content">
<div id="main">
<div class="">
<div id="introduction">
<p><strong><em>Meteor is an ultra-simple environment for building modern websites. What once took weeks, even with the best tools, now takes hours with Meteor.</em></strong></p>
<p>The web was originally designed to work in the same way that mainframes worked in the 70s. The application server rendered a screen and sent it over the network to a dumb terminal. Whenever the user did anything, that server rerendered a whole new screen. This model served the Web well for over a decade. It gave rise to LAMP, Rails, Django, PHP.</p>
<p>But the best teams, with the biggest budgets and the longest schedules, now build applications in JavaScript that run on the client. These apps have stellar interfaces. They don't reload pages. They are reactive: changes from any client immediately appear on everyone's screen.</p>
<p>They've built them the hard way. Meteor makes it an order of magnitude simpler, and a lot more fun. You can build a complete application in a weekend, or a sufficiently caffeinated hackathon. No longer do you need to provision server resources, or deploy API endpoints in the cloud, or manage a database, or wrangle an ORM layer, or swap back and forth between JavaScript and Ruby, or broadcast data invalidations to clients.</p>
<h2 id="quickstart">Quick start!</h2>
<p>The following works on all <a href="https://github.com/meteor/meteor/wiki/Supported-Platforms">supported platforms</a>.</p>
<p>Install Meteor:</p>
<pre><code class="hljs bash">$ curl https://install.meteor.com | /bin/sh
</code></pre>
<p>Create a project:</p>
<pre><code class="hljs bash">$ meteor create myapp
</code></pre>
<p>Run it locally:</p>
<pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> myapp
$ meteor
<span class="hljs-comment"># Meteor server running on: http://localhost:3000/</span>
</code></pre>
<p>Unleash it on the world (on a free server we provide):</p>
<pre><code class="hljs bash">$ meteor deploy myapp.meteor.com
</code></pre>
<h2 id="sevenprinciples">Principles of Meteor</h2>
<ul>
<li>
<p><em>Data on the Wire</em>. Meteor doesn't send HTML over the network. The server sends data and lets the client render it.</p>
</li>
<li>
<p><em>One Language.</em> Meteor lets you write both the client and the server parts of your application in JavaScript.</p>
</li>
<li>
<p><em>Database Everywhere</em>. You can use the same methods to access your database from the client or the server.</p>
</li>
<li>
<p><em>Latency Compensation</em>. On the client, Meteor prefetches data and simulates models to make it look like server method calls return instantly.</p>
</li>
<li>
<p><em>Full Stack Reactivity</em>. In Meteor, realtime is the default. All layers, from database to template, update themselves automatically when necessary.</p>
</li>
<li>
<p><em>Embrace the Ecosystem</em>. Meteor is open source and integrates with existing open source tools and frameworks.</p>
</li>
<li>
<p><em>Simplicity Equals Productivity</em>. The best way to make something seem simple is to have it actually <em>be</em> simple. Meteor's main functionality has clean, classically beautiful APIs.</p>
</li>
</ul>
<h2 id="resources">Developer Resources</h2>
<p>&nbsp;</p>
<p>If anything in Meteor catches your interest, we hope you'll get involved with the project!</p>
<dl class="involved">
<dt>Tutorial</dt>
<dd>Get started fast with the <a href="https://www.meteor.com/install">official Meteor tutorial</a>!</dd>
<dt>Stack Overflow</dt>
<dd>The best place to ask (and answer!) technical questions is on <a href="http://stackoverflow.com/questions/tagged/meteor">Stack Overflow</a>. Be sure to add the <code>meteor</code> tag to your question.</dd>
<dt>Forums</dt>
<dd>Visit the <a href="https://forums.meteor.com">Meteor discussion forums</a>to announce projects, get help, talk about the community, or discuss changes to core.</dd>
<dt>GitHub</dt>
<dd>The core code is on <a href="http://github.com/meteor/meteor">GitHub</a>. If you're able to write code or file issues, we'd love to have your help. Please read <a href="https://github.com/meteor/meteor/wiki/Contributing-to-Meteor">Contributing to Meteor</a> for how to get started.</dd>
<dt>The Meteor Manual</dt>
<dd>In-depth articles about the core components of Meteor can be found on the <a href="http://manual.meteor.com/">Meteor Manual</a>. The first article is about <a href="http://manual.meteor.com/#tracker">Tracker</a>, our transparent reactivity framework. More articles (covering topics like Blaze, Unibuild, and DDP) are coming soon!</dd>
</dl>
</div>
<h1 id="concepts">Concepts</h1>
We've written our fair share of single-page JavaScript applications by hand. Writing an entire application in one language (JavaScript) with one data format (JSON) is a real joy. Meteor is everything we wanted when writing those apps.
<h2 id="whatismeteor">What is Meteor?</h2>
<p>Meteor is two things:</p>
<ul>
<li>
<p>A <em>library of packages</em>: pre-written, self-contained modules that you might need in your app.</p>
<p>There are about a dozen core Meteor packages that most any app will use. Two examples: <a href="http://localhost:3000/#webapp"><code>webapp</code></a>, which handles incoming HTTP connections, and <code>templating</code>, which lets you make HTML templates that automatically update live as data changes. Then there are optional packages like <code>email</code>, which lets your app send emails, or the Meteor Accounts series (<code>accounts-password</code>, <code>accounts-facebook</code>, <code>accounts-ui</code>, and others) which provide a full-featured user account system that you can drop right into your app. In addition to these "core" packages, there are thousands of community-written packages in <a href="https://atmospherejs.com/">Atmosphere</a>, one of which might do just what you need.</p>
</li>
<li>
<p>A <em>command-line tool</em> called <code>meteor</code>.</p>
<p><code>meteor</code> is a build tool analogous to <code>make</code>, <code>rake</code>, or the non-visual parts of Visual Studio. It gathers up all of the source files and assets in your application, carries out any necessary build steps (such as compiling <a href="http://coffeescript.org">CoffeeScript</a>, minifying CSS, building <a href="https://npmjs.org/">npm</a> modules, or generating source maps), fetches the packages used by your app, and outputs a standalone, ready-to-run application bundle. In development mode it can do all of this interactively, so that whenever you change a file you immediately see the changes in your browser. It's super easy to use out of the box, but it's also extensible: you can add support for new languages and compilers by adding build plugin packages to your app.</p>
<p>The key idea in the Meteor package system is that <em>everything should work identically in the browser and on the server</em> (wherever it makes sense, of course: browsers can't send email and servers can't capture mouse events). Our whole ecosystem has been built from the ground up to support this.</p>
</li>
</ul>
<h2 id="structuringyourapp">Structuring your application</h2>
<p>A Meteor application is a mix of client-side JavaScript that runs inside a web browser or PhoneGap mobile app, server-side JavaScript that runs on the Meteor server inside a <a href="http://nodejs.org/">Node.js</a> container, and all the supporting HTML templates, CSS rules, and static assets. Meteor automates the packaging and transmission of these different components, and it is quite flexible about how you choose to structure those components in your file tree.</p>
<h3 id="specialdirectories">Special Directories</h3>
<p>By default, any JavaScript files in your Meteor folder are bundled and sent to the client and the server. However, the names of the files and directories inside your project can affect their load order, where they are loaded, and some other characteristics. Here is a list of file and directory names that are treated specially by Meteor:</p>
<ul>
<li>
<p><strong>client</strong></p>
<p>Any directory named <code>client</code> is not loaded on the server. Similar to wrapping your code in <code>if (Meteor.isClient) { ... }</code>. All files loaded on the client are automatically concatenated and minified when in production mode. In development mode, JavaScript and CSS files are not minified, to make debugging easier. (CSS files are still combined into a single file for consistency between production and development, because changing the CSS file's URL affects how URLs in it are processed.)</p>
<p>HTML files in a Meteor application are treated quite a bit differently from a server-side framework. Meteor scans all the HTML files in your directory for three top-level elements: <code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>, and <code>&lt;template&gt;</code>. The head and body sections are separately concatenated into a single head and body, which are transmitted to the client on initial page load.</p>
</li>
<li>
<p><strong>server</strong></p>
<p>Any directory named <code>server</code> is not loaded on the client. Similar to wrapping your code in <code>if (Meteor.isServer) { ... }</code>, except the client never even receives the code. Any sensitive code that you don't want served to the client, such as code containing passwords or authentication mechanisms, should be kept in the <code>server</code> directory.</p>
<p>Meteor gathers all your JavaScript files, excluding anything under the <code>client</code>, <code>public</code>, and <code>private</code> subdirectories, and loads them into a Node.js server instance. In Meteor, your server code runs in a single thread per request, not in the asynchronous callback style typical of Node. We find the linear execution model a better fit for the typical server code in a Meteor application.</p>
</li>
<li>
<p><strong>public</strong></p>
<p>All files inside a top-level directory called <code>public</code> are served as-is to the client. When referencing these assets, do not include <code>public/</code> in the URL, write the URL as if they were all in the top level. For example, reference <code>public/bg.png</code> as <code>&lt;img src='/bg.png' /&gt;</code>. This is the best place for <code>favicon.ico</code>, <code>robots.txt</code>, and similar files.</p>
</li>
<li>
<p><strong>private</strong></p>
<p>All files inside a top-level directory called <code>private</code> are only accessible from server code and can be loaded via the <a href="http://localhost:3000/#assets"><code>Assets</code></a> API. This can be used for private data files and any files that are in your project directory that you don't want to be accessible from the outside.</p>
</li>
<li>
<p><strong>client/compatibility</strong></p>
<p>This folder is for compatibility JavaScript libraries that rely on variables declared with var at the top level being exported as globals. Files in this directory are executed without being wrapped in a new variable scope. These files are executed before other client-side JavaScript files.</p>
</li>
<li>
<p><strong>tests</strong></p>
<p>Any directory named <code>tests</code> is not loaded anywhere. Use this for any local test code.</p>
</li>
</ul>
<h3 id="filesoutsidespecialdirectories">Files outside special directories</h3>
<p>All JavaScript files outside special directories are loaded on both the client and the server. That's the place for model definitions and other functions. Meteor provides the variables <a href="http://localhost:3000/#meteor_isclient"><code>Meteor.isClient</code></a> and <a href="http://localhost:3000/#meteor_isserver"><code>Meteor.isServer</code></a> so that your code can alter its behavior depending on whether it's running on the client or the server.</p>
<p>CSS and HTML files outside special directories are loaded on the client only, and cannot be used from server code.</p>
<h3 id="examplefilestructure">Example File Structure</h3>
<p>The file structure of your Meteor app is very flexible. Here is an example layout that takes advantage of some of the special folders mentioned above.</p>
<pre><code class="hljs bash">lib/                      <span class="hljs-comment"># common code like collections and utilities</span>
lib/methods.js            <span class="hljs-comment"># Meteor.methods definitions</span>
lib/constants.js          <span class="hljs-comment"># constants used in the rest of the code</span>

client/compatibility      <span class="hljs-comment"># legacy libraries that expect to be global</span>
client/lib/               <span class="hljs-comment"># code for the client to be loaded first</span>
client/lib/helpers.js     <span class="hljs-comment"># useful helpers for your client code</span>
client/body.html          <span class="hljs-comment"># content that goes in the &lt;body&gt; of your HTML</span>
client/head.html          <span class="hljs-comment"># content for &lt;head&gt; of your HTML: &lt;meta&gt; tags, etc</span>
client/style.css          <span class="hljs-comment"># some CSS code</span>
client/&lt;feature&gt;.html     <span class="hljs-comment"># HTML templates related to a certain feature</span>
client/&lt;feature&gt;.js       <span class="hljs-comment"># JavaScript code related to a certain feature</span>

server/lib/permissions.js <span class="hljs-comment"># sensitive permissions code used by your server</span>
server/publications.js    <span class="hljs-comment"># Meteor.publish definitions</span>

public/favicon.ico        <span class="hljs-comment"># app icon</span>

settings.json             <span class="hljs-comment"># configuration data to be passed to meteor --settings</span>
mobile-config.js          <span class="hljs-comment"># define icons and metadata for Android/iOS</span>
</code></pre>
<p>You can also model your directory structure after the example apps. Run <code>meteor create --example todos</code> and explore the directories to see where all the files in a real app could go.</p>
<h3 id="fileloadorder">File Load Order</h3>
<p>It is best to write your application in such a way that it is insensitive to the order in which files are loaded, for example by using <a href="http://localhost:3000/#meteor_startup">Meteor.startup</a>, or by moving load order sensitive code into <a href="http://localhost:3000/#usingpackages">packages</a>, which can explicitly control both the load order of their contents and their load order with respect to other packages. However, sometimes load order dependencies in your application are unavoidable.</p>
<p>There are several load ordering rules. They are <em>applied sequentially</em> to all applicable files in the application, in the priority given below:</p>
<ol>
<li>HTML template files are <em>always</em> loaded before everything else</li>
<li>Files beginning with <code>main.</code> are loaded last</li>
<li>Files inside <em>any</em> <code>lib/</code> directory are loaded next</li>
<li>Files with deeper paths are loaded next</li>
<li>Files are then loaded in alphabetical order of the entire path</li>
</ol>
<pre><code class="hljs js">nav.html
main.html
client/lib/methods.js
client/lib/styles.js
lib/feature/styles.js
lib/collections.js
client/feature-y.js
feature-x.js
client/main.js
</code></pre>
<p>For example, the files above are arranged in the correct load order. <code>main.html</code> is loaded second because HTML templates are always loaded first, even if it begins with <code>main.</code>, since rule 1 has priority over rule 2. However, it will be loaded after <code>nav.html</code> because rule 2 has priority over rule 5.</p>
<p><code>client/lib/styles.js</code> and <code>lib/feature/styles.js</code> have identical load order up to rule 4; however, since <code>client</code> comes before <code>lib</code> alphabetically, it will be loaded first.</p>
<h3 id="organizingyourproject">Organizing Your Project</h3>
<p>There are three main ways to organize your files into features or components. Let's say we have two types of objects in our project: <strong>apples</strong> and <strong>oranges</strong>.</p>
<h4 id="method1rootlevelfolders">Method 1: Root-Level Folders</h4>
<p>Since the special <code>client</code>, <code>server</code>, and <code>lib</code> directories work if they are anywhere in the path, you can use top-level folders to organize code into modules:</p>
<pre><code class="hljs bash">apples/lib/               <span class="hljs-comment"># code for apple-related features</span>
apples/client/
apples/server/

oranges/lib/              <span class="hljs-comment"># code for orange-related features</span>
oranges/client/
oranges/server/
</code></pre>
<h4 id="method2foldersinsideclientandserver">Method 2: Folders inside client/ and server/</h4>
<pre><code class="hljs bash">lib/apples/               <span class="hljs-comment"># common code for apples</span>
lib/oranges/              <span class="hljs-comment"># and oranges</span>

client/apples/            <span class="hljs-comment"># client code for apples</span>
client/oranges/           <span class="hljs-comment"># and oranges</span>

server/apples/            <span class="hljs-comment"># server code for apples</span>
server/oranges/           <span class="hljs-comment"># and oranges</span>
</code></pre>
<h4 id="method3packages">Method 3: Packages</h4>
<p>This is the ultimate in code separation, modularity, and reusability. If you put the code for each feature in a separate package, the code for one feature won't be able to access the code for the other feature except through exports, making every dependency explicit. This also allows for the easiest independent testing of features. You can also publish the packages and use them in multiple apps with <code>meteor add</code>.</p>
<pre><code class="hljs bash">packages/apples/package.js     <span class="hljs-comment"># files, dependencies, exports for apple feature</span>
packages/apples/&lt;anything&gt;.js  <span class="hljs-comment"># file loading is controlled by package.js</span>

packages/oranges/package.js    <span class="hljs-comment"># files, dependencies, exports for orange feature</span>
packages/oranges/&lt;anything&gt;.js <span class="hljs-comment"># file loading is controlled by package.js</span>
</code></pre>
<h2 id="dataandsecurity">Data and security</h2>
<p>Meteor makes writing distributed client code as simple as talking to a local database. It's a clean, simple, and secure approach that removes the need to implement individual RPC endpoints, manually cache data on the client to avoid slow roundtrips to the server, and carefully orchestrate invalidation messages to every client as data changes.</p>
<p>In Meteor, the client and server share the same database API. The same exact application code &mdash; like validators and computed properties &mdash; can often run in both places. But while code running on the server has direct access to the database, code running on the client does <em>not</em>. This distinction is the basis for Meteor's data security model.</p>
<div class="note">
<p>By default, a new Meteor app includes the <code>autopublish</code> and <code>insecure</code> packages, which together mimic the effect of each client having full read/write access to the server's database. These are useful prototyping tools, but typically not appropriate for production applications. When you're ready, just remove the packages.</p>
</div>
<p>Every Meteor client includes an in-memory database cache. To manage the client cache, the server <em>publishes</em> sets of JSON documents, and the client <em>subscribes</em> to those sets. As documents in a set change, the server patches each client's cache.</p>
<p>Today most Meteor apps use MongoDB as their database because it is the best supported, though support for other databases is coming in the future. The <a href="http://localhost:3000/#mongo_collection"><code>Mongo.Collection</code></a> class is used to declare Mongo collections and to manipulate them. Thanks to <code>minimongo</code>, Meteor's client-side Mongo emulator, <code>Mongo.Collection</code> can be used from both client and server code.</p>
<pre><code class="hljs js"><span class="hljs-comment">// declare collections</span>
<span class="hljs-comment">// this code should be included in both the client and the server</span>
Rooms = <span class="hljs-keyword">new</span> Mongo.Collection(<span class="hljs-string">"rooms"</span>);
Messages = <span class="hljs-keyword">new</span> Mongo.Collection(<span class="hljs-string">"messages"</span>);
Parties = <span class="hljs-keyword">new</span> Mongo.Collection(<span class="hljs-string">"parties"</span>);

<span class="hljs-comment">// server: populate collections with some initial documents</span>
Rooms.insert({name: <span class="hljs-string">"Conference Room A"</span>});
<span class="hljs-keyword">var</span> myRooms = Rooms.find({}).fetch();
Messages.insert({text: <span class="hljs-string">"Hello world"</span>, room: myRooms[<span class="hljs-number">0</span>]._id});
Parties.insert({name: <span class="hljs-string">"Super Bowl Party"</span>});
</code></pre>
<p>Each document set is defined by a publish function on the server. The publish function runs each time a new client subscribes to a document set. The data in a document set can come from anywhere, but the common case is to publish a database query.</p>
<pre><code class="hljs js"><span class="hljs-comment">// server: publish all room documents</span>
Meteor.publish(<span class="hljs-string">"all-rooms"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> Rooms.find(); <span class="hljs-comment">// everything</span>
});

<span class="hljs-comment">// server: publish all messages for a given room</span>
Meteor.publish(<span class="hljs-string">"messages"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(roomId)</span> </span>{
  check(roomId, <span class="hljs-built_in">String</span>);
  <span class="hljs-keyword">return</span> Messages.find({room: roomId});
});

<span class="hljs-comment">// server: publish the set of parties the logged-in user can see.</span>
Meteor.publish(<span class="hljs-string">"parties"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> Parties.find({$or: [{<span class="hljs-string">"public"</span>: <span class="hljs-literal">true</span>},
                             {invited: <span class="hljs-keyword">this</span>.userId},
                             {owner: <span class="hljs-keyword">this</span>.userId}]});
});
</code></pre>
<p>Publish functions can provide different results to each client. In the last example, a logged in user can only see <code>Party</code> documents that are public, that the user owns, or that the user has been invited to.</p>
<p>Once subscribed, the client uses its cache as a fast local database, dramatically simplifying client code. Reads never require a costly round trip to the server. And they're limited to the contents of the cache: a query for every document in a collection on a client will only return documents the server is publishing to that client.</p>
<pre><code class="hljs js"><span class="hljs-comment">// client: start a parties subscription</span>
Meteor.subscribe(<span class="hljs-string">"parties"</span>);

<span class="hljs-comment">// client: return array of Parties this client can read</span>
<span class="hljs-keyword">return</span> Parties.find().fetch(); <span class="hljs-comment">// synchronous!</span>
</code></pre>
<p>Sophisticated clients can turn subscriptions on and off to control how much data is kept in the cache and manage network traffic. When a subscription is turned off, all its documents are removed from the cache unless the same document is also provided by another active subscription.</p>
<p>When the client <em>changes</em> one or more documents, it sends a message to the server requesting the change. The server checks the proposed change against a set of allow/deny rules you write as JavaScript functions. The server only accepts the change if all the rules pass.</p>
<pre><code class="hljs js"><span class="hljs-comment">// server: don't allow client to insert a party</span>
Parties.allow({
  insert: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(userId, party)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
});

<span class="hljs-comment">// client: this will fail</span>
<span class="hljs-keyword">var</span> party = { ... };
Parties.insert(party);
</code></pre>
<p>If the server accepts the change, it applies the change to the database and automatically propagates the change to other clients subscribed to the affected documents. If not, the update fails, the server's database remains untouched, and no other client sees the update.</p>
<p>Meteor has a cute trick, though. When a client issues a write to the server, it also updates its local cache immediately, without waiting for the server's response. This means the screen will redraw right away. If the server accepted the update &mdash; what ought to happen most of the time in a properly behaving client &mdash; then the client got a jump on the change and didn't have to wait for the round trip to update its own screen. If the server rejects the change, Meteor patches up the client's cache with the server's result.</p>
<p>Putting it all together, these techniques accomplish latency compensation. Clients hold a fresh copy of the data they need, and never need to wait for a roundtrip to the server. And when clients modify data, those modifications can run locally without waiting for the confirmation from the server, while still giving the server final say over the requested change.</p>
<div class="note">
<p>The current release of Meteor supports MongoDB, the popular document database, and the examples in this section use the <a href="http://www.mongodb.org/display/DOCS/Manual">MongoDB API</a>. Future releases will include support for other databases.</p>
</div>
<h3 id="dataandsecurity-authentication">Authentication and user accounts</h3>
<p>Meteor includes <a href="http://localhost:3000/#accounts_api">Meteor Accounts</a>, a state-of-the-art authentication system. It features secure password login using the <a href="http://en.wikipedia.org/wiki/Bcrypt">bcrypt</a> algorithm, and integration with external services including Facebook, GitHub, Google, Meetup, Twitter, and Weibo. Meteor Accounts defines a <a href="http://localhost:3000/#meteor_users"><code>Meteor.users</code></a> collection where developers can store application-specific user data.</p>
<p>Meteor also includes pre-built forms for common tasks like login, signup, password change, and password reset emails. You can add <a href="http://localhost:3000/#accountsui">Accounts UI</a> to your app with just one line of code. The <code>accounts-ui</code> package even provides a configuration wizard that walks you through the steps to set up the external login services you're using in your app.</p>
<h3 id="dataandsecurity-validation">Input validation</h3>
<p>Meteor allows your methods and publish functions to take arguments of any <a href="http://json.org/">JSON</a> type. (In fact, Meteor's wire protocol supports <a href="http://localhost:3000/#ejson">EJSON</a>, an extension of JSON which also supports other common types like dates and binary buffers.) JavaScript's dynamic typing means you don't need to declare precise types of every variable in your app, but it's usually helpful to ensure that the arguments that clients are passing to your methods and publish functions are of the type that you expect.</p>
<p>Meteor provides a <a href="http://localhost:3000/#check_package">lightweight library</a> for checking that arguments and other values are the type you expect them to be. Simply start your functions with statements like <code>check(username, String)</code> or <code>check(office, {building: String, room: Number})</code>. The <code>check</code> call will throw an error if its argument is of an unexpected type.</p>
<p>Meteor also provides an easy way to make sure that all of your methods and publish functions validate all of their arguments. Just run <code>meteor add <a href="http://localhost:3000/#auditargumentchecks">audit-argument-checks</a></code> and any method or publish function which skips <code>check</code>ing any of its arguments will fail with an exception.</p>
<h2 id="reactivity">Reactivity</h2>
<p>Meteor embraces the concept of <a href="http://en.wikipedia.org/wiki/Reactive_programming">reactive programming</a>. This means that you can write your code in a simple imperative style, and the result will be automatically recalculated whenever data changes that your code depends on.</p>
<pre><code class="hljs javascript">Tracker.autorun(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  Meteor.subscribe(<span class="hljs-string">"messages"</span>, Session.get(<span class="hljs-string">"currentRoomId"</span>));
});
</code></pre>
<p>This example (taken from a chat room client) sets up a data subscription based on the session variable <code>currentRoomId</code>. If the value of <code>Session.get("currentRoomId")</code> changes for any reason, the function will be automatically re-run, setting up a new subscription that replaces the old one.</p>
<p>This automatic recomputation is achieved by a cooperation between <code>Session</code> and <code>Tracker.autorun</code>. <code>Tracker.autorun</code> performs an arbitrary "reactive computation" inside of which data dependencies are tracked, and it will re-run its function argument as necessary. Data providers like <code>Session</code>, on the other hand, make note of the computation they are called from and what data was requested, and they are prepared to send an invalidation signal to the computation when the data changes.</p>
<p>This simple pattern (reactive computation + reactive data source) has wide applicability. Above, the programmer is saved from writing unsubscribe/resubscribe calls and making sure they are called at the right time. In general, Meteor can eliminate whole classes of data propagation code which would otherwise clog up your application with error-prone logic.</p>
<p>These Meteor functions run your code as a reactive computation:</p>
<ul>
<li><a href="http://localhost:3000/#livehtmltemplates">Templates</a></li>
<li><a href="http://localhost:3000/#tracker_autorun"><code>Tracker.autorun</code></a></li>
<li><a href="http://localhost:3000/#blaze_render"><code>Blaze.render</code></a> and <a href="http://localhost:3000/#blaze_renderwithdata"><code>Blaze.renderWithData</code></a></li>
</ul>
<p>And the reactive data sources that can trigger changes are:</p>
<ul>
<li><a href="http://localhost:3000/#session"><code>Session</code></a> variables</li>
<li>Database queries on <a href="http://localhost:3000/#find">Collections</a></li>
<li><a href="http://localhost:3000/#meteor_status"><code>Meteor.status</code></a></li>
<li>The <code>ready()</code> method on a <a href="http://localhost:3000/#meteor_subscribe">subscription handle</a></li>
<li><a href="http://localhost:3000/#meteor_user"><code>Meteor.user</code></a></li>
<li><a href="http://localhost:3000/#meteor_userid"><code>Meteor.userId</code></a></li>
<li><a href="http://localhost:3000/#meteor_loggingin"><code>Meteor.loggingIn</code></a></li>
</ul>
<p>In addition, the following functions which return an object with a <code>stop</code> method, if called from a reactive computation, are stopped when the computation is rerun or stopped:</p>
<ul>
<li><a href="http://localhost:3000/#tracker_autorun"><code>Tracker.autorun</code></a> (nested)</li>
<li><a href="http://localhost:3000/#meteor_subscribe"><code>Meteor.subscribe</code></a></li>
<li><a href="http://localhost:3000/#observe"><code>observe()</code></a> and <a href="http://localhost:3000/#observe_changes"><code>observeChanges()</code></a> on cursors</li>
</ul>
<p>Meteor's <a href="https://github.com/meteor/meteor/blob/master/packages/tracker/tracker.js">implementation</a> is a package called <a href="http://localhost:3000/#tracker"><code>Tracker</code></a> that is fairly short and straightforward. You can use it yourself to implement new reactive data sources.</p>
<h2 id="livehtmltemplates">Live HTML templates</h2>
<p>HTML templating is central to web applications. With Blaze, Meteor's live page update technology, you can render your HTML <em>reactively</em>, meaning that it will update automatically to track changes in the data used to generate it.</p>
<p>Meteor makes it easy to use your favorite HTML templating language along with Meteor's live page update technology. Just write your template as you normally would, and Meteor will take care of making it update in realtime.</p>
<p>Meteor ships with a templating language called <a href="https://github.com/meteor/meteor/blob/devel/packages/spacebars/README.md">Spacebars</a>, inspired by <a href="http://handlebarsjs.com/">Handlebars</a>. It shares some of the spirit and syntax of Handlebars, but it has been tailored to produce reactive Meteor templates when compiled.</p>
<div class="note">
<p>Today, the only templating system that ships with Meteor is Spacebars, though our community has created packages for other languages such as <a href="https://atmospherejs.com/mquandalle/jade">Jade</a>.</p>
</div>
<p>To define templates, create a file in your project with the <code>.html</code> extension. In the file, make a <code>&lt;template&gt;</code> tag and give it a <code>name</code> attribute. Put the template contents inside the tag. Meteor will precompile the template, ship it down to the client, and make it available as on the global <code>Template</code> object.</p>
<p>When your app is loaded, it automatically renders the special template called <code>&lt;body&gt;</code>, which is written using the <code>&lt;body&gt;</code> element instead of a <code>&lt;template&gt;</code>. You insert a template inside another template by using the <code>{{&gt; inclusion}}</code> operator.</p>
<p>The easiest way to get data into templates is by defining helper functions in JavaScript. Define helpers with the <code>Template.templateName.helpers({ ... })</code> function. Putting it all together:</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- in myapp.html --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>Today's weather!<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
  {{&gt; forecast}}
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"forecast"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>It'll be {{prediction}} tonight<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>
<pre><code class="hljs js"><span class="hljs-comment">// in client/myapp.js: reactive helper function</span>
Template.forecast.helpers({
  prediction: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> Session.get(<span class="hljs-string">"weather"</span>);
  }
});
</code></pre>
<pre><code class="hljs js"><span class="hljs-comment">// in the JavaScript console</span>
&gt; Session.set(<span class="hljs-string">"weather"</span>, <span class="hljs-string">"cloudy"</span>);
&gt; <span class="hljs-built_in">document</span>.body.innerHTML
 =&gt; <span class="hljs-string">"&lt;h1&gt;Today's weather!&lt;/h1&gt; &lt;div&gt;It'll be cloudy tonight&lt;/div&gt;"</span>

&gt; Session.set(<span class="hljs-string">"weather"</span>, <span class="hljs-string">"cool and dry"</span>);
&gt; <span class="hljs-built_in">document</span>.body.innerHTML
 =&gt; <span class="hljs-string">"&lt;h1&gt;Today's weather!&lt;/h1&gt; &lt;div&gt;It'll be cool and dry tonight&lt;/div&gt;"</span>
</code></pre>
<p>To iterate over an array or database cursor, use <code>{{#each}}</code>:</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- in myapp.html --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"players"</span>&gt;</span>
  {{#each topScorers}}
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>{{name}}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  {{/each}}
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>
<pre><code class="hljs js"><span class="hljs-comment">// in myapp.js</span>
Template.players.helpers({
  topScorers: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> Users.find({score: {$gt: <span class="hljs-number">100</span>}}, {sort: {score: -<span class="hljs-number">1</span>}});
  }
});
</code></pre>
<p>In this case, the data is coming from a database query. When the database cursor is passed to <code>{{#each}}</code>, it will wire up all of the machinery to efficiently add and move DOM nodes as new results enter the query.</p>
<p>Helpers can take arguments, and they receive the current template context data in <code>this</code>. Note that some block helpers change the current context (notably <code>{{#each}}</code> and <code>{{#with}}</code>):</p>
<pre><code class="hljs js"><span class="hljs-comment">// in a JavaScript file</span>
Template.players.helpers({
  leagueIs: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(league)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.league === league;
  }
});
</code></pre>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- in a HTML file --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"players"</span>&gt;</span>
  {{#each topScorers}}
    {{#if leagueIs "junior"}}
      <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Junior: {{name}}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    {{/if}}
    {{#if leagueIs "senior"}}
      <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Senior: {{name}}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    {{/if}}
  {{/each}}
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>
<p>Helpers can also be used to pass in constant data.</p>
<pre><code class="hljs js"><span class="hljs-comment">// Works fine with {{#each sections}}</span>
Template.report.helpers({
  sections: [<span class="hljs-string">"Situation"</span>, <span class="hljs-string">"Complication"</span>, <span class="hljs-string">"Resolution"</span>]
});
</code></pre>
<p>Finally, you can use the <code>events</code> function on a template to attach event handlers. The object passed into <code>events</code> is documented at <a href="http://localhost:3000/#eventmaps">Event Maps</a>. The <code>this</code> argument to the event handler will be the data context of the element that triggered the event.</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- myapp.html --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"scores"</span>&gt;</span>
  {{#each player}}
    {{&gt; playerScore}}
  {{/each}}
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"playerScore"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>{{name}}: {{score}}
    <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"give-points"</span>&gt;</span>Give points<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>
<pre><code class="hljs js"><span class="hljs-comment">// myapp.js</span>
Template.playerScore.events({
  <span class="hljs-string">'click .give-points'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    Users.update(<span class="hljs-keyword">this</span>._id, {$inc: {score: <span class="hljs-number">2</span>}});
  }
});
</code></pre>
<p>For more details about Spacebars, read <a href="https://github.com/meteor/meteor/blob/devel/packages/spacebars/README.md">the Spacebars README</a>.</p>
<h2 id="usingpackages">Using packages</h2>
<p>All of the functionality you've read about so far is implemented in standard Meteor packages. This is possible thanks to Meteor's unusually powerful isomorphic package and build system. Isomorphic means the same packages work in the web browser, in mobile apps, and on the server. Packages can also contain plugins that extend the build process, such as <code>coffeescript</code> (<a href="http://coffeescript.org">CoffeeScript</a> compilation) or <code>templating</code> (compiling HTML templates).</p>
<p>Anyone can publish a Meteor package, and thousands of community-written packages have been published to date. The easiest way to browse these packages is <a href="http://www.atmospherejs.com">Atmosphere</a>, by Percolate Studio. You can also use the <a href="http://localhost:3000/#meteorsearch"><code>meteor search</code></a> and <a href="http://localhost:3000/#meteorshow"><code>meteor show</code></a> commands.</p>
<p>You can add packages to your project with <a href="http://localhost:3000/#meteoradd"><code>meteor add</code></a> and remove them with <a href="http://localhost:3000/#meteorremove"><code>meteor remove</code></a>. Additionally, <a href="http://localhost:3000/#meteorlist"><code>meteor list</code></a> will tell you what packages your project is using, and <a href="http://localhost:3000/#meteorupdate"><code>meteor update</code></a> will update them to the newest versions when possible.</p>
<p>By default all apps include the <code>meteor-platform</code> package. This automatically pulls in the packages that make up the core Meteor stack. If you want to build your own custom stack, just remove <code>meteor-platform</code> from your app and add back in whichever of the standard packages you want to keep.</p>
<p>Meteor uses a single-loading packaging system, meaning that it loads just one version of every package. Before adding or upgrading to a particular version of a package, Meteor uses a constraint solver to check if doing so will cause other packages to break. By default, Meteor will choose conservatively. When adding transitive dependencies (packages that other packages, but not the application itself) depend on, Meteor will try to choose the earlier version.</p>
<p>In addition to the packages in the official Meteor release being used by your app, <code>meteor list</code> and <code>meteor add</code> also search the <code>packages</code> directory at the top of your app. You can also use the <code>packages</code> directory to break your app into subpackages for your convenience, or to test packages that you might want to publish. See <a href="http://localhost:3000/#writingpackages">Writing Packages</a>.</p>
<p>&nbsp;</p>
<h2 id="namespacing">Namespacing</h2>
<p>&nbsp;</p>
<p>Meteor's namespacing support makes it easy to write large applications in JavaScript. Each package that you use in your app exists in its own separate namespace, meaning that it sees only its own global variables and any variables provided by the packages that it specifically uses. Here's how it works.</p>
<p>When you declare a top-level variable, you have a choice. You can make the variable File Scope or Package Scope.</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// File Scope. This variable will be visible only inside this</span>
<span class="hljs-comment">// one file. Other files in this app or package won't see it.</span>
<span class="hljs-keyword">var</span> alicePerson = {name: <span class="hljs-string">"alice"</span>};

<span class="hljs-comment">// Package Scope. This variable is visible to every file inside</span>
<span class="hljs-comment">// of this package or app. The difference is that 'var' is</span>
<span class="hljs-comment">// omitted.</span>
bobPerson = {name: <span class="hljs-string">"bob"</span>};
</code></pre>
<p>Notice that this is just the normal JavaScript syntax for declaring a variable that is local or global. Meteor scans your source code for global variable assignments and generates a wrapper that makes sure that your globals don't escape their appropriate namespace.</p>
<p>In addition to File Scope and Package Scope, there are also Exports. An export is a variable that a package makes available to you when you use it. For example, the <code>email</code> package exports the <code>Email</code> variable. If your app uses the <code>email</code> package (and <em>only</em> if it uses the <code>email</code> package!) then your app can see <code>Email</code> and you can call <code>Email.send</code>. Most packages have only one export, but some packages might have two or three (for example, a package that provides several classes that work together).</p>
<p>You see only the exports of the packages that you use directly. If you use package A, and package A uses package B, then you only see package A's exports. Package B's exports don't "leak" into your namespace just because you used package A. This keeps each namespace nice and tidy. Each app or package only sees their own globals plus the APIs of the packages that they specifically asked for.</p>
<p>When debugging your app, your browser's JavaScript console behaves as if it were attached to your app's namespace. You see your app's globals and the exports of the packages that your app uses directly. You don't see the variables from inside those packages, and you don't see the exports of your transitive dependencies (packages that aren't used directly by your app, but that are used by packages that are used by your app).</p>
<p>If you want to look inside packages from inside your in-browser debugger, you've got two options:</p>
<ul>
<li>
<p>Set a breakpoint inside package code. While stopped on that breakpoint, the console will be in the package's namespace. You'll see the package's package-scope variables, imports, and also any file-scope variables for the file you're stopped in.</p>
</li>
<li>
<p>If a package <code>foo</code> is included in your app, regardless of whether your app uses it directly, its exports are available in <code>Package.foo</code>. For example, if the <code>email</code> package is loaded, then you can access <code>Package.email.Email.send</code> even from namespaces that don't use the <code>email</code> package directly.</p>
</li>
</ul>
<p>When declaring functions, keep in mind that <code>function x () {}</code> is just shorthand for <code>var x = function x () {}</code> in JavaScript. Consider these examples:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// This is the same as 'var x = function x () ...'. So x() is</span>
<span class="hljs-comment">// file-scope and can be called only from within this one file.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span> <span class="hljs-params">()</span> </span>{ ... }

<span class="hljs-comment">// No 'var', so x() is package-scope and can be called from</span>
<span class="hljs-comment">// any file inside this app or package.</span>
x = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ ... }
</code></pre>
<div class="note">
<p>Technically speaking, globals in an app (as opposed to in a package) are actually true globals. They can't be captured in a scope that is private to the app code, because that would mean that they wouldn't be visible in the console during debugging! This means that app globals actually end up being visible in packages. That should never be a problem for properly written package code (since the app globals will still be properly shadowed by declarations in the packages). You certainly shouldn't depend on this quirk, and in the future Meteor may check for it and throw an error if you do.</p>
</div>
<h2 id="deploying">Deploying</h2>
<p>Meteor is a full application server. We include everything you need to deploy your application on the internet: you just provide the JavaScript, HTML, and CSS.</p>
<h3 class="nosection">Running on Meteor's infrastructure</h3>
<p>The easiest way to deploy your application is to use <code>meteor deploy</code>. We provide it because it's what, personally, we've always wanted: an easy way to take an app idea, flesh it out over a weekend, and put it out there for the world to use, with nothing getting in the way of creativity.</p>
<pre><code class="hljs ruby"><span class="hljs-variable">$ </span>meteor deploy myapp.meteor.com
</code></pre>
<p>Your application is now available at myapp.meteor.com. If this is the first time deploying to this hostname, Meteor creates a fresh empty database for your application. If you want to deploy an update, Meteor will preserve the existing data and just refresh the code.</p>
<p>You can also deploy to your own domain. Just set up the hostname you want to use as a CNAME to <code>origin.meteor.com</code>, then deploy to that name.</p>
<pre><code class="hljs ruby"><span class="hljs-variable">$ </span>meteor deploy www.myapp.com
</code></pre>
<p>We provide this as a free service so you can try Meteor. It is also helpful for quickly putting up internal betas, demos, and so on. For more information, see <a href="http://localhost:3000/#meteordeploy">meteor deploy</a>.</p>
<h3 class="nosection">Running on your own infrastructure</h3>
<p>You can also run your application on your own infrastructure or any hosting provider that can run Node.js apps.</p>
<p>To get started, run</p>
<pre><code class="hljs ruby"><span class="hljs-variable">$ </span>meteor build my_directory
</code></pre>
<p>This command will generate a fully-contained Node.js application in the form of a tarball. To run this application, you need to provide Node.js 0.10 and a MongoDB server. (The current release of Meteor has been tested with Node 0.10.36.) You can then run the application by invoking node, specifying the HTTP port for the application to listen on, and the MongoDB endpoint.</p>
<pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> my_directory
$ (<span class="hljs-built_in">cd</span> programs/server &amp;&amp; npm install)
$ PORT=<span class="hljs-number">3000</span> MONGO_URL=mongodb://localhost:<span class="hljs-number">27017</span>/myapp node main.js
</code></pre>
<p>Some packages might require other environment variables. For example, the <code>email</code> package requires a <code>MAIL_URL</code> environment variable.</p>
<p>&nbsp;</p>
<h2 id="writingpackages">Writing packages</h2>
<p>&nbsp;</p>
<p>Writing Meteor packages is easy. To initialize a meteor package, run <code>meteor create --package username:packagename</code>, where <code>username</code> is your Meteor Developer username. This will create a package from scratch and prefill the directory with a package.js control file and some javascript. By default, Meteor will take the package name from the name of the directory that contains the package.js file. Don't forget to run <code>meteor add [packagename]</code>, even if the package is internal to the app, in order to use it.</p>
<p>Meteor promises repeatable builds for both packages and applications. This means that, if you built your package on a machine, then checked the code into a repository and checked it out elsewhere, you should get the same result. In your package directory, you will find an automatically generated <code>.versions</code> file. This file specifies the versions of all packages used to build your package and is part of the source. Check it into version control to ensure repeatable builds across machines.</p>
<div class="note">
<p>Sometimes, packages do not just stand on their own, but function in the context of an app (specifically, packages in the packages directory of an app). In that case, the app's context will take precedence. Rather than using the <code>.versions</code> file as a guide, we will build the package with the same dependencies as used by the app (we think that, in practice, it would be confusing to find your local packages built with different versions of things).</p>
</div>
<p>Meteor uses extended semver versioning for its packages: that means that the version number has three parts separated by dots: major version, minor version and patch version (for example: 1.2.3) with an optional pre-release version. You can read more about it on <a href="http://www.semver.org">semver.org</a>. Additionally, because some meteor packages wrap external libraries, Meteor supports the convention of using <code>_</code> to denote a wrap number.</p>
<p>You can read more about <a href="http://localhost:3000/#packagejs"><code>package.js</code></a> files in the API section.</p>
<p>A word on testing: since testing is an important part of the development process, there are two common ways to test a package:</p>
<ul>
<li>
<p>Integration tests (putting a package directly into an application, and writing tests against the application) is the most common way to test a package. After creating your package, add it to your app's /packages directory and run <code>meteor add</code>. This will add your package to your app as a local package. You can then test and run your app as usual. Meteor will detect and respond to changes to your local package, just as it does to your app files.</p>
</li>
<li>
<p>Unit tests are run with the command <a href="http://localhost:3000/#meteortestpackages"><code>meteor test-packages package-name</code></a>. As described in the <a href="http://localhost:3000/#packagejs"><code>package.js</code></a> section, you can use the <code>package.js</code> file to specify where your unit tests are located. If you have a repository that contains only the package source, you can test your package by specifying the path to the package directory (which must contain a slash), such as <code>meteor test-packages ./</code>.</p>
</li>
</ul>
<p>To publish a package, run <a href="http://localhost:3000/#meteorpublish"><code>meteor publish</code></a> from the package directory. There are some extra restrictions on published packages: they must contain a version (Meteor packages are versioned using strict <a href="http://www.semver.org">semver</a> versioning) and their names must be prefixed with the username of the author and a colon, like so: <code>iron:router</code>. This namespacing allows for more descriptive and on-topic package names.</p>
<h1 id="api">The Meteor API</h1>
<p>Your JavaScript code can run in two environments: the <em>client</em> (browser), and the <em>server</em> (a <a href="http://nodejs.org/">Node.js</a> container on a server). For each function in this API reference, we'll indicate if the function is available just on the client, just on the server, or <em>Anywhere</em>.</p>
<h2 id="core">Meteor Core</h2>
<div class="api new-api-box">
<h3 id="meteor_isclient" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_isclient">Meteor.isClient</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Boolean variable. True if running in client environment.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="meteor_isserver" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_isserver">Meteor.isServer</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Boolean variable. True if running in server environment.</p>
</div>
</div>
<div class="note">
<p><code>Meteor.isServer</code> can be used to limit where code runs, but it does not prevent code from being sent to the client. Any sensitive code that you don't want served to the client, such as code containing passwords or authentication mechanisms, should be kept in the <code>server</code> directory.</p>
</div>
<div class="api new-api-box">
<h3 id="meteor_iscordova" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_iscordova">Meteor.isCordova</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Boolean variable. True if running in a Cordova mobile environment.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="meteor_startup" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_startup">Meteor.startup(func)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Run code when a client or a server starts.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">func</span> <span class="type">Function</span></dt>
<dd>
<p>A function to run on startup.</p>
</dd>
</dl>
</div>
<p>On a server, the function will run as soon as the server process is finished starting. On a client, the function will run as soon as the DOM is ready.</p>
<p>The <code>startup</code> callbacks are called in the same order as the calls to <code>Meteor.startup</code> were made.</p>
<p>On a client, <code>startup</code> callbacks from packages will be called first, followed by <code>&lt;body&gt;</code> templates from your <code>.html</code> files, followed by your application code.</p>
<pre><code class="hljs sql">// On server startup, if the database is empty, <span class="hljs-operator"><span class="hljs-keyword">create</span> <span class="hljs-keyword">some</span> initial <span class="hljs-keyword">data</span>.
<span class="hljs-keyword">if</span> (Meteor.isServer) {
  Meteor.startup(<span class="hljs-keyword">function</span> () {
    <span class="hljs-keyword">if</span> (Rooms.find().<span class="hljs-keyword">count</span>() === <span class="hljs-number">0</span>) {
      Rooms.<span class="hljs-keyword">insert</span>({name: <span class="hljs-string">"Initial room"</span>});</span>
    }
  });
}
</code></pre>
<div class="api new-api-box">
<h3 id="meteor_wrapasync" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_wrapasync">Meteor.wrapAsync(func, [context])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Wrap a function that takes a callback function as its final parameter. On the server, the wrapped function can be used either synchronously (without passing a callback) or asynchronously (when a callback is passed). On the client, a callback is always required; errors will be logged if there is no callback. If a callback is provided, the environment captured when the original function was called will be restored in the callback.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">func</span> <span class="type">Function</span></dt>
<dd>
<p>A function that takes a callback as its final parameter</p>
</dd>
<dt><span class="name">context</span> <span class="type">Object</span></dt>
<dd>
<p>Optional <code>this</code> object against which the original function will be invoked</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="meteor_absoluteurl" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_absoluteurl">Meteor.absoluteUrl([path], [options])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Generate an absolute URL pointing to the application. The server reads from the <code>ROOT_URL</code> environment variable to determine where it is running. This is taken care of automatically for apps deployed with <code>meteor deploy</code>, but must be provided when using <code>meteor build</code>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">path</span> <span class="type">String</span></dt>
<dd>
<p>A path to append to the root URL. Do not include a leading "<code>/</code>".</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">secure</span> <span class="type">Boolean</span></dt>
<dd>
<p>Create an HTTPS URL.</p>
</dd>
<dt><span class="name">replaceLocalhost</span> <span class="type">Boolean</span></dt>
<dd>
<p>Replace localhost with 127.0.0.1. Useful for services that don't recognize localhost as a domain name.</p>
</dd>
<dt><span class="name">rootUrl</span> <span class="type">String</span></dt>
<dd>
<p>Override the default ROOT_URL from the server environment. For example: "<code>http://foo.example.com</code>"</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="meteor_settings" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_settings">Meteor.settings</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p><code>Meteor.settings</code> contains deployment-specific configuration options. You can initialize settings by passing the <code>--settings</code> option (which takes the name of a file containing JSON data) to <code>meteor run</code> or <code>meteor deploy</code>. When running your server directly (e.g. from a bundle), you instead specify settings by putting the JSON directly into the <code>METEOR_SETTINGS</code> environment variable. If you don't provide any settings, <code>Meteor.settings</code> will be an empty object. If the settings object contains a key named <code>public</code>, then <code>Meteor.settings.public</code> will be available on the client as well as the server. All other properties of <code>Meteor.settings</code> are only defined on the server.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="meteor_release" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_release">Meteor.release</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p><code>Meteor.release</code> is a string containing the name of the <a href="http://localhost:3000/#meteorupdate">release</a> with which the project was built (for example, <code>"1.2.3"</code>). It is <code>undefined</code> if the project was built using a git checkout of Meteor.</p>
</div>
</div>
<h2 id="publishandsubscribe">Publish and subscribe</h2>
<p>These functions control how Meteor servers publish sets of records and how clients can subscribe to those sets.</p>
<div class="api new-api-box">
<h3 id="meteor_publish" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_publish">Meteor.publish(name, func)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Publish a record set.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">name</span> <span class="type">String</span></dt>
<dd>
<p>Name of the record set. If <code>null</code>, the set has no name, and the record set is automatically sent to all connected clients.</p>
</dd>
<dt><span class="name">func</span> <span class="type">Function</span></dt>
<dd>
<p>Function called on the server each time a client subscribes. Inside the function, <code>this</code> is the publish handler object, described below. If the client passed arguments to <code>subscribe</code>, the function is called with the same arguments.</p>
</dd>
</dl>
</div>
<p>To publish records to clients, call <code>Meteor.publish</code> on the server with two parameters: the name of the record set, and a <em>publish function</em> that Meteor will call each time a client subscribes to the name.</p>
<p>Publish functions can return a <a href="http://localhost:3000/#mongo_cursor"><code>Collection.Cursor</code></a>, in which case Meteor will publish that cursor's documents to each subscribed client. You can also return an array of <code>Collection.Cursor</code>s, in which case Meteor will publish all of the cursors.</p>
<div class="warning">
<p>If you return multiple cursors in an array, they currently must all be from different collections. We hope to lift this restriction in a future release.</p>
</div>
<pre><code class="hljs javascript"><span class="hljs-comment">// server: publish the rooms collection, minus secret info.</span>
Meteor.publish(<span class="hljs-string">"rooms"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> Rooms.find({}, {fields: {secretInfo: <span class="hljs-number">0</span>}});
});

<span class="hljs-comment">// ... and publish secret info for rooms where the logged-in user</span>
<span class="hljs-comment">// is an admin. If the client subscribes to both streams, the records</span>
<span class="hljs-comment">// are merged together into the same documents in the Rooms collection.</span>
Meteor.publish(<span class="hljs-string">"adminSecretInfo"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> Rooms.find({admin: <span class="hljs-keyword">this</span>.userId}, {fields: {secretInfo: <span class="hljs-number">1</span>}});
});

<span class="hljs-comment">// publish dependent documents and simulate joins</span>
Meteor.publish(<span class="hljs-string">"roomAndMessages"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(roomId)</span> </span>{
  check(roomId, <span class="hljs-built_in">String</span>);
  <span class="hljs-keyword">return</span> [
    Rooms.find({_id: roomId}, {fields: {secretInfo: <span class="hljs-number">0</span>}}),
    Messages.find({roomId: roomId})
  ];
});
</code></pre>
<p>Alternatively, a publish function can directly control its published record set by calling the functions <a href="http://localhost:3000/#publish_added"><code>added</code></a> (to add a new document to the published record set), <a href="http://localhost:3000/#publish_changed"><code>changed</code></a> (to change or clear some fields on a document already in the published record set), and <a href="http://localhost:3000/#publish_removed"><code>removed</code></a> (to remove documents from the published record set). These methods are provided by <code>this</code> in your publish function.</p>
<p>If a publish function does not return a cursor or array of cursors, it is assumed to be using the low-level <code>added</code>/<code>changed</code>/<code>removed</code> interface, and it <strong>must also call <a href="http://localhost:3000/#publish_ready"><code>ready</code></a> once the initial record set is complete</strong>.</p>
<p>Example:</p>
<pre><code class="hljs php"><span class="hljs-comment">// server: publish the current size of a collection</span>
Meteor.publish(<span class="hljs-string">"counts-by-room"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(roomId)</span> </span>{
  <span class="hljs-keyword">var</span> <span class="hljs-keyword">self</span> = this;
  check(roomId, String);
  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> initializing = <span class="hljs-keyword">true</span>;

  <span class="hljs-comment">// observeChanges only returns after the initial `added` callbacks</span>
  <span class="hljs-comment">// have run. Until then, we don't want to send a lot of</span>
  <span class="hljs-comment">// `self.changed()` messages - hence tracking the</span>
  <span class="hljs-comment">// `initializing` state.</span>
  <span class="hljs-keyword">var</span> handle = Messages.find({roomId: roomId}).observeChanges({
    added: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> </span>{
      count++;
      <span class="hljs-keyword">if</span> (!initializing)
        <span class="hljs-keyword">self</span>.changed(<span class="hljs-string">"counts"</span>, roomId, {count: count});
    },
    removed: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> </span>{
      count--;
      <span class="hljs-keyword">self</span>.changed(<span class="hljs-string">"counts"</span>, roomId, {count: count});
    }
    <span class="hljs-comment">// don't care about changed</span>
  });

  <span class="hljs-comment">// Instead, we'll send one `self.added()` message right after</span>
  <span class="hljs-comment">// observeChanges has returned, and mark the subscription as</span>
  <span class="hljs-comment">// ready.</span>
  initializing = <span class="hljs-keyword">false</span>;
  <span class="hljs-keyword">self</span>.added(<span class="hljs-string">"counts"</span>, roomId, {count: count});
  <span class="hljs-keyword">self</span>.ready();

  <span class="hljs-comment">// Stop observing the cursor when client unsubs.</span>
  <span class="hljs-comment">// Stopping a subscription automatically takes</span>
  <span class="hljs-comment">// care of sending the client any removed messages.</span>
  <span class="hljs-keyword">self</span>.onStop(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    handle.stop();
  });
});

<span class="hljs-comment">// client: declare collection to hold count object</span>
Counts = <span class="hljs-keyword">new</span> Mongo.Collection(<span class="hljs-string">"counts"</span>);

<span class="hljs-comment">// client: subscribe to the count for the current room</span>
Tracker.autorun(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  Meteor.subscribe(<span class="hljs-string">"counts-by-room"</span>, Session.get(<span class="hljs-string">"roomId"</span>));
});

<span class="hljs-comment">// client: use the new collection</span>
console.log(<span class="hljs-string">"Current room has "</span> +
            Counts.findOne(Session.get(<span class="hljs-string">"roomId"</span>)).count +
            <span class="hljs-string">" messages."</span>);

<span class="hljs-comment">// server: sometimes publish a query, sometimes publish nothing</span>
Meteor.publish(<span class="hljs-string">"secretData"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (this.userId === <span class="hljs-string">'superuser'</span>) {
    <span class="hljs-keyword">return</span> SecretData.find();
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Declare that no data is being published. If you leave this line</span>
    <span class="hljs-comment">// out, Meteor will never consider the subscription ready because</span>
    <span class="hljs-comment">// it thinks you're using the added/changed/removed interface where</span>
    <span class="hljs-comment">// you have to explicitly call this.ready().</span>
    <span class="hljs-keyword">return</span> [];
  }
});
</code></pre>
<p>Since publish functions usually expect particular types as arguments, use <a href="http://localhost:3000/#check"><code>check</code></a> liberally to ensure the arguments have the correct <a href="http://localhost:3000/#matchpatterns">types and structure</a>.</p>
<div class="warning">
<p>Meteor will emit a warning message if you call <code>Meteor.publish</code> in a project that includes the <code>autopublish</code> package. Your publish function will still work.</p>
</div>
<div class="api new-api-box">
<h3 id="publish_userId" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/publish_userId"><em>this</em>.userId</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Access inside the publish function. The id of the logged-in user, or <code>null</code> if no user is logged in.</p>
</div>
</div>
<p>This is constant. However, if the logged-in user changes, the publish function is rerun with the new value.</p>
<div class="api new-api-box">
<h3 id="publish_added" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/publish_added"><em>this</em>.added(collection, id, fields)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Call inside the publish function. Informs the subscriber that a document has been added to the record set.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">collection</span> <span class="type">String</span></dt>
<dd>
<p>The name of the collection that contains the new document.</p>
</dd>
<dt><span class="name">id</span> <span class="type">String</span></dt>
<dd>
<p>The new document's ID.</p>
</dd>
<dt><span class="name">fields</span> <span class="type">Object</span></dt>
<dd>
<p>The fields in the new document. If <code>_id</code> is present it is ignored.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="publish_changed" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/publish_changed"><em>this</em>.changed(collection, id, fields)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Call inside the publish function. Informs the subscriber that a document in the record set has been modified.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">collection</span> <span class="type">String</span></dt>
<dd>
<p>The name of the collection that contains the changed document.</p>
</dd>
<dt><span class="name">id</span> <span class="type">String</span></dt>
<dd>
<p>The changed document's ID.</p>
</dd>
<dt><span class="name">fields</span> <span class="type">Object</span></dt>
<dd>
<p>The fields in the document that have changed, together with their new values. If a field is not present in <code>fields</code> it was left unchanged; if it is present in <code>fields</code> and has a value of <code>undefined</code> it was removed from the document. If <code>_id</code> is present it is ignored.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="publish_removed" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/publish_removed"><em>this</em>.removed(collection, id)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Call inside the publish function. Informs the subscriber that a document has been removed from the record set.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">collection</span> <span class="type">String</span></dt>
<dd>
<p>The name of the collection that the document has been removed from.</p>
</dd>
<dt><span class="name">id</span> <span class="type">String</span></dt>
<dd>
<p>The ID of the document that has been removed.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="publish_ready" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/publish_ready"><em>this</em>.ready()</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Call inside the publish function. Informs the subscriber that an initial, complete snapshot of the record set has been sent. This will trigger a call on the client to the <code>onReady</code> callback passed to <a href="http://localhost:3000/#meteor_subscribe"><code>Meteor.subscribe</code></a>, if any.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="publish_onstop" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/publish_onstop"><em>this</em>.onStop(func)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Call inside the publish function. Registers a callback function to run when the subscription is stopped.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">func</span> <span class="type">Function</span></dt>
<dd>
<p>The callback function</p>
</dd>
</dl>
</div>
<p>If you call <a href="http://localhost:3000/#observe"><code>observe</code></a> or <a href="http://localhost:3000/#observe_changes"><code>observeChanges</code></a> in your publish handler, this is the place to stop the observes.</p>
<div class="api new-api-box">
<h3 id="publish_error" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/publish_error"><em>this</em>.error(error)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Call inside the publish function. Stops this client's subscription, triggering a call on the client to the <code>onStop</code> callback passed to <a href="http://localhost:3000/#meteor_subscribe"><code>Meteor.subscribe</code></a>, if any. If <code>error</code> is not a <a href="http://localhost:3000/#meteor_error"><code>Meteor.Error</code></a>, it will be <a href="http://localhost:3000/#meteor_error">sanitized</a>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">error</span> <span class="type">Error</span></dt>
<dd>
<p>The error to pass to the client.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="publish_stop" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/publish_stop"><em>this</em>.stop()</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Call inside the publish function. Stops this client's subscription and invokes the client's <code>onStop</code> callback with no error.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="publish_connection" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/publish_connection"><em>this</em>.connection</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Access inside the publish function. The incoming <a href="http://localhost:3000/#meteor_onconnection">connection</a> for this subscription.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="meteor_subscribe" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_subscribe">Meteor.subscribe(name, [arg1, arg2...], [callbacks])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Subscribe to a record set. Returns a handle that provides <code>stop()</code> and <code>ready()</code> methods.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">name</span> <span class="type">String</span></dt>
<dd>
<p>Name of the subscription. Matches the name of the server's <code>publish()</code> call.</p>
</dd>
<dt><span class="name">arg1, arg2...</span> <span class="type">Any</span></dt>
<dd>
<p>Optional arguments passed to publisher function on server.</p>
</dd>
<dt><span class="name">callbacks</span> <span class="type">Function or Object</span></dt>
<dd>
<p>Optional. May include <code>onStop</code> and <code>onReady</code> callbacks. If there is an error, it is passed as an argument to <code>onStop</code>. If a function is passed instead of an object, it is interpreted as an <code>onReady</code> callback.</p>
</dd>
</dl>
</div>
<p>When you subscribe to a record set, it tells the server to send records to the client. The client stores these records in local <a href="http://localhost:3000/#mongo_collection">Minimongo collections</a>, with the same name as the <code>collection</code> argument used in the publish handler's <a href="http://localhost:3000/#publish_added"><code>added</code></a>, <a href="http://localhost:3000/#publish_changed"><code>changed</code></a>, and <a href="http://localhost:3000/#publish_removed"><code>removed</code></a> callbacks. Meteor will queue incoming records until you declare the <a href="http://localhost:3000/#mongo_collection"><code>Mongo.Collection</code></a> on the client with the matching collection name.</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// okay to subscribe (and possibly receive data) before declaring</span>
<span class="hljs-comment">// the client collection that will hold it.  assume "allplayers"</span>
<span class="hljs-comment">// publishes data from server's "players" collection.</span>
Meteor.subscribe(<span class="hljs-string">"allplayers"</span>);
...
<span class="hljs-comment">// client queues incoming players records until ...</span>
...
Players = <span class="hljs-keyword">new</span> Mongo.Collection(<span class="hljs-string">"players"</span>);
</code></pre>
<p>The client will see a document if the document is currently in the published record set of any of its subscriptions.</p>
<p>The <code>onReady</code> callback is called with no arguments when the server <a href="http://localhost:3000/#publish_ready">marks the subscription as ready</a>. The <code>onStop</code> callback is called with a <a href="http://localhost:3000/#meteor_error"><code>Meteor.Error</code></a> if the subscription fails or is terminated by the server. If the subscription is stopped by calling <code>stop</code> on the subscription handle or inside the publication, <code>onStop</code> is called with no arguments.</p>
<p><code>Meteor.subscribe</code> returns a subscription handle, which is an object with the following properties:</p>
<dl class="callbacks">
<dt><span class="name">stop()</span></dt>
<dd>
<p>Cancel the subscription. This will typically result in the server directing the client to remove the subscription's data from the client's cache.</p>
</dd>
<dt><span class="name">ready()</span></dt>
<dd>
<p>True if the server has <a href="http://localhost:3000/#publish_ready">marked the subscription as ready</a>. A reactive data source.</p>
</dd>
<dt><span class="name">subscriptionId</span></dt>
<dd>
<p>The <code>id</code> of the subscription this handle is for. When you run <code>Meteor.subscribe</code> inside of <code>Tracker.autorun</code>, the handles you get will always have the same <code>subscriptionId</code> field. You can use this to deduplicate subscription handles if you are storing them in some data structure.</p>
</dd>
</dl>
<p>If you call <code>Meteor.subscribe</code> within a <a href="http://localhost:3000/#reactivity">reactive computation</a>, for example using <a href="http://localhost:3000/#tracker_autorun"><code>Tracker.autorun</code></a>, the subscription will automatically be cancelled when the computation is invalidated or stopped; it's not necessary to call <code>stop</code> on subscriptions made from inside <code>autorun</code>. However, if the next iteration of your run function subscribes to the same record set (same name and parameters), Meteor is smart enough to skip a wasteful unsubscribe/resubscribe. For example:</p>
<pre><code class="hljs javascript">Tracker.autorun(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  Meteor.subscribe(<span class="hljs-string">"chat"</span>, {room: Session.get(<span class="hljs-string">"current-room"</span>)});
  Meteor.subscribe(<span class="hljs-string">"privateMessages"</span>);
});
</code></pre>
<p>This subscribes you to the chat messages in the current room and to your private messages. When you change rooms by calling <code>Session.set("current-room", "new-room")</code>, Meteor will subscribe to the new room's chat messages, unsubscribe from the original room's chat messages, and continue to stay subscribed to your private messages.</p>
<p>If more than one subscription sends conflicting values for a field (same collection name, document ID, and field name), then the value on the client will be one of the published values, chosen arbitrarily.</p>
<h2 id="methods_header">Methods</h2>
<p>Methods are remote functions that Meteor clients can invoke.</p>
<div class="api new-api-box">
<h3 id="meteor_methods" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_methods">Meteor.methods(methods)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Defines functions that can be invoked over the network by clients.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">methods</span> <span class="type">Object</span></dt>
<dd>
<p>Dictionary whose keys are method names and values are functions.</p>
</dd>
</dl>
</div>
<p>Example:</p>
<pre><code class="hljs js">Meteor.methods({
  foo: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg1, arg2)</span> </span>{
    check(arg1, <span class="hljs-built_in">String</span>);
    check(arg2, [<span class="hljs-built_in">Number</span>]);

    <span class="hljs-comment">// .. do stuff ..</span>

    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* you want to throw an error */</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Meteor.Error(<span class="hljs-string">"pants-not-found"</span>, <span class="hljs-string">"Can't find my pants"</span>);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-string">"some return value"</span>;
  },

  bar: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// .. do other stuff ..</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"baz"</span>;
  }
});
</code></pre>
<p>Calling <code>methods</code> on the server defines functions that can be called remotely by clients. They should return an <a href="http://localhost:3000/#ejson">EJSON</a>-able value or throw an exception. Inside your method invocation, <code>this</code> is bound to a method invocation object, which provides the following:</p>
<ul>
<li><code>isSimulation</code>: a boolean value, true if this invocation is a stub.</li>
<li><code>unblock</code>: when called, allows the next method from this client to begin running.</li>
<li><code>userId</code>: the id of the current user.</li>
<li><code>setUserId</code>: a function that associates the current client with a user.</li>
<li><code>connection</code>: on the server, the <a href="http://localhost:3000/#meteor_onconnection">connection</a> this method call was received on.</li>
</ul>
<p>Calling <code>methods</code> on the client defines <em>stub</em> functions associated with server methods of the same name. You don't have to define a stub for your method if you don't want to. In that case, method calls are just like remote procedure calls in other systems, and you'll have to wait for the results from the server.</p>
<p>If you do define a stub, when a client invokes a server method it will also run its stub in parallel. On the client, the return value of a stub is ignored. Stubs are run for their side-effects: they are intended to <em>simulate</em> the result of what the server's method will do, but without waiting for the round trip delay. If a stub throws an exception it will be logged to the console.</p>
<p>You use methods all the time, because the database mutators (<a href="http://localhost:3000/#insert"><code>insert</code></a>, <a href="http://localhost:3000/#update"><code>update</code></a>, <a href="http://localhost:3000/#remove"><code>remove</code></a>) are implemented as methods. When you call any of these functions on the client, you're invoking their stub version that update the local cache, and sending the same write request to the server. When the server responds, the client updates the local cache with the writes that actually occurred on the server.</p>
<p>You don't have to put all your method definitions into a single <code>Meteor.methods</code> call; you may call it multiple times, as long as each method has a unique name.</p>
<p>Since methods usually expect particular types as arguments, use <a href="http://localhost:3000/#check"><code>check</code></a> liberally to ensure your method arguments have the correct <a href="http://localhost:3000/#matchpatterns">types and structure</a>.</p>
<p>If a client calls a method and is disconnected before it receives a response, it will re-call the method when it reconnects. This means that a client may call a method multiple times when it only means to call it once. If this behavior is problematic for your method, consider attaching a unique ID to each method call on the client, and checking on the server whether a call with this ID has already been made.</p>
<div class="api new-api-box">
<h3 id="method_userId" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/method_userId"><em>this</em>.userId</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>The id of the user that made this method call, or <code>null</code> if no user was logged in.</p>
</div>
</div>
<p>The user id is an arbitrary string &mdash; typically the id of the user record in the database. You can set it with the <code>setUserId</code> function. If you're using the <a href="http://localhost:3000/#accounts_api">Meteor accounts system</a> then this is handled for you.</p>
<div class="api new-api-box">
<h3 id="method_setUserId" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/method_setUserId"><em>this</em>.setUserId(userId)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Set the logged in user.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">userId</span> <span class="type">String or null</span></dt>
<dd>
<p>The value that should be returned by <code>userId</code> on this connection.</p>
</dd>
</dl>
</div>
<p>Call this function to change the currently logged in user on the connection that made this method call. This simply sets the value of <code>userId</code> for future method calls received on this connection. Pass <code>null</code> to log out the connection.</p>
<p>If you are using the <a href="http://localhost:3000/#accounts_api">built-in Meteor accounts system</a> then this should correspond to the <code>_id</code> field of a document in the <a href="http://localhost:3000/#meteor_users"><code>Meteor.users</code></a> collection.</p>
<p><code>setUserId</code> is not retroactive. It affects the current method call and any future method calls on the connection. Any previous method calls on this connection will still see the value of <code>userId</code> that was in effect when they started.</p>
<div class="api new-api-box">
<h3 id="method_issimulation" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/method_issimulation"><em>this</em>.isSimulation</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Access inside a method invocation. Boolean value, true if this invocation is a stub.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="method_unblock" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/method_unblock"><em>this</em>.unblock()</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Call inside a method invocation. Allow subsequent method from this client to begin running in a new fiber.</p>
</div>
</div>
<p>On the server, methods from a given client run one at a time. The N+1th invocation from a client won't start until the Nth invocation returns. However, you can change this by calling <code>this.unblock</code>. This will allow the N+1th invocation to start running in a new fiber.</p>
<div class="api new-api-box">
<h3 id="method_connection" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/method_connection"><em>this</em>.connection</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Access inside a method invocation. The <a href="http://localhost:3000/#meteor_onconnection">connection</a> that this method was received on. <code>null</code> if the method is not associated with a connection, eg. a server initiated method call.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="meteor_error" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_error">new Meteor.Error(error, [reason], [details])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>This class represents a symbolic error thrown by a method.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">error</span> <span class="type">String</span></dt>
<dd>
<p>A string code uniquely identifying this kind of error. This string should be used by callers of the method to determine the appropriate action to take, instead of attempting to parse the reason or details fields. For example:</p>
<pre class="prettyprint source"><code class="hljs javascript"><span class="hljs-comment">// on the server, pick a code unique to this error</span>
<span class="hljs-comment">// the reason field should be a useful debug message</span>
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Meteor.Error(<span class="hljs-string">"logged-out"</span>, 
  <span class="hljs-string">"The user must be logged in to post a comment."</span>);

<span class="hljs-comment">// on the client</span>
Meteor.call(<span class="hljs-string">"methodName"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> </span>{
  <span class="hljs-comment">// identify the error</span>
  <span class="hljs-keyword">if</span> (error.error === <span class="hljs-string">"logged-out"</span>) {
    <span class="hljs-comment">// show a nice error message</span>
    Session.set(<span class="hljs-string">"errorMessage"</span>, <span class="hljs-string">"Please log in to post a comment."</span>);
  }
});</code></pre>
<p>For legacy reasons, some built-in Meteor functions such as <code>check</code> throw errors with a number in this field.</p>
</dd>
<dt><span class="name">reason</span> <span class="type">String</span></dt>
<dd>
<p>Optional. A short human-readable summary of the error, like 'Not Found'.</p>
</dd>
<dt><span class="name">details</span> <span class="type">String</span></dt>
<dd>
<p>Optional. Additional information about the error, like a textual stack trace.</p>
</dd>
</dl>
</div>
<p>If you want to return an error from a method, throw an exception. Methods can throw any kind of exception. But <code>Meteor.Error</code> is the only kind of error that a server will send to the client. If a method function throws a different exception, then it will be mapped to a sanitized version on the wire. Specifically, if the <code>sanitizedError</code> field on the thrown error is set to a <code>Meteor.Error</code>, then that error will be sent to the client. Otherwise, if no sanitized version is available, the client gets <code>Meteor.Error(500, 'Internal server error')</code>.</p>
<div class="api new-api-box">
<h3 id="meteor_call" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_call">Meteor.call(name, [arg1, arg2...], [asyncCallback])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Invokes a method passing any number of arguments.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">name</span> <span class="type">String</span></dt>
<dd>
<p>Name of method to invoke</p>
</dd>
<dt><span class="name">arg1, arg2...</span> <span class="type"><a href="http://localhost:3000/#ejson">EJSON-able Object</a></span></dt>
<dd>
<p>Optional method arguments</p>
</dd>
<dt><span class="name">asyncCallback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).</p>
</dd>
</dl>
</div>
<p>This is how to invoke a method. It will run the method on the server. If a stub is available, it will also run the stub on the client. (See also <a href="http://localhost:3000/#meteor_apply"><code>Meteor.apply</code></a>, which is identical to <code>Meteor.call</code> except that you specify the parameters as an array instead of as separate arguments and you can specify a few options controlling how the method is executed.)</p>
<p>If you include a callback function as the last argument (which can't be an argument to the method, since functions aren't serializable), the method will run asynchronously: it will return nothing in particular and will not throw an exception. When the method is complete (which may or may not happen before <code>Meteor.call</code> returns), the callback will be called with two arguments: <code>error</code> and <code>result</code>. If an error was thrown, then <code>error</code> will be the exception object. Otherwise, <code>error</code> will be undefined and the return value (possibly undefined) will be in <code>result</code>.</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// async call</span>
Meteor.call(<span class="hljs-string">'foo'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error, result)</span> </span>{ ... } );
</code></pre>
<p>If you do not pass a callback on the server, the method invocation will block until the method is complete. It will eventually return the return value of the method, or it will throw an exception if the method threw an exception. (Possibly mapped to 500 Server Error if the exception happened remotely and it was not a <code>Meteor.Error</code> exception.)</p>
<pre><code class="hljs sql">// sync <span class="hljs-operator"><span class="hljs-keyword">call</span>
<span class="hljs-keyword">var</span> result = Meteor.<span class="hljs-keyword">call</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</span>
</code></pre>
<p>On the client, if you do not pass a callback and you are not inside a stub, <code>call</code> will return <code>undefined</code>, and you will have no way to get the return value of the method. That is because the client doesn't have fibers, so there is not actually any way it can block on the remote execution of a method.</p>
<p>Finally, if you are inside a stub on the client and call another method, the other method is not executed (no RPC is generated, nothing "real" happens). If that other method has a stub, that stub stands in for the method and is executed. The method call's return value is the return value of the stub function. The client has no problem executing a stub synchronously, and that is why it's okay for the client to use the synchronous <code>Meteor.call</code> form from inside a method body, as described earlier.</p>
<p>Meteor tracks the database writes performed by methods, both on the client and the server, and does not invoke <code>asyncCallback</code> until all of the server's writes replace the stub's writes in the local cache. In some cases, there can be a lag between the method's return value being available and the writes being visible: for example, if another method still outstanding wrote to the same document, the local cache may not be up to date until the other method finishes as well. If you want to process the method's result as soon as it arrives from the server, even if the method's writes are not available yet, you can specify an <code>onResultReceived</code> callback to <a href="http://localhost:3000/#meteor_apply"><code>Meteor.apply</code></a>.</p>
<div class="api new-api-box">
<h3 id="meteor_apply" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_apply">Meteor.apply(name, args, [options], [asyncCallback])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Invoke a method passing an array of arguments.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">name</span> <span class="type">String</span></dt>
<dd>
<p>Name of method to invoke</p>
</dd>
<dt><span class="name">args</span> <span class="type">Array of <a href="http://localhost:3000/#ejson">EJSON-able Object</a>s</span></dt>
<dd>
<p>Method arguments</p>
</dd>
<dt><span class="name">asyncCallback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional callback; same semantics as in <a href="http://localhost:3000/#meteor_call"><code>Meteor.call</code></a>.</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">wait</span> <span class="type">Boolean</span></dt>
<dd>
<p>(Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.</p>
</dd>
<dt><span class="name">onResultReceived</span> <span class="type">Function</span></dt>
<dd>
<p>(Client only) This callback is invoked with the error or result of the method (just like <code>asyncCallback</code>) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.</p>
</dd>
</dl>
</div>
<p><code>Meteor.apply</code> is just like <code>Meteor.call</code>, except that the method arguments are passed as an array rather than directly as arguments, and you can specify options about how the client executes the method.</p>
<h2 id="check_package">Check</h2>
<p>The <code>check</code> package includes pattern checking functions useful for checking the types and structure of variables and an <a href="http://localhost:3000/#matchpatterns">extensible library of patterns</a> to specify which types you are expecting.</p>
<div class="api new-api-box">
<h3 id="check" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/check">check(value, pattern)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Check that a value matches a <a href="http://localhost:3000/#matchpatterns">pattern</a>. If the value does not match the pattern, throw a <code>Match.Error</code>.</p>
<p>Particularly useful to assert that arguments to a function have the right types and structure.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">value</span> <span class="type">Any</span></dt>
<dd>
<p>The value to check</p>
</dd>
<dt><span class="name">pattern</span> <span class="type"><a href="http://localhost:3000/#matchpatterns">Match Pattern</a></span></dt>
<dd>
<p>The pattern to match <code>value</code> against</p>
</dd>
</dl>
</div>
<p>Meteor methods and publish functions take arbitrary <a href="http://localhost:3000/#ejson">EJSON</a> types as arguments, but most arguments are expected to be of a particular type. <code>check</code> is a lightweight function for checking that arguments and other values are of the expected type. For example:</p>
<pre><code class="hljs javascript">Meteor.publish(<span class="hljs-string">"chats-in-room"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(roomId)</span> </span>{
  <span class="hljs-comment">// Make sure roomId is a string, not an arbitrary mongo selector object.</span>
  check(roomId, <span class="hljs-built_in">String</span>);
  <span class="hljs-keyword">return</span> Chats.find({room: roomId});
});

Meteor.methods({addChat: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(roomId, message)</span> </span>{
  check(roomId, <span class="hljs-built_in">String</span>);
  check(message, {
    text: <span class="hljs-built_in">String</span>,
    timestamp: <span class="hljs-built_in">Date</span>,
    <span class="hljs-comment">// Optional, but if present must be an array of strings.</span>
    tags: Match.Optional([<span class="hljs-built_in">String</span>])
  });

  <span class="hljs-comment">// ... do something with the message ...</span>
}});
</code></pre>
<p>If the match fails, <code>check</code> throws a <code>Match.Error</code> describing how it failed. If this error gets sent over the wire to the client, it will appear only as <code>Meteor.Error(400, "Match Failed")</code>. The failure details will be written to the server logs but not revealed to the client.</p>
<div class="api new-api-box">
<h3 id="match_test" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/match_test">Match.test(value, pattern)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Returns true if the value matches the pattern.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">value</span> <span class="type">Any</span></dt>
<dd>
<p>The value to check</p>
</dd>
<dt><span class="name">pattern</span> <span class="type"><a href="http://localhost:3000/#matchpatterns">Match Pattern</a></span></dt>
<dd>
<p>The pattern to match <code>value</code> against</p>
</dd>
</dl>
</div>
<p><code>Match.test</code> can be used to identify if a variable has a certain structure.</p>
<pre><code class="hljs js"><span class="hljs-comment">// will return true for {foo: 1, bar: "hello"} or similar</span>
Match.test(value, {foo: Match.Integer, bar: <span class="hljs-built_in">String</span>});

<span class="hljs-comment">// will return true if value is a string</span>
Match.test(value, <span class="hljs-built_in">String</span>);

<span class="hljs-comment">// will return true if value is a String or an array of Numbers</span>
Match.test(value, Match.OneOf(<span class="hljs-built_in">String</span>, [<span class="hljs-built_in">Number</span>]));
</code></pre>
<p>This can be useful if you have a function that accepts several different kinds of objects, and you want to determine which was passed in.</p>
<h3 id="matchpatterns" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/matchpatterns">Match Patterns</a></h3>
<p>The following patterns can be used as pattern arguments to <a href="http://localhost:3000/#check"><code>check</code></a> and <code>Match.test</code>:</p>
<dl>
<dt><span class="name"><code>Match.Any</code></span></dt>
<dd>
<p>Matches any value.</p>
</dd>
<dt><span class="name"><code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>undefined</code>, <code>null</code></span></dt>
<dd>
<p>Matches a primitive of the given type.</p>
</dd>
<dt><span class="name"><code>Match.Integer</code></span></dt>
<dd>
<p>Matches a signed 32-bit integer. Doesn't match <code>Infinity</code>, <code>-Infinity</code>, or <code>NaN</code>.</p>
</dd>
<dt><span class="name"><code>[<em>pattern</em>]</code></span></dt>
<dd>
<p>A one-element array matches an array of elements, each of which match <em>pattern</em>. For example, <code>[Number]</code> matches a (possibly empty) array of numbers; <code>[Match.Any]</code> matches any array.</p>
</dd>
<dt><span class="name"><code>{<em>key1</em>: <em>pattern1</em>, <em>key2</em>: <em>pattern2</em>, ...}</code></span></dt>
<dd>
<p>Matches an Object with the given keys, with values matching the given patterns. If any <em>pattern</em> is a <code>Match.Optional</code>, that key does not need to exist in the object. The value may not contain any keys not listed in the pattern. The value must be a plain Object with no special prototype.</p>
</dd>
<dt><span class="name"><code>Match.ObjectIncluding({<em>key1</em>: <em>pattern1</em>, <em>key2</em>: <em>pattern2</em>, ...})</code></span></dt>
<dd>
<p>Matches an Object with the given keys; the value may also have other keys with arbitrary values.</p>
</dd>
<dt><span class="name"><code>Object</code></span></dt>
<dd>
<p>Matches any plain Object with any keys; equivalent to <code>Match.ObjectIncluding({})</code>.</p>
</dd>
<dt><span class="name"><code>Match.Optional(<em>pattern</em>)</code></span></dt>
<dd>
<p>Matches either <code>undefined</code> or something that matches pattern. If used in an object this matches only if the key is not set as opposed to the value being set to <code>undefined</code>.</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// In an object</span>
<span class="hljs-keyword">var</span> pat = { name: Match.Optional(<span class="hljs-built_in">String</span>) };
check({ name: <span class="hljs-string">"something"</span> }, pat) <span class="hljs-comment">// OK</span>
check({}, pat) <span class="hljs-comment">// OK</span>
check({ name: <span class="hljs-literal">undefined</span> }, pat) <span class="hljs-comment">// Throws an exception</span>

<span class="hljs-comment">// Outside an object</span>
check(<span class="hljs-literal">undefined</span>, Match.Optional(<span class="hljs-built_in">String</span>)); <span class="hljs-comment">// OK</span>
</code></pre>
</dd>
<dt><span class="name"><code>Match.OneOf(<em>pattern1</em>, <em>pattern2</em>, ...)</code></span></dt>
<dd>
<p>Matches any value that matches at least one of the provided patterns.</p>
</dd>
<dt><span class="name">Any constructor function (eg, <code>Date</code>)</span></dt>
<dd>
<p>Matches any element that is an instance of that type.</p>
</dd>
<dt><span class="name"><code>Match.Where(<em>condition</em>)</code></span></dt>
<dd>
<p>Calls the function <em>condition</em> with the value as the argument. If <em>condition</em> returns true, this matches. If <em>condition</em> throws a <code>Match.Error</code> or returns false, this fails. If <em>condition</em> throws any other error, that error is thrown from the call to <code>check</code> or <code>Match.test</code>. Examples:</p>
<pre><code class="hljs javascript">check(buffer, Match.Where(EJSON.isBinary));

NonEmptyString = Match.Where(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span> </span>{
  check(x, <span class="hljs-built_in">String</span>);
  <span class="hljs-keyword">return</span> x.length &gt; <span class="hljs-number">0</span>;
});
check(arg, NonEmptyString);
</code></pre>
</dd>
</dl>
<h2 id="connections">Server connections</h2>
<p>These functions manage and inspect the network connection between the Meteor client and server.</p>
<div class="api new-api-box">
<h3 id="meteor_status" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_status">Meteor.status()</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Get the current connection status. A reactive data source.</p>
</div>
</div>
<p>This method returns the status of the connection between the client and the server. The return value is an object with the following fields:</p>
<dl class="objdesc">
<dt><span class="name">connected</span> <span class="type">Boolean</span></dt>
<dd>
<p>True if currently connected to the server. If false, changes and method invocations will be queued up until the connection is reestablished.</p>
</dd>
<dt><span class="name">status</span> <span class="type">String</span></dt>
<dd>
<p>Describes the current reconnection status. The possible values are <code>connected</code> (the connection is up and running), <code>connecting</code> (disconnected and trying to open a new connection), <code>failed</code> (permanently failed to connect; e.g., the client and server support different versions of DDP), <code>waiting</code> (failed to connect and waiting to try to reconnect) and <code>offline</code> (user has disconnected the connection).</p>
</dd>
<dt><span class="name">retryCount</span> <span class="type">Number</span></dt>
<dd>
<p>The number of times the client has tried to reconnect since the connection was lost. 0 when connected.</p>
</dd>
<dt><span class="name">retryTime</span> <span class="type">Number or undefined</span></dt>
<dd>
<p>The estimated time of the next reconnection attempt. To turn this into an interval until the next reconnection, use <code>retryTime - (new Date()).getTime()</code>. This key will be set only when <code>status</code> is <code>waiting</code>.</p>
</dd>
<dt><span class="name">reason</span> <span class="type">String or undefined</span></dt>
<dd>
<p>If <code>status</code> is <code>failed</code>, a description of why the connection failed.</p>
</dd>
</dl>
<p>Instead of using callbacks to notify you on changes, this is a <a href="http://localhost:3000/#reactivity">reactive</a> data source. You can use it in a <a href="http://localhost:3000/#livehtmltemplates">template</a> or <a href="http://localhost:3000/#tracker_autorun">computation</a> to get realtime updates.</p>
<div class="api new-api-box">
<h3 id="meteor_reconnect" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_reconnect">Meteor.reconnect()</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Force an immediate reconnection attempt if the client is not connected to the server.</p>
<p>This method does nothing if the client is already connected.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="meteor_disconnect" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_disconnect">Meteor.disconnect()</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Disconnect the client from the server.</p>
</div>
</div>
<p>Call this method to disconnect from the server and stop all live data updates. While the client is disconnected it will not receive updates to collections, method calls will be queued until the connection is reestablished, and hot code push will be disabled.</p>
<p>Call <a href="http://localhost:3000/#meteor_reconnect">Meteor.reconnect</a> to reestablish the connection and resume data transfer.</p>
<p>This can be used to save battery on mobile devices when real time updates are not required.</p>
<div class="api new-api-box">
<h3 id="meteor_onconnection" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_onconnection">Meteor.onConnection(callback)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Register a callback to be called when a new DDP connection is made to the server.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>The function to call when a new DDP connection is established.</p>
</dd>
</dl>
</div>
<p><code>onConnection</code> returns an object with a single method <code>stop</code>. Calling <code>stop</code> unregisters the callback, so that this callback will no longer be called on new connections.</p>
<p>The callback is called with a single argument, the server-side <code>connection</code> representing the connection from the client. This object contains the following fields:</p>
<dl class="objdesc">
<dt><span class="name">id</span> <span class="type">String</span></dt>
<dd>
<p>A globally unique id for this connection.</p>
</dd>
<dt><span class="name">close</span> <span class="type">Function</span></dt>
<dd>
<p>Close this DDP connection. The client is free to reconnect, but will receive a different connection with a new <code>id</code> if it does.</p>
</dd>
<dt><span class="name">onClose</span> <span class="type">Function</span></dt>
<dd>
<p>Register a callback to be called when the connection is closed. If the connection is already closed, the callback will be called immediately.</p>
</dd>
<dt><span class="name">clientAddress</span> <span class="type">String</span></dt>
<dd>
<p>The IP address of the client in dotted form (such as <code>"127.0.0.1"</code>).</p>
<p>If you're running your Meteor server behind a proxy (so that clients are connecting to the proxy instead of to your server directly), you'll need to set the <code>HTTP_FORWARDED_COUNT</code> environment variable for the correct IP address to be reported by <code>clientAddress</code>.</p>
<p>Set <code>HTTP_FORWARDED_COUNT</code> to an integer representing the number of proxies in front of your server. For example, you'd set it to <code>"1"</code> when your server was behind one proxy.</p>
</dd>
<dt><span class="name">httpHeaders</span> <span class="type">Object</span></dt>
<dd>
<p>When the connection came in over an HTTP transport (such as with Meteor's default SockJS implementation), this field contains whitelisted HTTP headers.</p>
<p>Cookies are deliberately excluded from the headers as they are a security risk for this transport. For details and alternatives, see the <a href="https://github.com/sockjs/sockjs-node#authorisation">SockJS documentation</a>.</p>
</dd>
</dl>
<div class="note">
<p>Currently when a client reconnects to the server (such as after temporarily losing its Internet connection), it will get a new connection each time. The <code>onConnection</code> callbacks will be called again, and the new connection will have a new connection <code>id</code>.</p>
<p>In the future, when client reconnection is fully implemented, reconnecting from the client will reconnect to the same connection on the server: the <code>onConnection</code> callback won't be called for that connection again, and the connection will still have the same connection <code>id</code>.</p>
</div>
<div class="api new-api-box">
<h3 id="ddp_connect" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/ddp_connect">DDP.connect(url)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">url</span> <span class="type">String</span></dt>
<dd>
<p>The URL of another Meteor application.</p>
</dd>
</dl>
</div>
<p>To call methods on another Meteor application or subscribe to its data sets, call <code>DDP.connect</code> with the URL of the application. <code>DDP.connect</code> returns an object which provides:</p>
<ul>
<li><code>subscribe</code> - Subscribe to a record set. See <a href="http://localhost:3000/#meteor_subscribe">Meteor.subscribe</a>.</li>
<li><code>call</code> - Invoke a method. See <a href="http://localhost:3000/#meteor_call">Meteor.call</a>.</li>
<li><code>apply</code> - Invoke a method with an argument array. See <a href="http://localhost:3000/#meteor_apply">Meteor.apply</a>.</li>
<li><code>methods</code> - Define client-only stubs for methods defined on the remote server. See <a href="http://localhost:3000/#meteor_methods">Meteor.methods</a>.</li>
<li><code>status</code> - Get the current connection status. See <a href="http://localhost:3000/#meteor_status">Meteor.status</a>.</li>
<li><code>reconnect</code> - See <a href="http://localhost:3000/#meteor_reconnect">Meteor.reconnect</a>.</li>
<li><code>disconnect</code> - See <a href="http://localhost:3000/#meteor_disconnect">Meteor.disconnect</a>.</li>
<li><code>onReconnect</code> - Set this to a function to be called as the first step of reconnecting. This function can call methods which will be executed before any other outstanding methods. For example, this can be used to re-establish the appropriate authentication context on the new connection.</li>
</ul>
<p>By default, clients open a connection to the server from which they're loaded. When you call <code>Meteor.subscribe</code>, <code>Meteor.status</code>, <code>Meteor.call</code>, and <code>Meteor.apply</code>, you are using a connection back to that default server.</p>
<h2 id="collections">Collections</h2>
<p>Meteor stores data in <em>collections</em>. To get started, declare a collection with <code>new Mongo.Collection</code>.</p>
<div class="api new-api-box">
<h3 id="mongo_collection" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/mongo_collection">new Mongo.Collection(name, [options])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Constructor for a Collection</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">name</span> <span class="type">String</span></dt>
<dd>
<p>The name of the collection. If null, creates an unmanaged (unsynchronized) local collection.</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">connection</span> <span class="type">Object</span></dt>
<dd>
<p>The server connection that will manage this collection. Uses the default connection if not specified. Pass the return value of calling <a href="http://localhost:3000/#ddp_connect"><code>DDP.connect</code></a> to specify a different server. Pass <code>null</code> to specify no connection. Unmanaged (<code>name</code> is null) collections cannot specify a connection.</p>
</dd>
<dt><span class="name">idGeneration</span> <span class="type">String</span></dt>
<dd>
<p>The method of generating the <code>_id</code> fields of new documents in this collection. Possible values:</p>
<ul>
<li><strong><code>'STRING'</code></strong>: random strings</li>
<li><strong><code>'MONGO'</code></strong>: random <a href="http://localhost:3000/#mongo_object_id"><code>Mongo.ObjectID</code></a> values</li>
</ul>
<p>The default id generation technique is <code>'STRING'</code>.</p>
</dd>
<dt><span class="name">transform</span> <span class="type">Function</span></dt>
<dd>
<p>An optional transformation function. Documents will be passed through this function before being returned from <code>fetch</code> or <code>findOne</code>, and before being passed to callbacks of <code>observe</code>, <code>map</code>, <code>forEach</code>, <code>allow</code>, and <code>deny</code>. Transforms are <em>not</em> applied for the callbacks of <code>observeChanges</code> or to cursors returned from publish functions.</p>
</dd>
</dl>
</div>
<p>Calling this function is analogous to declaring a model in a traditional ORM (Object-Relation Mapper)-centric framework. It sets up a <em>collection</em> (a storage space for records, or "documents") that can be used to store a particular type of information, like users, posts, scores, todo items, or whatever matters to your application. Each document is a EJSON object. It includes an <code>_id</code> property whose value is unique in the collection, which Meteor will set when you first create the document.</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// common code on client and server declares a DDP-managed mongo</span>
<span class="hljs-comment">// collection.</span>
Chatrooms = <span class="hljs-keyword">new</span> Mongo.Collection(<span class="hljs-string">"chatrooms"</span>);
Messages = <span class="hljs-keyword">new</span> Mongo.Collection(<span class="hljs-string">"messages"</span>);
</code></pre>
<p>The function returns an object with methods to <a href="http://localhost:3000/#insert"><code>insert</code></a> documents in the collection, <a href="http://localhost:3000/#update"><code>update</code></a> their properties, and <a href="http://localhost:3000/#remove"><code>remove</code></a> them, and to <a href="http://localhost:3000/#find"><code>find</code></a> the documents in the collection that match arbitrary criteria. The way these methods work is compatible with the popular Mongo database API. The same database API works on both the client and the server (see below).</p>
<pre><code class="hljs cs"><span class="hljs-comment">// return array of my messages</span>
<span class="hljs-keyword">var</span> myMessages = Messages.find({userId: Session.<span class="hljs-keyword">get</span>(<span class="hljs-string">'myUserId'</span>)}).fetch();

<span class="hljs-comment">// create a new message</span>
Messages.insert({text: <span class="hljs-string">"Hello, world!"</span>});

<span class="hljs-comment">// mark my first message as "important"</span>
Messages.update(myMessages[<span class="hljs-number">0</span>]._id, {$<span class="hljs-keyword">set</span>: {important: <span class="hljs-keyword">true</span>}});
</code></pre>
<p>If you pass a <code>name</code> when you create the collection, then you are declaring a persistent collection &mdash; one that is stored on the server and seen by all users. Client code and server code can both access the same collection using the same API.</p>
<p>Specifically, when you pass a <code>name</code>, here's what happens:</p>
<ul>
<li>
<p>On the server (if you do not specify a <code>connection</code>), a collection with that name is created on a backend Mongo server. When you call methods on that collection on the server, they translate directly into normal Mongo operations (after checking that they match your <a href="http://localhost:3000/#allow">access control rules</a>).</p>
</li>
<li>
<p>On the client (and on the server if you specify a <code>connection</code>), a Minimongo instance is created. Minimongo is essentially an in-memory, non-persistent implementation of Mongo in pure JavaScript. It serves as a local cache that stores just the subset of the database that this client is working with. Queries (<a href="http://localhost:3000/#find"><code>find</code></a>) on these collections are served directly out of this cache, without talking to the server.</p>
</li>
<li>
<p>When you write to the database on the client (<a href="http://localhost:3000/#insert"><code>insert</code></a>, <a href="http://localhost:3000/#update"><code>update</code></a>, <a href="http://localhost:3000/#remove"><code>remove</code></a>), the command is executed locally immediately, and, simultaneously, it's sent to the server and executed there too. This happens via <a href="http://localhost:3000/#meteor_methods">stubs</a>, because writes are implemented as methods.</p>
</li>
</ul>
<div class="note">
<p>When, on the server, you write to a collection which has a specified <code>connection</code> to another server, it sends the corresponding method to the other server and receives the changed values back from it over DDP. Unlike on the client, it does not execute the write locally first.</p>
</div>
<p>If you pass <code>null</code> as the <code>name</code>, then you're creating a local collection. It's not synchronized anywhere; it's just a local scratchpad that supports Mongo-style <a href="http://localhost:3000/#find"><code>find</code></a>, <a href="http://localhost:3000/#insert"><code>insert</code></a>, <a href="http://localhost:3000/#update"><code>update</code></a>, and <a href="http://localhost:3000/#remove"><code>remove</code></a> operations. (On both the client and the server, this scratchpad is implemented using Minimongo.)</p>
<p>By default, Meteor automatically publishes every document in your collection to each connected client. To turn this behavior off, remove the <code>autopublish</code> package:</p>
<pre><code class="hljs ruby"><span class="hljs-variable">$ </span>meteor remove autopublish
</code></pre>
<p>and instead call <a href="http://localhost:3000/#meteor_publish"><code>Meteor.publish</code></a> to specify which parts of your collection should be published to which users.</p>
<pre><code class="hljs js"><span class="hljs-comment">// Create a collection called Posts and put a document in it. The</span>
<span class="hljs-comment">// document will be immediately visible in the local copy of the</span>
<span class="hljs-comment">// collection. It will be written to the server-side database</span>
<span class="hljs-comment">// a fraction of a second later, and a fraction of a second</span>
<span class="hljs-comment">// after that, it will be synchronized down to any other clients</span>
<span class="hljs-comment">// that are subscribed to a query that includes it (see</span>
<span class="hljs-comment">// Meteor.subscribe and autopublish)</span>
Posts = <span class="hljs-keyword">new</span> Mongo.Collection(<span class="hljs-string">"posts"</span>);
Posts.insert({title: <span class="hljs-string">"Hello world"</span>, body: <span class="hljs-string">"First post"</span>});

<span class="hljs-comment">// Changes are visible immediately -- no waiting for a round trip to</span>
<span class="hljs-comment">// the server.</span>
assert(Posts.find().count() === <span class="hljs-number">1</span>);

<span class="hljs-comment">// Create a temporary, local collection. It works just like any other</span>
<span class="hljs-comment">// collection, but it doesn't send changes to the server, and it</span>
<span class="hljs-comment">// can't receive any data from subscriptions.</span>
Scratchpad = <span class="hljs-keyword">new</span> Mongo.Collection;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)
  Scratchpad.insert({number: i * <span class="hljs-number">2</span>});
assert(Scratchpad.find({number: {$lt: <span class="hljs-number">9</span>}}).count() === <span class="hljs-number">5</span>);
</code></pre>
<p>Generally, you'll assign <code>Mongo.Collection</code> objects in your app to global variables. You can only create one <code>Mongo.Collection</code> object for each underlying Mongo collection.</p>
<p>If you specify a <code>transform</code> option to the <code>Collection</code> or any of its retrieval methods, documents are passed through the <code>transform</code> function before being returned or passed to callbacks. This allows you to add methods or otherwise modify the contents of your collection from their database representation. You can also specify <code>transform</code> on a particular <code>find</code>, <code>findOne</code>, <code>allow</code>, or <code>deny</code> call. Transform functions must return an object and they may not change the value of the document's <code>_id</code> field (though it's OK to leave it out).</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// An Animal class that takes a document in its constructor</span>
Animal = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(doc)</span> </span>{
  _.extend(<span class="hljs-keyword">this</span>, doc);
};
_.extend(Animal.prototype, {
  makeNoise: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.sound);
  }
});

<span class="hljs-comment">// Define a Collection that uses Animal as its document</span>
Animals = <span class="hljs-keyword">new</span> Mongo.Collection(<span class="hljs-string">"Animals"</span>, {
  transform: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(doc)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Animal(doc); }
});

<span class="hljs-comment">// Create an Animal and call its makeNoise method</span>
Animals.insert({name: <span class="hljs-string">"raptor"</span>, sound: <span class="hljs-string">"roar"</span>});
Animals.findOne({name: <span class="hljs-string">"raptor"</span>}).makeNoise(); <span class="hljs-comment">// prints "roar"</span>
</code></pre>
<p><code>transform</code> functions are not called reactively. If you want to add a dynamically changing attribute to an object, do it with a function that computes the value at the time it's called, not by computing the attribute at <code>transform</code> time.</p>
<div class="warning">
<p>In this release, Minimongo has some limitations:</p>
<ul>
<li><code>$pull</code> in modifiers can only accept certain kinds of selectors.</li>
<li><code>findAndModify</code>, aggregate functions, and map/reduce aren't supported.</li>
</ul>
<p>All of these will be addressed in a future release. For full Minimongo release notes, see packages/minimongo/NOTES in the repository.</p>
</div>
<div class="warning">
<p>Minimongo doesn't currently have indexes. It's rare for this to be an issue, since it's unusual for a client to have enough data that an index is worthwhile.</p>
</div>
<div class="api new-api-box">
<h3 id="find" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/find"><em>collection</em>.find([selector], [options])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Find the documents in a collection that match the selector.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">selector</span> <span class="type"><a href="http://localhost:3000/#selectors">Mongo Selector</a>, <a href="http://localhost:3000/#mongo_object_id">Object ID</a>, or String</span></dt>
<dd>
<p>A query describing the documents to find</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">sort</span> <span class="type"><a href="http://localhost:3000/#sortspecifiers">Mongo Sort Specifier</a></span></dt>
<dd>
<p>Sort order (default: natural order)</p>
</dd>
<dt><span class="name">skip</span> <span class="type">Number</span></dt>
<dd>
<p>Number of results to skip at the beginning</p>
</dd>
<dt><span class="name">limit</span> <span class="type">Number</span></dt>
<dd>
<p>Maximum number of results to return</p>
</dd>
<dt><span class="name">fields</span> <span class="type"><a href="http://localhost:3000/#fieldspecifiers">Mongo Field Specifier</a></span></dt>
<dd>
<p>Dictionary of fields to return or exclude.</p>
</dd>
<dt><span class="name">reactive</span> <span class="type">Boolean</span></dt>
<dd>
<p>(Client only) Default <code>true</code>; pass <code>false</code> to disable reactivity</p>
</dd>
<dt><span class="name">transform</span> <span class="type">Function</span></dt>
<dd>
<p>Overrides <code>transform</code> on the <a href="http://localhost:3000/#collections"><code>Collection</code></a> for this cursor. Pass <code>null</code> to disable transformation.</p>
</dd>
</dl>
</div>
<p><code>find</code> returns a cursor. It does not immediately access the database or return documents. Cursors provide <code>fetch</code> to return all matching documents, <code>map</code> and <code>forEach</code> to iterate over all matching documents, and <code>observe</code> and <code>observeChanges</code> to register callbacks when the set of matching documents changes.</p>
<div class="warning">
<p>Collection cursors are not query snapshots. If the database changes between calling <code>Collection.find</code> and fetching the results of the cursor, or while fetching results from the cursor, those changes may or may not appear in the result set.</p>
</div>
<p>Cursors are a reactive data source. On the client, the first time you retrieve a cursor's documents with <code>fetch</code>, <code>map</code>, or <code>forEach</code> inside a reactive computation (eg, a template or <a href="http://localhost:3000/#tracker_autorun"><code>autorun</code></a>), Meteor will register a dependency on the underlying data. Any change to the collection that changes the documents in a cursor will trigger a recomputation. To disable this behavior, pass <code>{reactive: false}</code> as an option to <code>find</code>.</p>
<p>Note that when <code>fields</code> are specified, only changes to the included fields will trigger callbacks in <code>observe</code>, <code>observeChanges</code> and invalidations in reactive computations using this cursor. Careful use of <code>fields</code> allows for more fine-grained reactivity for computations that don't depend on an entire document.</p>
<div class="api new-api-box">
<h3 id="findone" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/findone"><em>collection</em>.findOne([selector], [options])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Finds the first document that matches the selector, as ordered by sort and skip options.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">selector</span> <span class="type"><a href="http://localhost:3000/#selectors">Mongo Selector</a>, <a href="http://localhost:3000/#mongo_object_id">Object ID</a>, or String</span></dt>
<dd>
<p>A query describing the documents to find</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">sort</span> <span class="type"><a href="http://localhost:3000/#sortspecifiers">Mongo Sort Specifier</a></span></dt>
<dd>
<p>Sort order (default: natural order)</p>
</dd>
<dt><span class="name">skip</span> <span class="type">Number</span></dt>
<dd>
<p>Number of results to skip at the beginning</p>
</dd>
<dt><span class="name">fields</span> <span class="type"><a href="http://localhost:3000/#fieldspecifiers">Mongo Field Specifier</a></span></dt>
<dd>
<p>Dictionary of fields to return or exclude.</p>
</dd>
<dt><span class="name">reactive</span> <span class="type">Boolean</span></dt>
<dd>
<p>(Client only) Default true; pass false to disable reactivity</p>
</dd>
<dt><span class="name">transform</span> <span class="type">Function</span></dt>
<dd>
<p>Overrides <code>transform</code> on the <a href="http://localhost:3000/#collections"><code>Collection</code></a> for this cursor. Pass <code>null</code> to disable transformation.</p>
</dd>
</dl>
</div>
<p>Equivalent to <code>find(selector, options).fetch()[0]</code> with <code>options.limit = 1</code>.</p>
<div class="api new-api-box">
<h3 id="insert" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/insert"><em>collection</em>.insert(doc, [callback])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Insert a document in the collection. Returns its unique _id.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">doc</span> <span class="type">Object</span></dt>
<dd>
<p>The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.</p>
</dd>
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional. If present, called with an error object as the first argument and, if no error, the _id as the second.</p>
</dd>
</dl>
</div>
<p>Add a document to the collection. A document is just an object, and its fields can contain any combination of EJSON-compatible datatypes (arrays, objects, numbers, strings, <code>null</code>, true, and false).</p>
<p><code>insert</code> will generate a unique ID for the object you pass, insert it in the database, and return the ID. When <code>insert</code> is called from untrusted client code, it will be allowed only if passes any applicable <a href="http://localhost:3000/#allow"><code>allow</code></a> and <a href="http://localhost:3000/#deny"><code>deny</code></a> rules.</p>
<p>On the server, if you don't provide a callback, then <code>insert</code> blocks until the database acknowledges the write, or throws an exception if something went wrong. If you do provide a callback, <code>insert</code> still returns the ID immediately. Once the insert completes (or fails), the callback is called with error and result arguments. In an error case, <code>result</code> is undefined. If the insert is successful, <code>error</code> is undefined and <code>result</code> is the new document ID.</p>
<p>On the client, <code>insert</code> never blocks. If you do not provide a callback and the insert fails on the server, then Meteor will log a warning to the console. If you provide a callback, Meteor will call that function with <code>error</code> and <code>result</code> arguments. In an error case, <code>result</code> is undefined. If the insert is successful, <code>error</code> is undefined and <code>result</code> is the new document ID.</p>
<p>Example:</p>
<pre><code class="hljs php"><span class="hljs-keyword">var</span> groceriesId = Lists.insert({name: <span class="hljs-string">"Groceries"</span>});
Items.insert({<span class="hljs-keyword">list</span>: groceriesId, name: <span class="hljs-string">"Watercress"</span>});
Items.insert({<span class="hljs-keyword">list</span>: groceriesId, name: <span class="hljs-string">"Persimmons"</span>});
</code></pre>
<div class="api new-api-box">
<h3 id="update" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/update"><em>collection</em>.update(selector, modifier, [options], [callback])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Modify one or more documents in the collection. Returns the number of affected documents.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">selector</span> <span class="type"><a href="http://localhost:3000/#selectors">Mongo Selector</a>, <a href="http://localhost:3000/#mongo_object_id">Object ID</a>, or String</span></dt>
<dd>
<p>Specifies which documents to modify</p>
</dd>
<dt><span class="name">modifier</span> <span class="type"><a href="http://localhost:3000/#modifiers">Mongo Modifier</a></span></dt>
<dd>
<p>Specifies how to modify the documents</p>
</dd>
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional. If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">multi</span> <span class="type">Boolean</span></dt>
<dd>
<p>True to modify all matching documents; false to only modify one of the matching documents (the default).</p>
</dd>
<dt><span class="name">upsert</span> <span class="type">Boolean</span></dt>
<dd>
<p>True to insert a document if no matching documents are found.</p>
</dd>
</dl>
</div>
<p>Modify documents that match <code>selector</code> according to <code>modifier</code> (see <a href="http://localhost:3000/#modifiers">modifier documentation</a>).</p>
<p>The behavior of <code>update</code> differs depending on whether it is called by trusted or untrusted code. Trusted code includes server code and method code. Untrusted code includes client-side code such as event handlers and a browser's JavaScript console.</p>
<ul>
<li>
<p>Trusted code can modify multiple documents at once by setting <code>multi</code> to true, and can use an arbitrary <a href="http://localhost:3000/#selectors">Mongo selector</a> to find the documents to modify. It bypasses any access control rules set up by <a href="http://localhost:3000/#allow"><code>allow</code></a> and <a href="http://localhost:3000/#deny"><code>deny</code></a>. The number of affected documents will be returned from the <code>update</code> call if you don't pass a callback.</p>
</li>
<li>
<p>Untrusted code can only modify a single document at once, specified by its <code>_id</code>. The modification is allowed only after checking any applicable <a href="http://localhost:3000/#allow"><code>allow</code></a> and <a href="http://localhost:3000/#deny"><code>deny</code></a> rules. The number of affected documents will be returned to the callback. Untrusted code cannot perform upserts, except in insecure mode.</p>
</li>
</ul>
<p>On the server, if you don't provide a callback, then <code>update</code> blocks until the database acknowledges the write, or throws an exception if something went wrong. If you do provide a callback, <code>update</code> returns immediately. Once the update completes, the callback is called with a single error argument in the case of failure, or a second argument indicating the number of affected documents if the update was successful.</p>
<p>On the client, <code>update</code> never blocks. If you do not provide a callback and the update fails on the server, then Meteor will log a warning to the console. If you provide a callback, Meteor will call that function with an error argument if there was an error, or a second argument indicating the number of affected documents if the update was successful.</p>
<p>Client example:</p>
<pre><code class="hljs php"><span class="hljs-comment">// When the givePoints button in the admin dashboard is pressed,</span>
<span class="hljs-comment">// give 5 points to the current player. The new score will be</span>
<span class="hljs-comment">// immediately visible on everyone's screens.</span>
Template.adminDashboard.events({
  <span class="hljs-string">'click .givePoints'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    Players.update(Session.get(<span class="hljs-string">"currentPlayer"</span>), {<span class="hljs-variable">$inc</span>: {score: <span class="hljs-number">5</span>}});
  }
});
</code></pre>
<p>Server example:</p>
<pre><code class="hljs php"><span class="hljs-comment">// Give the "Winner" badge to each user with a score greater than</span>
<span class="hljs-comment">// 10. If they are logged in and their badge list is visible on the</span>
<span class="hljs-comment">// screen, it will update automatically as they watch.</span>
Meteor.methods({
  declareWinners: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    Players.update({score: {<span class="hljs-variable">$gt</span>: <span class="hljs-number">10</span>}},
                   {<span class="hljs-variable">$addToSet</span>: {badges: <span class="hljs-string">"Winner"</span>}},
                   {multi: <span class="hljs-keyword">true</span>});
  }
});
</code></pre>
<p>You can use <code>update</code> to perform a Mongo upsert by setting the <code>upsert</code> option to true. You can also use the <a href="http://localhost:3000/#upsert"><code>upsert</code></a> method to perform an upsert that returns the _id of the document that was inserted (if there was one) in addition to the number of affected documents.</p>
<div class="api new-api-box">
<h3 id="upsert" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/upsert"><em>collection</em>.upsert(selector, modifier, [options], [callback])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Modify one or more documents in the collection, or insert one if no matching documents were found. Returns an object with keys <code>numberAffected</code> (the number of documents modified) and <code>insertedId</code> (the unique _id of the document that was inserted, if any).</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">selector</span> <span class="type"><a href="http://localhost:3000/#selectors">Mongo Selector</a>, <a href="http://localhost:3000/#mongo_object_id">Object ID</a>, or String</span></dt>
<dd>
<p>Specifies which documents to modify</p>
</dd>
<dt><span class="name">modifier</span> <span class="type"><a href="http://localhost:3000/#modifiers">Mongo Modifier</a></span></dt>
<dd>
<p>Specifies how to modify the documents</p>
</dd>
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional. If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">multi</span> <span class="type">Boolean</span></dt>
<dd>
<p>True to modify all matching documents; false to only modify one of the matching documents (the default).</p>
</dd>
</dl>
</div>
<p>Modify documents that match <code>selector</code> according to <code>modifier</code>, or insert a document if no documents were modified. <code>upsert</code> is the same as calling <code>update</code> with the <code>upsert</code> option set to true, except that the return value of <code>upsert</code> is an object that contain the keys <code>numberAffected</code> and <code>insertedId</code>. (<code>update</code> returns only the number of affected documents.)</p>
<div class="api new-api-box">
<h3 id="remove" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/remove"><em>collection</em>.remove(selector, [callback])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Remove documents from the collection</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">selector</span> <span class="type"><a href="http://localhost:3000/#selectors">Mongo Selector</a>, <a href="http://localhost:3000/#mongo_object_id">Object ID</a>, or String</span></dt>
<dd>
<p>Specifies which documents to remove</p>
</dd>
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional. If present, called with an error object as its argument.</p>
</dd>
</dl>
</div>
<p>Find all of the documents that match <code>selector</code> and delete them from the collection.</p>
<p>The behavior of <code>remove</code> differs depending on whether it is called by trusted or untrusted code. Trusted code includes server code and method code. Untrusted code includes client-side code such as event handlers and a browser's JavaScript console.</p>
<ul>
<li>
<p>Trusted code can use an arbitrary <a href="http://localhost:3000/#selectors">Mongo selector</a> to find the documents to remove, and can remove more than one document at once by passing a selector that matches multiple documents. It bypasses any access control rules set up by <a href="http://localhost:3000/#allow"><code>allow</code></a> and <a href="http://localhost:3000/#deny"><code>deny</code></a>. The number of removed documents will be returned from <code>remove</code> if you don't pass a callback.</p>
<p>As a safety measure, if <code>selector</code> is omitted (or is <code>undefined</code>), no documents will be removed. Set <code>selector</code> to <code>{}</code> if you really want to remove all documents from your collection.</p>
</li>
<li>
<p>Untrusted code can only remove a single document at a time, specified by its <code>_id</code>. The document is removed only after checking any applicable <a href="http://localhost:3000/#allow"><code>allow</code></a> and <a href="http://localhost:3000/#deny"><code>deny</code></a> rules. The number of removed documents will be returned to the callback.</p>
</li>
</ul>
<p>On the server, if you don't provide a callback, then <code>remove</code> blocks until the database acknowledges the write and then returns the number of removed documents, or throws an exception if something went wrong. If you do provide a callback, <code>remove</code> returns immediately. Once the remove completes, the callback is called with a single error argument in the case of failure, or a second argument indicating the number of removed documents if the remove was successful.</p>
<p>On the client, <code>remove</code> never blocks. If you do not provide a callback and the remove fails on the server, then Meteor will log a warning to the console. If you provide a callback, Meteor will call that function with an error argument if there was an error, or a second argument indicating the number of removed documents if the remove was successful.</p>
<p>Client example:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// When the remove button is clicked on a chat message, delete</span>
<span class="hljs-comment">// that message.</span>
Template.chat.events({
  <span class="hljs-string">'click .remove'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    Messages.remove(<span class="hljs-keyword">this</span>._id);
  }
});
</code></pre>
<p>Server example:</p>
<pre><code class="hljs php"><span class="hljs-comment">// When the server starts, clear the log, and delete all players</span>
<span class="hljs-comment">// with a karma of less than -2.</span>
Meteor.startup(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (Meteor.isServer) {
    Logs.remove({});
    Players.remove({karma: {<span class="hljs-variable">$lt</span>: -<span class="hljs-number">2</span>}});
  }
});
</code></pre>
<div class="api new-api-box">
<h3 id="allow" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/allow"><em>collection</em>.allow(options)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Allow users to write directly to this collection from client code, subject to limitations you define.</p>
</div>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">insert, update, remove</span> <span class="type">Function</span></dt>
<dd>
<p>Functions that look at a proposed modification to the database and return true if it should be allowed.</p>
</dd>
<dt><span class="name">fetch</span> <span class="type">Array of Strings</span></dt>
<dd>
<p>Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your <code>update</code> and <code>remove</code> functions.</p>
</dd>
<dt><span class="name">transform</span> <span class="type">Function</span></dt>
<dd>
<p>Overrides <code>transform</code> on the <a href="http://localhost:3000/#collections"><code>Collection</code></a>. Pass <code>null</code> to disable transformation.</p>
</dd>
</dl>
</div>
<p>When a client calls <code>insert</code>, <code>update</code>, or <code>remove</code> on a collection, the collection's <code>allow</code> and <a href="http://localhost:3000/#deny"><code>deny</code></a> callbacks are called on the server to determine if the write should be allowed. If at least one <code>allow</code> callback allows the write, and no <code>deny</code> callbacks deny the write, then the write is allowed to proceed.</p>
<p>These checks are run only when a client tries to write to the database directly, for example by calling <code>update</code> from inside an event handler. Server code is trusted and isn't subject to <code>allow</code> and <code>deny</code> restrictions. That includes methods that are called with <code>Meteor.call</code> &mdash; they are expected to do their own access checking rather than relying on <code>allow</code> and <code>deny</code>.</p>
<p>You can call <code>allow</code> as many times as you like, and each call can include any combination of <code>insert</code>, <code>update</code>, and <code>remove</code> functions. The functions should return <code>true</code> if they think the operation should be allowed. Otherwise they should return <code>false</code>, or nothing at all (<code>undefined</code>). In that case Meteor will continue searching through any other <code>allow</code> rules on the collection.</p>
<p>The available callbacks are:</p>
<dl class="callbacks">
<dt><span class="name">insert(userId, doc)</span></dt>
<dd>
<p>The user <code>userId</code> wants to insert the document <code>doc</code> into the collection. Return <code>true</code> if this should be allowed.</p>
<p><code>doc</code> will contain the <code>_id</code> field if one was explicitly set by the client, or if there is an active <code>transform</code>. You can use this to prevent users from specifying arbitrary <code>_id</code> fields.</p>
</dd>
<dt><span class="name">update(userId, doc, fieldNames, modifier)</span></dt>
<dd>
<p>The user <code>userId</code> wants to update a document <code>doc</code>. (<code>doc</code> is the current version of the document from the database, without the proposed update.) Return <code>true</code> to permit the change.</p>
<p><code>fieldNames</code> is an array of the (top-level) fields in <code>doc</code> that the client wants to modify, for example <code>['name',</code>&nbsp;<code>'score']</code>.</p>
<p><code>modifier</code> is the raw Mongo modifier that the client wants to execute; for example, <code>{$set: {'name.first': "Alice"}, $inc: {score: 1}}</code>.</p>
<p>Only Mongo modifiers are supported (operations like <code>$set</code> and <code>$push</code>). If the user tries to replace the entire document rather than use $-modifiers, the request will be denied without checking the <code>allow</code> functions.</p>
</dd>
<dt><span class="name">remove(userId, doc)</span></dt>
<dd>
<p>The user <code>userId</code> wants to remove <code>doc</code> from the database. Return <code>true</code> to permit this.</p>
</dd>
</dl>
<p>When calling <code>update</code> or <code>remove</code> Meteor will by default fetch the entire document <code>doc</code> from the database. If you have large documents you may wish to fetch only the fields that are actually used by your functions. Accomplish this by setting <code>fetch</code> to an array of field names to retrieve.</p>
<p>Example:</p>
<pre><code class="hljs js"><span class="hljs-comment">// Create a collection where users can only modify documents that</span>
<span class="hljs-comment">// they own. Ownership is tracked by an 'owner' field on each</span>
<span class="hljs-comment">// document. All documents must be owned by the user that created</span>
<span class="hljs-comment">// them and ownership can't be changed. Only a document's owner</span>
<span class="hljs-comment">// is allowed to delete it, and the 'locked' attribute can be</span>
<span class="hljs-comment">// set on a document to prevent its accidental deletion.</span>

Posts = <span class="hljs-keyword">new</span> Mongo.Collection(<span class="hljs-string">"posts"</span>);

Posts.allow({
  insert: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(userId, doc)</span> </span>{
    <span class="hljs-comment">// the user must be logged in, and the document must be owned by the user</span>
    <span class="hljs-keyword">return</span> (userId &amp;&amp; doc.owner === userId);
  },
  update: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(userId, doc, fields, modifier)</span> </span>{
    <span class="hljs-comment">// can only change your own documents</span>
    <span class="hljs-keyword">return</span> doc.owner === userId;
  },
  remove: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(userId, doc)</span> </span>{
    <span class="hljs-comment">// can only remove your own documents</span>
    <span class="hljs-keyword">return</span> doc.owner === userId;
  },
  fetch: [<span class="hljs-string">'owner'</span>]
});

Posts.deny({
  update: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(userId, docs, fields, modifier)</span> </span>{
    <span class="hljs-comment">// can't change owners</span>
    <span class="hljs-keyword">return</span> _.contains(fields, <span class="hljs-string">'owner'</span>);
  },
  remove: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(userId, doc)</span> </span>{
    <span class="hljs-comment">// can't remove locked documents</span>
    <span class="hljs-keyword">return</span> doc.locked;
  },
  fetch: [<span class="hljs-string">'locked'</span>] <span class="hljs-comment">// no need to fetch 'owner'</span>
});
</code></pre>
<p>If you never set up any <code>allow</code> rules on a collection then all client writes to the collection will be denied, and it will only be possible to write to the collection from server-side code. In this case you will have to create a method for each possible write that clients are allowed to do. You'll then call these methods with <code>Meteor.call</code> rather than having the clients call <code>insert</code>, <code>update</code>, and <code>remove</code> directly on the collection.</p>
<p>Meteor also has a special "insecure mode" for quickly prototyping new applications. In insecure mode, if you haven't set up any <code>allow</code> or <code>deny</code> rules on a collection, then all users have full write access to the collection. This is the only effect of insecure mode. If you call <code>allow</code> or <code>deny</code> at all on a collection, even <code>Posts.allow({})</code>, then access is checked just like normal on that collection. <strong>New Meteor projects start in insecure mode by default.</strong> To turn it off just run <code>$ meteor remove insecure</code>.</p>
<div class="api new-api-box">
<h3 id="deny" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/deny"><em>collection</em>.deny(options)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Override <code>allow</code> rules.</p>
</div>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">insert, update, remove</span> <span class="type">Function</span></dt>
<dd>
<p>Functions that look at a proposed modification to the database and return true if it should be denied, even if an <a href="http://localhost:3000/#allow">allow</a> rule says otherwise.</p>
</dd>
<dt><span class="name">fetch</span> <span class="type">Array of Strings</span></dt>
<dd>
<p>Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your <code>update</code> and <code>remove</code> functions.</p>
</dd>
<dt><span class="name">transform</span> <span class="type">Function</span></dt>
<dd>
<p>Overrides <code>transform</code> on the <a href="http://localhost:3000/#collections"><code>Collection</code></a>. Pass <code>null</code> to disable transformation.</p>
</dd>
</dl>
</div>
<p>This works just like <a href="http://localhost:3000/#allow"><code>allow</code></a>, except it lets you make sure that certain writes are definitely denied, even if there is an <code>allow</code> rule that says that they should be permitted.</p>
<p>When a client tries to write to a collection, the Meteor server first checks the collection's <code>deny</code> rules. If none of them return true then it checks the collection's <code>allow</code> rules. Meteor allows the write only if no <code>deny</code> rules return <code>true</code> and at least one <code>allow</code> rule returns <code>true</code>.</p>
<h2 id="mongo_cursor">Cursors</h2>
<p>To create a cursor, use <a href="http://localhost:3000/#find"><code>find</code></a>. To access the documents in a cursor, use <a href="http://localhost:3000/#foreach"><code>forEach</code></a>, <a href="http://localhost:3000/#map"><code>map</code></a>, or <a href="http://localhost:3000/#fetch"><code>fetch</code></a>.</p>
<div class="api new-api-box">
<h3 id="foreach" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/foreach"><em>cursor</em>.forEach(callback, [thisArg])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Call <code>callback</code> once for each matching document, sequentially and synchronously.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.</p>
</dd>
<dt><span class="name">thisArg</span> <span class="type">Any</span></dt>
<dd>
<p>An object which will be the value of <code>this</code> inside <code>callback</code>.</p>
</dd>
</dl>
</div>
<p>This interface is compatible with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array.forEach</a>.</p>
<p>When called from a reactive computation, <code>forEach</code> registers dependencies on the matching documents.</p>
<p>Examples:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// Print the titles of the five top-scoring posts</span>
<span class="hljs-keyword">var</span> topPosts = Posts.find({}, {sort: {score: -<span class="hljs-number">1</span>}, limit: <span class="hljs-number">5</span>});
<span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
topPosts.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(post)</span> </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Title of post "</span> + count + <span class="hljs-string">": "</span> + post.title);
  count += <span class="hljs-number">1</span>;
});
</code></pre>
<div class="api new-api-box">
<h3 id="map" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/map"><em>cursor</em>.map(callback, [thisArg])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Map callback over all matching documents. Returns an Array.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.</p>
</dd>
<dt><span class="name">thisArg</span> <span class="type">Any</span></dt>
<dd>
<p>An object which will be the value of <code>this</code> inside <code>callback</code>.</p>
</dd>
</dl>
</div>
<p>This interface is compatible with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.map</a>.</p>
<p>When called from a reactive computation, <code>map</code> registers dependencies on the matching documents.</p>
<p>On the server, if <code>callback</code> yields, other calls to <code>callback</code> may occur while the first call is waiting. If strict sequential execution is necessary, use <code>forEach</code> instead.</p>
<div class="api new-api-box">
<h3 id="fetch" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/fetch"><em>cursor</em>.fetch()</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Return all matching documents as an Array.</p>
</div>
</div>
<p>When called from a reactive computation, <code>fetch</code> registers dependencies on the matching documents.</p>
<div class="api new-api-box">
<h3 id="count" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/count"><em>cursor</em>.count()</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Returns the number of documents that match a query.</p>
</div>
</div>
<p>Unlike the other functions, <code>count</code> registers a dependency only on the number of matching documents. (Updates that just change or reorder the documents in the result set will not trigger a recomputation.)</p>
<div class="api new-api-box">
<h3 id="observe" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/observe"><em>cursor</em>.observe(callbacks)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Watch a query. Receive callbacks as the result set changes.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callbacks</span> <span class="type">Object</span></dt>
<dd>
<p>Functions to call to deliver the result set as it changes</p>
</dd>
</dl>
</div>
<p>Establishes a <em>live query</em> that invokes callbacks when the result of the query changes. The callbacks receive the entire contents of the document that was affected, as well as its old contents, if applicable. If you only need to receive the fields that changed, see <a href="http://localhost:3000/#observe_changes"><code>observeChanges</code></a>.</p>
<p><code>callbacks</code> may have the following functions as properties:</p>
<dl class="callbacks">
<dt><span class="name">added(document)</span> <span class="or">or</span></dt>
<dt><span class="name">addedAt(document, atIndex, before)</span></dt>
<dd>
<p>A new document <code>document</code> entered the result set. The new document appears at position <code>atIndex</code>. It is immediately before the document whose <code>_id</code> is <code>before</code>. <code>before</code> will be <code>null</code> if the new document is at the end of the results.</p>
</dd>
<dt><span class="name">changed(newDocument, oldDocument) <span class="or">or</span></span></dt>
<dt><span class="name">changedAt(newDocument, oldDocument, atIndex)</span></dt>
<dd>
<p>The contents of a document were previously <code>oldDocument</code> and are now <code>newDocument</code>. The position of the changed document is <code>atIndex</code>.</p>
</dd>
<dt><span class="name">removed(oldDocument)</span> <span class="or">or</span></dt>
<dt><span class="name">removedAt(oldDocument, atIndex)</span></dt>
<dd>
<p>The document <code>oldDocument</code> is no longer in the result set. It used to be at position <code>atIndex</code>.</p>
</dd>
<dt><span class="name">movedTo(document, fromIndex, toIndex, before)</span></dt>
<dd>
<p>A document changed its position in the result set, from <code>fromIndex</code> to <code>toIndex</code> (which is before the document with id <code>before</code>). Its current contents is <code>document</code>.</p>
</dd>
</dl>
<p>Use <code>added</code>, <code>changed</code>, and <code>removed</code> when you don't care about the order of the documents in the result set. They are more efficient than <code>addedAt</code>, <code>changedAt</code>, and <code>removedAt</code>.</p>
<p>Before <code>observe</code> returns, <code>added</code> (or <code>addedAt</code>) will be called zero or more times to deliver the initial results of the query.</p>
<p><code>observe</code> returns a live query handle, which is an object with a <code>stop</code> method. Call <code>stop</code> with no arguments to stop calling the callback functions and tear down the query. <strong>The query will run forever until you call this.</strong> If <code>observe</code> is called from a <code>Tracker.autorun</code> computation, it is automatically stopped when the computation is rerun or stopped. (If the cursor was created with the option <code>reactive</code> set to false, it will only deliver the initial results and will not call any further callbacks; it is not necessary to call <code>stop</code> on the handle.)</p>
<div class="api new-api-box">
<h3 id="observe_changes" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/observe_changes"><em>cursor</em>.observeChanges(callbacks)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Watch a query. Receive callbacks as the result set changes. Only the differences between the old and new documents are passed to the callbacks.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callbacks</span> <span class="type">Object</span></dt>
<dd>
<p>Functions to call to deliver the result set as it changes</p>
</dd>
</dl>
</div>
<p>Establishes a <em>live query</em> that invokes callbacks when the result of the query changes. In contrast to <a href="http://localhost:3000/#observe"><code>observe</code></a>, <code>observeChanges</code> provides only the difference between the old and new result set, not the entire contents of the document that changed.</p>
<p><code>callbacks</code> may have the following functions as properties:</p>
<dl class="callbacks">
<dt><span class="name">added(id, fields)</span> <span class="or">or</span></dt>
<dt><span class="name">addedBefore(id, fields, before)</span></dt>
<dd>
<p>A new document entered the result set. It has the <code>id</code> and <code>fields</code> specified. <code>fields</code> contains all fields of the document excluding the <code>_id</code> field. The new document is before the document identified by <code>before</code>, or at the end if <code>before</code> is <code>null</code>.</p>
</dd>
<dt><span class="name">changed(id, fields)</span></dt>
<dd>
<p>The document identified by <code>id</code> has changed. <code>fields</code> contains the changed fields with their new values. If a field was removed from the document then it will be present in <code>fields</code> with a value of <code>undefined</code>.</p>
</dd>
<dt><span class="name">movedBefore(id, before)</span></dt>
<dd>
<p>The document identified by <code>id</code> changed its position in the ordered result set, and now appears before the document identified by <code>before</code>.</p>
</dd>
<dt><span class="name">removed(id)</span></dt>
<dd>
<p>The document identified by <code>id</code> was removed from the result set.</p>
</dd>
</dl>
<p><code>observeChanges</code> is significantly more efficient if you do not use <code>addedBefore</code> or <code>movedBefore</code>.</p>
<p>Before <code>observeChanges</code> returns, <code>added</code> (or <code>addedBefore</code>) will be called zero or more times to deliver the initial results of the query.</p>
<p><code>observeChanges</code> returns a live query handle, which is an object with a <code>stop</code> method. Call <code>stop</code> with no arguments to stop calling the callback functions and tear down the query. <strong>The query will run forever until you call this.</strong> If <code>observeChanges</code> is called from a <code>Tracker.autorun</code> computation, it is automatically stopped when the computation is rerun or stopped. (If the cursor was created with the option <code>reactive</code> set to false, it will only deliver the initial results and will not call any further callbacks; it is not necessary to call <code>stop</code> on the handle.)</p>
<div class="note">
<p>Unlike <code>observe</code>, <code>observeChanges</code> does not provide absolute position information (that is, <code>atIndex</code> positions rather than <code>before</code> positions.) This is for efficiency.</p>
</div>
<p>Example:</p>
<pre><code class="hljs js"><span class="hljs-comment">// Keep track of how many administrators are online.</span>
<span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> query = Users.find({admin: <span class="hljs-literal">true</span>, onlineNow: <span class="hljs-literal">true</span>});
<span class="hljs-keyword">var</span> handle = query.observeChanges({
  added: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, user)</span> </span>{
    count++;
    <span class="hljs-built_in">console</span>.log(user.name + <span class="hljs-string">" brings the total to "</span> + count + <span class="hljs-string">" admins."</span>);
  },
  removed: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    count--;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Lost one. We're now down to "</span> + count + <span class="hljs-string">" admins."</span>);
  }
});

<span class="hljs-comment">// After five seconds, stop keeping the count.</span>
setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{handle.stop();}, <span class="hljs-number">5000</span>);
</code></pre>
<div class="api new-api-box">
<h3 id="mongo_object_id" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/mongo_object_id">new Mongo.ObjectID(hexString)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Create a Mongo-style <code>ObjectID</code>. If you don't specify a <code>hexString</code>, the <code>ObjectID</code> will generated randomly (not using MongoDB's ID construction rules).</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">hexString</span> <span class="type">String</span></dt>
<dd>
<p>Optional. The 24-character hexadecimal contents of the ObjectID to create</p>
</dd>
</dl>
</div>
<p><code>Mongo.ObjectID</code> follows the same API as the <a href="http://mongodb.github.com/node-mongodb-native/api-bson-generated/objectid.html">Node MongoDB driver <code>ObjectID</code></a> class. Note that you must use the <code>equals</code> method (or <a href="http://localhost:3000/#ejson_equals"><code>EJSON.equals</code></a>) to compare them; the <code>===</code> operator will not work. If you are writing generic code that needs to deal with <code>_id</code> fields that may be either strings or <code>ObjectID</code>s, use <a href="http://localhost:3000/#ejson_equals"><code>EJSON.equals</code></a> instead of <code>===</code> to compare them.</p>
<div class="note">
<p><code>ObjectID</code> values created by Meteor will not have meaningful answers to their <code>getTimestamp</code> method, since Meteor currently constructs them fully randomly.</p>
</div>
<h3 id="selectors" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/selectors">Mongo-Style Selectors</a></h3>
<p>The simplest selectors are just a string or <a href="http://localhost:3000/#mongo_object_id"><code>Mongo.ObjectID</code></a>. These selectors match the document with that value in its <code>_id</code> field.</p>
<p>A slightly more complex form of selector is an object containing a set of keys that must match in a document:</p>
<pre><code class="hljs js"><span class="hljs-comment">// Matches all documents where deleted is false</span>
{deleted: <span class="hljs-literal">false</span>}

<span class="hljs-comment">// Matches all documents where the name and cognomen are as given</span>
{name: <span class="hljs-string">"Rhialto"</span>, cognomen: <span class="hljs-string">"the Marvelous"</span>}

<span class="hljs-comment">// Matches every document</span>
{}
</code></pre>
<p>But they can also contain more complicated tests:</p>
<pre><code class="hljs js"><span class="hljs-comment">// Matches documents where age is greater than 18</span>
{age: {$gt: <span class="hljs-number">18</span>}}

<span class="hljs-comment">// Also matches documents where tags is an array containing "popular"</span>
{tags: <span class="hljs-string">"popular"</span>}

<span class="hljs-comment">// Matches documents where fruit is one of three possibilities</span>
{fruit: {$<span class="hljs-keyword">in</span>: [<span class="hljs-string">"peach"</span>, <span class="hljs-string">"plum"</span>, <span class="hljs-string">"pear"</span>]}}
</code></pre>
<p>See the <a href="http://docs.mongodb.org/manual/reference/operator/">complete documentation</a>.</p>
<h3 id="modifiers" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/modifiers">Mongo-Style Modifiers</a></h3>
<p>A modifier is an object that describes how to update a document in place by changing some of its fields. Some examples:</p>
<pre><code class="hljs js"><span class="hljs-comment">// Set the 'admin' property on the document to true</span>
{$set: {admin: <span class="hljs-literal">true</span>}}

<span class="hljs-comment">// Add 2 to the 'votes' property, and add "Traz"</span>
<span class="hljs-comment">// to the end of the 'supporters' array</span>
{$inc: {votes: <span class="hljs-number">2</span>}, $push: {supporters: <span class="hljs-string">"Traz"</span>}}
</code></pre>
<p>But if a modifier doesn't contain any $-operators, then it is instead interpreted as a literal document, and completely replaces whatever was previously in the database. (Literal document modifiers are not currently supported by <a href="http://localhost:3000/#allow">validated updates</a>.)</p>
<pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> Find the <span class="hljs-built_in">document</span> <span class="hljs-reserved">with</span> id <span class="hljs-string">"123"</span>, <span class="hljs-keyword">and</span> completely replace it.
Users.update({<span class="hljs-attribute">_id</span>: <span class="hljs-string">"123"</span>}, {<span class="hljs-attribute">name</span>: <span class="hljs-string">"Alice"</span>, <span class="hljs-attribute">friends</span>: [<span class="hljs-string">"Bob"</span>]});
</code></pre>
<p>See the <a href="http://docs.mongodb.org/manual/reference/operator/update/">full list of modifiers</a>.</p>
<h3 id="sortspecifiers" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/sortspecifiers">Sort Specifiers</a></h3>
<p>Sorts may be specified using your choice of several syntaxes:</p>
<pre><code class="hljs sql">// All of these <span class="hljs-operator"><span class="hljs-keyword">do</span> the same thing (sort <span class="hljs-keyword">in</span> ascending <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>
// <span class="hljs-keyword">key</span> <span class="hljs-string">"a"</span>, breaking ties <span class="hljs-keyword">in</span> descending <span class="hljs-keyword">order</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">key</span> <span class="hljs-string">"b"</span>)

[[<span class="hljs-string">"a"</span>, <span class="hljs-string">"asc"</span>], [<span class="hljs-string">"b"</span>, <span class="hljs-string">"desc"</span>]]
[<span class="hljs-string">"a"</span>, [<span class="hljs-string">"b"</span>, <span class="hljs-string">"desc"</span>]]
{a: <span class="hljs-number">1</span>, b: -<span class="hljs-number">1</span>}
</span></code></pre>
<p>The last form will only work if your JavaScript implementation preserves the order of keys in objects. Most do, most of the time, but it's up to you to be sure.</p>
<h3 id="fieldspecifiers" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/fieldspecifiers">Field Specifiers</a></h3>
<p>Queries can specify a particular set of fields to include or exclude from the result object.</p>
<p>To exclude specific fields from the result objects, the field specifier is a dictionary whose keys are field names and whose values are <code>0</code>. All unspecified fields are included.</p>
<pre><code class="hljs js">Users.find({}, {fields: {password: <span class="hljs-number">0</span>, hash: <span class="hljs-number">0</span>}})
</code></pre>
<p>To include only specific fields in the result documents, use <code>1</code> as the value. The <code>_id</code> field is still included in the result.</p>
<pre><code class="hljs js">Users.find({}, {fields: {firstname: <span class="hljs-number">1</span>, lastname: <span class="hljs-number">1</span>}})
</code></pre>
<p>With one exception, it is not possible to mix inclusion and exclusion styles: the keys must either be all 1 or all 0. The exception is that you may specify <code>_id: 0</code> in an inclusion specifier, which will leave <code>_id</code> out of the result object as well. However, such field specifiers can not be used with <a href="http://localhost:3000/#observe_changes"><code>observeChanges</code></a>, <a href="http://localhost:3000/#observe"><code>observe</code></a>, cursors returned from a <a href="http://localhost:3000/#meteor_publish">publish function</a>, or cursors used in <code>{{#each}}</code> in a template. They may be used with <a href="http://localhost:3000/#fetch"><code>fetch</code></a>, <a href="http://localhost:3000/#findone"><code>findOne</code></a>, <a href="http://localhost:3000/#foreach"><code>forEach</code></a>, and <a href="http://localhost:3000/#map"><code>map</code></a>.</p>
<p><a href="http://docs.mongodb.org/manual/reference/operator/projection/">Field operators</a> such as <code>$</code> and <code>$elemMatch</code> are not available on the client side yet.</p>
<p>A more advanced example:</p>
<pre><code class="hljs js">Users.insert({ alterEgos: [{ name: <span class="hljs-string">"Kira"</span>, alliance: <span class="hljs-string">"murderer"</span> },
                           { name: <span class="hljs-string">"L"</span>, alliance: <span class="hljs-string">"police"</span> }],
               name: <span class="hljs-string">"Yagami Light"</span> });

Users.findOne({}, { fields: { <span class="hljs-string">'alterEgos.name'</span>: <span class="hljs-number">1</span>, _id: <span class="hljs-number">0</span> } });

<span class="hljs-comment">// returns { alterEgos: [{ name: "Kira" }, { name: "L" }] }</span>
</code></pre>
<p>See <a href="http://docs.mongodb.org/manual/tutorial/project-fields-from-query-results/#projection"> the MongoDB docs</a> for details of the nested field rules and array behavior.</p>
<h2 id="session">Session</h2>
<p><code>Session</code> provides a global object on the client that you can use to store an arbitrary set of key-value pairs. Use it to store things like the currently selected item in a list.</p>
<p>What's special about <code>Session</code> is that it's reactive. If you call <a href="http://localhost:3000/#session_get"><code>Session.get</code></a><code>("currentList")</code> from inside a template, the template will automatically be rerendered whenever <a href="http://localhost:3000/#session_set"><code>Session.set</code></a><code>("currentList", x)</code> is called.</p>
<div class="api new-api-box">
<h3 id="session_set" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/session_set">Session.set(key, value)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Set a variable in the session. Notify any listeners that the value has changed (eg: redraw templates, and rerun any <a href="http://localhost:3000/#tracker_autorun"><code>Tracker.autorun</code></a> computations, that called <a href="http://localhost:3000/#session_get"><code>Session.get</code></a> on this <code>key</code>.)</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">key</span> <span class="type">String</span></dt>
<dd>
<p>The key to set, eg, <code>selectedItem</code></p>
</dd>
<dt><span class="name">value</span> <span class="type"><a href="http://localhost:3000/#ejson">EJSON-able Object</a> or undefined</span></dt>
<dd>
<p>The new value for <code>key</code></p>
</dd>
</dl>
</div>
<p>Example:</p>
<pre><code class="hljs js">Tracker.autorun(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  Meteor.subscribe(<span class="hljs-string">"chat-history"</span>, {room: Session.get(<span class="hljs-string">"currentRoomId"</span>)});
});

<span class="hljs-comment">// Causes the function passed to Tracker.autorun to be re-run, so</span>
<span class="hljs-comment">// that the chat-history subscription is moved to the room "home".</span>
Session.set(<span class="hljs-string">"currentRoomId"</span>, <span class="hljs-string">"home"</span>);
</code></pre>
<p><code>Session.set</code> can also be called with an object of keys and values, which is equivalent to calling <code>Session.set</code> individually on each key/value pair.</p>
<pre><code class="hljs js">Session.set({
  a: <span class="hljs-string">"foo"</span>,
  b: <span class="hljs-string">"bar"</span>
});
</code></pre>
<div class="api new-api-box">
<h3 id="session_set_default" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/session_set_default">Session.setDefault(key, value)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Set a variable in the session if it hasn't been set before. Otherwise works exactly the same as <a href="http://localhost:3000/#session_set"><code>Session.set</code></a>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">key</span> <span class="type">String</span></dt>
<dd>
<p>The key to set, eg, <code>selectedItem</code></p>
</dd>
<dt><span class="name">value</span> <span class="type"><a href="http://localhost:3000/#ejson">EJSON-able Object</a> or undefined</span></dt>
<dd>
<p>The new value for <code>key</code></p>
</dd>
</dl>
</div>
<p>This is useful in initialization code, to avoid re-initializing a session variable every time a new version of your app is loaded.</p>
<div class="api new-api-box">
<h3 id="session_get" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/session_get">Session.get(key)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Get the value of a session variable. If inside a <a href="http://localhost:3000/#reactivity">reactive computation</a>, invalidate the computation the next time the value of the variable is changed by <a href="http://localhost:3000/#session_set"><code>Session.set</code></a>. This returns a clone of the session value, so if it's an object or an array, mutating the returned value has no effect on the value stored in the session.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">key</span> <span class="type">String</span></dt>
<dd>
<p>The name of the session variable to return</p>
</dd>
</dl>
</div>
<p>Example:</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- in main.html --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"main"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>We've always been at war with {{theEnemy}}.<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
&lt;/template&gt;
</code></pre>
<pre><code class="hljs js"><span class="hljs-comment">// in main.js</span>
Template.main.helpers({
  theEnemy: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> Session.get(<span class="hljs-string">"enemy"</span>);
  }
});

Session.set(<span class="hljs-string">"enemy"</span>, <span class="hljs-string">"Eastasia"</span>);
<span class="hljs-comment">// Page will say "We've always been at war with Eastasia"</span>

Session.set(<span class="hljs-string">"enemy"</span>, <span class="hljs-string">"Eurasia"</span>);
<span class="hljs-comment">// Page will change to say "We've always been at war with Eurasia"</span>
</code></pre>
<div class="api new-api-box">
<h3 id="session_equals" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/session_equals">Session.equals(key, value)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Test if a session variable is equal to a value. If inside a <a href="http://localhost:3000/#reactivity">reactive computation</a>, invalidate the computation the next time the variable changes to or from the value.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">key</span> <span class="type">String</span></dt>
<dd>
<p>The name of the session variable to test</p>
</dd>
<dt><span class="name">value</span> <span class="type">String, Number, Boolean, null, or undefined</span></dt>
<dd>
<p>The value to test against</p>
</dd>
</dl>
</div>
<p>If value is a scalar, then these two expressions do the same thing:</p>
<pre><code class="hljs cs">(<span class="hljs-number">1</span>) Session.<span class="hljs-keyword">get</span>(<span class="hljs-string">"key"</span>) === <span class="hljs-keyword">value</span>
(<span class="hljs-number">2</span>) Session.equals(<span class="hljs-string">"key"</span>, <span class="hljs-keyword">value</span>)
</code></pre>
<p>... but the second one is always better. It triggers fewer invalidations (template redraws), making your program more efficient.</p>
<p>Example:</p>
<pre><code class="hljs html">&lt;template name="postsView"&gt;
{{! Show a dynamically updating list of items. Let the user click on an
    item to select it. The selected item is given a CSS class so it
    can be rendered differently. }}

{{#each posts}}
  {{&gt; postItem }}
{{/each}}
&lt;/template&gt;

&lt;template name="postItem"&gt;
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"{{postClass}}"</span>&gt;</span>{{title}}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
&lt;/template&gt;
</code></pre>
<pre><code class="hljs js"><span class="hljs-comment">// in JS file</span>
Template.postsView.helpers({
  posts: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> Posts.find();
  }
});

Template.postItem.helpers({
  postClass: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> Session.equals(<span class="hljs-string">"selectedPost"</span>, <span class="hljs-keyword">this</span>._id) ?
      <span class="hljs-string">"selected"</span> : <span class="hljs-string">""</span>;
  }
});

Template.postItem.events({
  <span class="hljs-string">'click'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    Session.set(<span class="hljs-string">"selectedPost"</span>, <span class="hljs-keyword">this</span>._id);
  }
});
</code></pre>
<p>Using Session.equals here means that when the user clicks on an item and changes the selection, only the newly selected and the newly unselected items are re-rendered.</p>
<p>If Session.get had been used instead of Session.equals, then when the selection changed, all the items would be re-rendered.</p>
<p>For object and array session values, you cannot use <code>Session.equals</code>; instead, you need to use the <code>underscore</code> package and write <code>_.isEqual(Session.get(key), value)</code>.</p>
<h2 id="accounts_api">Accounts</h2>
<p>The Meteor Accounts system builds on top of the <code>userId</code> support in <a href="http://localhost:3000/#publish_userId"><code>publish</code></a> and <a href="http://localhost:3000/#method_userId"><code>methods</code></a>. The core packages add the concept of user documents stored in the database, and additional packages add <a href="http://localhost:3000/#accounts_passwords">secure password authentication</a>, <a href="http://localhost:3000/#meteor_loginwithexternalservice">integration with third party login services</a>, and a <a href="http://localhost:3000/#accountsui">pre-built user interface</a>.</p>
<p>The basic Accounts system is in the <code>accounts-base</code> package, but applications typically include this automatically by adding one of the login provider packages: <code>accounts-password</code>, <code>accounts-facebook</code>, <code>accounts-github</code>, <code>accounts-google</code>, <code>accounts-meetup</code>, <code>accounts-twitter</code>, or <code>accounts-weibo</code>.</p>
<div class="api new-api-box">
<h3 id="meteor_user" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_user">Meteor.user()</a> <span class="locus">Anywhere but publish functions</span></h3>
<div class="desc">
<p>Get the current user record, or <code>null</code> if no user is logged in. A reactive data source.</p>
</div>
</div>
<p>Retrieves the user record for the current user from the <a href="http://localhost:3000/#meteor_users"><code>Meteor.users</code></a> collection.</p>
<p>On the client, this will be the subset of the fields in the document that are published from the server (other fields won't be available on the client). By default the server publishes <code>username</code>, <code>emails</code>, and <code>profile</code> (writable by user). See <a href="http://localhost:3000/#meteor_users"><code>Meteor.users</code></a> for more on the fields used in user documents.</p>
<div class="api new-api-box">
<h3 id="meteor_userid" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_userid">Meteor.userId()</a> <span class="locus">Anywhere but publish functions</span></h3>
<div class="desc">
<p>Get the current user id, or <code>null</code> if no user is logged in. A reactive data source.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="meteor_users" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_users">Meteor.users</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>A <a href="http://localhost:3000/#collections">Mongo.Collection</a> containing user documents.</p>
</div>
</div>
<p>This collection contains one document per registered user. Here's an example user document:</p>
<pre><code class="hljs objectivec">{
  _<span class="hljs-keyword">id</span>: <span class="hljs-string">"bbca5d6a-2156-41c4-89da-0329e8c99a4f"</span>,  <span class="hljs-comment">// Meteor.userId()</span>
  username: <span class="hljs-string">"cool_kid_13"</span>, <span class="hljs-comment">// unique name</span>
  emails: [
    <span class="hljs-comment">// each email address can only belong to one user.</span>
    { address: <span class="hljs-string">"cool@example.com"</span>, verified: <span class="hljs-literal">true</span> },
    { address: <span class="hljs-string">"another@different.com"</span>, verified: <span class="hljs-literal">false</span> }
  ],
  createdAt: Wed Aug <span class="hljs-number">21</span> <span class="hljs-number">2013</span> <span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">52</span> GMT-<span class="hljs-number">0700</span> (PDT),
  profile: {
    <span class="hljs-comment">// The profile is writable by the user by default.</span>
    name: <span class="hljs-string">"Joe Schmoe"</span>
  },
  services: {
    facebook: {
      <span class="hljs-keyword">id</span>: <span class="hljs-string">"709050"</span>, <span class="hljs-comment">// facebook id</span>
      accessToken: <span class="hljs-string">"AAACCgdX7G2...AbV9AZDZD"</span>
    },
    resume: {
      loginTokens: [
        { token: <span class="hljs-string">"97e8c205-c7e4-47c9-9bea-8e2ccc0694cd"</span>,
          when: <span class="hljs-number">1349761684048</span> }
      ]
    }
  }
}
</code></pre>
<p>A user document can contain any data you want to store about a user. Meteor treats the following fields specially:</p>
<ul>
<li><code>username</code>: a unique String identifying the user.</li>
<li><code>emails</code>: an Array of Objects with keys <code>address</code> and <code>verified</code>; an email address may belong to at most one user. <code>verified</code> is a Boolean which is true if the user has <a href="http://localhost:3000/#accounts_verifyemail">verified the address</a> with a token sent over email.</li>
<li><code>createdAt</code>: the Date at which the user document was created.</li>
<li><code>profile</code>: an Object which the user can create and update with any data. Do not store anything on <code>profile</code> that you wouldn't want the user to edit unless you have a deny rule on the <code>Meteor.users</code> collection.</li>
<li><code>services</code>: an Object containing data used by particular login services. For example, its <code>reset</code> field contains tokens used by <a href="http://localhost:3000/#accounts_forgotpassword">forgot password</a> links, and its <code>resume</code> field contains tokens used to keep you logged in between sessions.</li>
</ul>
<p>Like all <a href="http://localhost:3000/#collections">Mongo.Collection</a>s, you can access all documents on the server, but only those specifically published by the server are available on the client.</p>
<p>By default, the current user's <code>username</code>, <code>emails</code> and <code>profile</code> are published to the client. You can publish additional fields for the current user with:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// server</span>
Meteor.publish(<span class="hljs-string">"userData"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.userId) {
    <span class="hljs-keyword">return</span> Meteor.users.find({_id: <span class="hljs-keyword">this</span>.userId},
                             {fields: {<span class="hljs-string">'other'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'things'</span>: <span class="hljs-number">1</span>}});
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.ready();
  }
});

<span class="hljs-comment">// client</span>
Meteor.subscribe(<span class="hljs-string">"userData"</span>);
</code></pre>
<p>If the autopublish package is installed, information about all users on the system is published to all clients. This includes <code>username</code>, <code>profile</code>, and any fields in <code>services</code> that are meant to be public (eg <code>services.facebook.id</code>, <code>services.twitter.screenName</code>). Additionally, when using autopublish more information is published for the currently logged in user, including access tokens. This allows making API calls directly from the client for services that allow this.</p>
<p>Users are by default allowed to specify their own <code>profile</code> field with <a href="http://localhost:3000/#accounts_createuser"><code>Accounts.createUser</code></a> and modify it with <code>Meteor.users.update</code>. To allow users to edit additional fields, use <a href="http://localhost:3000/#allow"><code>Meteor.users.allow</code></a>. To forbid users from making any modifications to their user document:</p>
<pre><code class="hljs javascript">Meteor.users.deny({update: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }});
</code></pre>
<div class="api new-api-box">
<h3 id="meteor_loggingin" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_loggingin">Meteor.loggingIn()</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>True if a login method (such as <code>Meteor.loginWithPassword</code>, <code>Meteor.loginWithFacebook</code>, or <code>Accounts.createUser</code>) is currently in progress. A reactive data source.</p>
</div>
</div>
<p>For example, <a href="http://localhost:3000/#accountsui">the <code>accounts-ui</code> package</a> uses this to display an animation while the login request is being processed.</p>
<div class="api new-api-box">
<h3 id="meteor_logout" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_logout">Meteor.logout([callback])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Log the user out.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional callback. Called with no arguments on success, or with a single <code>Error</code> argument on failure.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="meteor_logoutotherclients" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_logoutotherclients">Meteor.logoutOtherClients([callback])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Log out other clients logged in as the current user, but does not log out the client that calls this function.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional callback. Called with no arguments on success, or with a single <code>Error</code> argument on failure.</p>
</dd>
</dl>
</div>
<p>For example, when called in a user's browser, connections in that browser remain logged in, but any other browsers or DDP clients logged in as that user will be logged out.</p>
<div class="api new-api-box">
<h3 id="meteor_loginwithpassword" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_loginwithpassword">Meteor.loginWithPassword(user, password, [callback])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Log the user in with a password.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">user</span> <span class="type">Object or String</span></dt>
<dd>
<p>Either a string interpreted as a username or an email; or an object with a single key: <code>email</code>, <code>username</code> or <code>id</code>.</p>
</dd>
<dt><span class="name">password</span> <span class="type">String</span></dt>
<dd>
<p>The user's password.</p>
</dd>
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional callback. Called with no arguments on success, or with a single <code>Error</code> argument on failure.</p>
</dd>
</dl>
</div>
<p>This function is provided by the <code>accounts-password</code> package. See the <a href="http://localhost:3000/#accounts_passwords">Passwords</a> section below.</p>
<div class="api new-api-box">
<h3 id="meteor_loginwithexternalservice" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_loginwithexternalservice">Meteor.loginWith&lt;ExternalService&gt;([options], [callback])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Log the user in using an external service.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional callback. Called with no arguments on success, or with a single <code>Error</code> argument on failure.</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">requestPermissions</span> <span class="type">Array of Strings</span></dt>
<dd>
<p>A list of permissions to request from the user.</p>
</dd>
<dt><span class="name">requestOfflineToken</span> <span class="type">Boolean</span></dt>
<dd>
<p>If true, asks the user for permission to act on their behalf when offline. This stores an additional offline token in the <code>services</code> field of the user document. Currently only supported with Google.</p>
</dd>
<dt><span class="name">forceApprovalPrompt</span> <span class="type">Boolean</span></dt>
<dd>
<p>If true, forces the user to approve the app's permissions, even if previously approved. Currently only supported with Google.</p>
</dd>
<dt><span class="name">userEmail</span> <span class="type">String</span></dt>
<dd>
<p>An email address that the external service will use to pre-fill the login prompt. Currently only supported with Meteor developer accounts.</p>
</dd>
<dt><span class="name">loginStyle</span> <span class="type">String</span></dt>
<dd>
<p>Login style ("popup" or "redirect", defaults to the login service configuration). The "popup" style opens the login page in a separate popup window, which is generally preferred because the Meteor application doesn't need to be reloaded. The "redirect" style redirects the Meteor application's window to the login page, and the login service provider redirects back to the Meteor application which is then reloaded. The "redirect" style can be used in situations where a popup window can't be opened, such as in a mobile UIWebView. The "redirect" style however relies on session storage which isn't available in Safari private mode, so the "popup" style will be forced if session storage can't be used.</p>
</dd>
</dl>
</div>
<p>Available functions are:</p>
<ul>
<li><code>Meteor.loginWithMeteorDeveloperAccount</code></li>
<li><code>Meteor.loginWithFacebook</code></li>
<li><code>Meteor.loginWithGithub</code></li>
<li><code>Meteor.loginWithGoogle</code></li>
<li><code>Meteor.loginWithMeetup</code></li>
<li><code>Meteor.loginWithTwitter</code></li>
<li><code>Meteor.loginWithWeibo</code></li>
</ul>
<p>These functions initiate the login process with an external service (eg: Facebook, Google, etc), using OAuth. When called they open a new pop-up window that loads the provider's login page. Once the user has logged in with the provider, the pop-up window is closed and the Meteor client logs in to the Meteor server with the information provided by the external service.</p>
<p><a id="requestpermissions" name="requestpermissions"></a></p>
<p>In addition to identifying the user to your application, some services have APIs that allow you to take action on behalf of the user. To request specific permissions from the user, pass the <code>requestPermissions</code> option the login function. This will cause the user to be presented with an additional page in the pop-up dialog to permit access to their data. The user's <code>accessToken</code> &mdash; with permissions to access the service's API &mdash; is stored in the <code>services</code> field of the user document. The supported values for <code>requestPermissions</code> differ for each login service and are documented on their respective developer sites:</p>
<ul>
<li>Facebook: <a href="http://developers.facebook.com/docs/authentication/permissions/">http://developers.facebook.com/docs/authentication/permissions/</a></li>
<li>GitHub: <a href="http://developer.github.com/v3/oauth/#scopes">http://developer.github.com/v3/oauth/#scopes</a></li>
<li>Google: <a href="https://developers.google.com/accounts/docs/OAuth2Login#scopeparameter">https://developers.google.com/accounts/docs/OAuth2Login#scopeparameter</a></li>
<li>Meetup: <a href="http://www.meetup.com/meetup_api/auth/#oauth2-scopes">http://www.meetup.com/meetup_api/auth/#oauth2-scopes</a></li>
<li>Twitter, Weibo, Meteor developer accounts: <code>requestPermissions</code> currently not supported</li>
</ul>
<p>External login services typically require registering and configuring your application before use. The easiest way to do this is with the <a href="http://localhost:3000/#accountsui"><code>accounts-ui</code> package</a> which presents a step-by-step guide to configuring each service. However, the data can be also be entered manually in the <code>ServiceConfiguration.configurations</code> collection, which is exported by the <code>service-configuration</code> package.</p>
<p>First, add the service configuration package:</p>
<pre><code class="hljs bash">meteor add service-configuration
</code></pre>
<p>Then, in your app:</p>
<pre><code class="hljs js">ServiceConfiguration.configurations.upsert(
  { service: <span class="hljs-string">"weibo"</span> },
  {
    $set: {
      clientId: <span class="hljs-string">"1292962797"</span>,
      loginStyle: <span class="hljs-string">"popup"</span>,
      secret: <span class="hljs-string">"75a730b58f5691de5522789070c319bc"</span>
    }
  }
);
</code></pre>
<p>Each external service has its own login provider package and login function. For example, to support GitHub login, run <code>$ meteor add accounts-github</code> and use the <code>Meteor.loginWithGithub</code> function:</p>
<pre><code class="hljs javascript">Meteor.loginWithGithub({
  requestPermissions: [<span class="hljs-string">'user'</span>, <span class="hljs-string">'public_repo'</span>]
}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
  <span class="hljs-keyword">if</span> (err)
    Session.set(<span class="hljs-string">'errorMessage'</span>, err.reason || <span class="hljs-string">'Unknown error'</span>);
});
</code></pre>
<p>Login service configuration is sent from the server to the client over DDP when your app starts up; you may not call the login function until the configuration is loaded. The function <code>Accounts.loginServicesConfigured()</code> is a reactive data source that will return true once the login service is configured; you should not make login buttons visible or active until it is true.</p>
<div class="api new-api-box">
<h3 id="template_currentuser" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_currentuser">{{ currentUser }}</a></h3>
<div class="desc">
<p>Calls <a href="http://localhost:3000/#meteor_user">Meteor.user()</a>. Use <code>{{#if currentUser}}</code> to check whether the user is logged in.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="template_loggingin" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_loggingin">{{ loggingIn }}</a></h3>
<div class="desc">
<p>Calls <a href="http://localhost:3000/#meteor_loggingin">Meteor.loggingIn()</a>.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="accounts_config" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_config">Accounts.config(options)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Set global accounts options.</p>
</div>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">sendVerificationEmail</span> <span class="type">Boolean</span></dt>
<dd>
<p>New users with an email address will receive an address verification email.</p>
</dd>
<dt><span class="name">forbidClientAccountCreation</span> <span class="type">Boolean</span></dt>
<dd>
<p>Calls to <a href="http://localhost:3000/#accounts_createuser"><code>createUser</code></a> from the client will be rejected. In addition, if you are using <a href="http://localhost:3000/#accountsui">accounts-ui</a>, the "Create account" link will not be available.</p>
</dd>
<dt><span class="name">restrictCreationByEmailDomain</span> <span class="type">String or Function</span></dt>
<dd>
<p>If set to a string, only allows new users if the domain part of their email address matches the string. If set to a function, only allows new users if the function returns true. The function is passed the full email address of the proposed new user. Works with password-based sign-in and external services that expose email addresses (Google, Facebook, GitHub). All existing users still can log in after enabling this option. Example: <code>Accounts.config({ restrictCreationByEmailDomain: 'school.edu' })</code>.</p>
</dd>
<dt><span class="name">loginExpirationInDays</span> <span class="type">Number</span></dt>
<dd>
<p>The number of days from when a user logs in until their token expires and they are logged out. Defaults to 90. Set to <code>null</code> to disable login expiration.</p>
</dd>
<dt><span class="name">oauthSecretKey</span> <span class="type">String</span></dt>
<dd>
<p>When using the <code>oauth-encryption</code> package, the 16 byte key using to encrypt sensitive account credentials in the database, encoded in base64. This option may only be specifed on the server. See packages/oauth-encryption/README.md for details.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="accounts_ui_config" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_ui_config">Accounts.ui.config(options)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Configure the behavior of <a href="http://localhost:3000/#accountsui"><code>{{&gt; loginButtons}}</code></a>.</p>
</div>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">requestPermissions</span> <span class="type">Object</span></dt>
<dd>
<p>Which <a href="http://localhost:3000/#requestpermissions">permissions</a> to request from the user for each external service.</p>
</dd>
<dt><span class="name">requestOfflineToken</span> <span class="type">Object</span></dt>
<dd>
<p>To ask the user for permission to act on their behalf when offline, map the relevant external service to <code>true</code>. Currently only supported with Google. See <a href="http://localhost:3000/#meteor_loginwithexternalservice">Meteor.loginWithExternalService</a> for more details.</p>
</dd>
<dt><span class="name">forceApprovalPrompt</span> <span class="type">Object</span></dt>
<dd>
<p>If true, forces the user to approve the app's permissions, even if previously approved. Currently only supported with Google.</p>
</dd>
<dt><span class="name">passwordSignupFields</span> <span class="type">String</span></dt>
<dd>
<p>Which fields to display in the user creation form. One of '<code>USERNAME_AND_EMAIL</code>', '<code>USERNAME_AND_OPTIONAL_EMAIL</code>', '<code>USERNAME_ONLY</code>', or '<code>EMAIL_ONLY</code>' (default).</p>
</dd>
</dl>
</div>
<p>Example:</p>
<pre><code class="hljs javascript">Accounts.ui.config({
  requestPermissions: {
    facebook: [<span class="hljs-string">'user_likes'</span>],
    github: [<span class="hljs-string">'user'</span>, <span class="hljs-string">'repo'</span>]
  },
  requestOfflineToken: {
    google: <span class="hljs-literal">true</span>
  },
  passwordSignupFields: <span class="hljs-string">'USERNAME_AND_OPTIONAL_EMAIL'</span>
});
</code></pre>
<div class="api new-api-box">
<h3 id="accounts_validatenewuser" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_validatenewuser">Accounts.validateNewUser(func)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Set restrictions on new user creation.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">func</span> <span class="type">Function</span></dt>
<dd>
<p>Called whenever a new user is created. Takes the new user object, and returns true to allow the creation or false to abort.</p>
</dd>
</dl>
</div>
<p>This can be called multiple times. If any of the functions return <code>false</code> or throw an error, the new user creation is aborted. To set a specific error message (which will be displayed by <a href="http://localhost:3000/#accountsui"><code>accounts-ui</code></a>), throw a new <a href="http://localhost:3000/#meteor_error"><code>Meteor.Error</code></a>.</p>
<p>Example:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// Validate username, sending a specific error message on failure.</span>
Accounts.validateNewUser(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(user)</span> </span>{
  <span class="hljs-keyword">if</span> (user.username &amp;&amp; user.username.length &gt;= <span class="hljs-number">3</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Meteor.Error(<span class="hljs-number">403</span>, <span class="hljs-string">"Username must have at least 3 characters"</span>);
});
<span class="hljs-comment">// Validate username, without a specific error message.</span>
Accounts.validateNewUser(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(user)</span> </span>{
  <span class="hljs-keyword">return</span> user.username !== <span class="hljs-string">"root"</span>;
});
</code></pre>
<p>If the user is being created as part of a login attempt from a client (eg, calling <a href="http://localhost:3000/#accounts_createuser"><code>Accounts.createUser</code></a> from the client, or <a href="http://localhost:3000/#meteor_loginwithexternalservice">logging in for the first time with an external service</a>), these callbacks are called <em>before</em> the <a href="http://localhost:3000/#accounts_validateloginattempt"><code>Accounts.validateLoginAttempt</code></a> callbacks. If these callbacks succeed but those fail, the user will still be created but the connection will not be logged in as that user.</p>
<div class="api new-api-box">
<h3 id="accounts_oncreateuser" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_oncreateuser">Accounts.onCreateUser(func)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Customize new user creation.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">func</span> <span class="type">Function</span></dt>
<dd>
<p>Called whenever a new user is created. Return the new user object, or throw an <code>Error</code> to abort the creation.</p>
</dd>
</dl>
</div>
<p>Use this when you need to do more than simply accept or reject new user creation. With this function you can programatically control the contents of new user documents.</p>
<p>The function you pass will be called with two arguments: <code>options</code> and <code>user</code>. The <code>options</code> argument comes from <a href="http://localhost:3000/#accounts_createuser"><code>Accounts.createUser</code></a> for password-based users or from an external service login flow. <code>options</code> may come from an untrusted client so make sure to validate any values you read from it. The <code>user</code> argument is created on the server and contains a proposed user object with all the automatically generated fields required for the user to log in.</p>
<p>The function should return the user document (either the one passed in or a newly-created object) with whatever modifications are desired. The returned document is inserted directly into the <a href="http://localhost:3000/#meteor_users"><code>Meteor.users</code></a> collection.</p>
<p>The default create user function simply copies <code>options.profile</code> into the new user document. Calling <code>onCreateUser</code> overrides the default hook. This can only be called once.</p>
<p>Example:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// Support for playing D&amp;D: Roll 3d6 for dexterity</span>
Accounts.onCreateUser(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options, user)</span> </span>{
  <span class="hljs-keyword">var</span> d6 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(Random.fraction() * <span class="hljs-number">6</span>) + <span class="hljs-number">1</span>; };
  user.dexterity = d6() + d6() + d6();
  <span class="hljs-comment">// We still want the default hook's 'profile' behavior.</span>
  <span class="hljs-keyword">if</span> (options.profile)
    user.profile = options.profile;
  <span class="hljs-keyword">return</span> user;
});
</code></pre>
<div class="api new-api-box">
<h3 id="accounts_validateloginattempt" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_validateloginattempt">Accounts.validateLoginAttempt(func)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Validate login attempts.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">func</span> <span class="type">Function</span></dt>
<dd>
<p>Called whenever a login is attempted (either successful or unsuccessful). A login can be aborted by returning a falsy value or throwing an exception.</p>
</dd>
</dl>
</div>
<p>Call <code>validateLoginAttempt</code> with a callback to be called on login attempts. It returns an object with a single method, <code>stop</code>. Calling <code>stop()</code> unregisters the callback.</p>
<p>When a login attempt is made, the registered validate login callbacks are called with a single argument, the attempt info object:</p>
<dl class="objdesc">
<dt><span class="name">type</span> <span class="type">String</span></dt>
<dd>
<p>The service name, such as "password" or "twitter".</p>
</dd>
<dt><span class="name">allowed</span> <span class="type">Boolean</span></dt>
<dd>
<p>Whether this login is allowed and will be successful (if not aborted by any of the validateLoginAttempt callbacks). False if the login will not succeed (for example, an invalid password or the login was aborted by a previous validateLoginAttempt callback).</p>
</dd>
<dt><span class="name">error</span> <span class="type">Exception</span></dt>
<dd>
<p>When <code>allowed</code> is false, the exception describing why the login failed. It will be a <code>Meteor.Error</code> for failures reported to the user (such as invalid password), and can be a another kind of exception for internal errors.</p>
</dd>
<dt><span class="name">user</span> <span class="type">Object</span></dt>
<dd>
<p>When it is known which user was attempting to login, the Meteor user object. This will always be present for successful logins.</p>
</dd>
<dt><span class="name">connection</span> <span class="type">Object</span></dt>
<dd>
<p>The <code>connection</code> object the request came in on. See <a href="http://localhost:3000/#meteor_onconnection"><code>Meteor.onConnection</code></a> for details.</p>
</dd>
<dt><span class="name">methodName</span> <span class="type">String</span></dt>
<dd>
<p>The name of the Meteor method being used to login.</p>
</dd>
<dt><span class="name">methodArguments</span> <span class="type">Array</span></dt>
<dd>
<p>An array of the arguments passed to the login method.</p>
</dd>
</dl>
<p>A validate login callback must return a truthy value for the login to proceed. If the callback returns a falsy value or throws an exception, the login is aborted. Throwing a <code>Meteor.Error</code> will report the error reason to the user.</p>
<p>All registered validate login callbacks are called, even if one of the callbacks aborts the login. The later callbacks will see the <code>allowed</code> field set to <code>false</code> since the login will now not be successful. This allows later callbacks to override an error from a previous callback; for example, you could override the "Incorrect password" error with a different message.</p>
<p>Validate login callbacks that aren't explicitly trying to override a previous error generally have no need to run if the attempt has already been determined to fail, and should start with</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!attempt.allowed)
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
</code></pre>
<div class="api new-api-box">
<h3 id="accounts_onlogin" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_onlogin">Accounts.onLogin(func)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Register a callback to be called after a login attempt succeeds.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">func</span> <span class="type">Function</span></dt>
<dd>
<p>The callback to be called when login is successful.</p>
</dd>
</dl>
</div>
<p>See description of <a href="http://localhost:3000/#accounts_onloginfailure">Accounts.onLoginFailure</a> for details.</p>
<div class="api new-api-box">
<h3 id="accounts_onloginfailure" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_onloginfailure">Accounts.onLoginFailure(func)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Register a callback to be called after a login attempt fails.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">func</span> <span class="type">Function</span></dt>
<dd>
<p>The callback to be called after the login has failed.</p>
</dd>
</dl>
</div>
<p>Either the <code>onLogin</code> or the <code>onLoginFailure</code> callbacks will be called for each login attempt. The <code>onLogin</code> callbacks are called after the user has been successfully logged in. The <code>onLoginFailure</code> callbacks are called after a login attempt is denied.</p>
<p>These functions return an object with a single method, <code>stop</code>. Calling <code>stop()</code> unregisters the callback.</p>
<p>On the server, the callbacks get a single argument, the same attempt info object as <a href="http://localhost:3000/#accounts_validateloginattempt"><code>validateLoginAttempt</code></a>. On the client, no arguments are passed.</p>
<h2 id="accounts_passwords">Passwords</h2>
<p>The <code>accounts-password</code> package contains a full system for password-based authentication. In addition to the basic username and password-based sign-in process, it also supports email-based sign-in including address verification and password recovery emails.</p>
<p>The Meteor server stores passwords using the <a href="http://en.wikipedia.org/wiki/Bcrypt">bcrypt</a> algorithm. This helps protect against embarrassing password leaks if the server's database is compromised.</p>
<p>To add password support to your application, run <code>$ meteor add accounts-password</code>. You can construct your own user interface using the functions below, or use the <a href="http://localhost:3000/#accountsui"><code>accounts-ui</code> package</a> to include a turn-key user interface for password-based sign-in.</p>
<div class="api new-api-box">
<h3 id="accounts_createuser" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_createuser">Accounts.createUser(options, [callback])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Create a new user.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Client only, optional callback. Called with no arguments on success, or with a single <code>Error</code> argument on failure.</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">username</span> <span class="type">String</span></dt>
<dd>
<p>A unique name for this user.</p>
</dd>
<dt><span class="name">email</span> <span class="type">String</span></dt>
<dd>
<p>The user's email address.</p>
</dd>
<dt><span class="name">password</span> <span class="type">String</span></dt>
<dd>
<p>The user's password. This is <strong>not</strong> sent in plain text over the wire.</p>
</dd>
<dt><span class="name">profile</span> <span class="type">Object</span></dt>
<dd>
<p>The user's profile, typically including the <code>name</code> field.</p>
</dd>
</dl>
</div>
<p>On the client, this function logs in as the newly created user on successful completion. On the server, it returns the newly created user id.</p>
<p>On the client, you must pass <code>password</code> and at least one of <code>username</code> or <code>email</code> &mdash; enough information for the user to be able to log in again later. On the server, you do not need to specify <code>password</code>, but the user will not be able to log in until it has a password (eg, set with <a href="http://localhost:3000/#accounts_setpassword"><code>Accounts.setPassword</code></a>).</p>
<p>To create an account without a password on the server and still let the user pick their own password, call <code>createUser</code> with the <code>email</code> option and then call <a href="http://localhost:3000/#accounts_sendenrollmentemail"><code>Accounts.sendEnrollmentEmail</code></a>. This will send the user an email with a link to set their initial password.</p>
<p>By default the <code>profile</code> option is added directly to the new user document. To override this behavior, use <a href="http://localhost:3000/#accounts_oncreateuser"><code>Accounts.onCreateUser</code></a>.</p>
<p>This function is only used for creating users with passwords. The external service login flows do not use this function.</p>
<div class="api new-api-box">
<h3 id="accounts_changepassword" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_changepassword">Accounts.changePassword(oldPassword, newPassword, [callback])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Change the current user's password. Must be logged in.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">oldPassword</span> <span class="type">String</span></dt>
<dd>
<p>The user's current password. This is <strong>not</strong> sent in plain text over the wire.</p>
</dd>
<dt><span class="name">newPassword</span> <span class="type">String</span></dt>
<dd>
<p>A new password for the user. This is <strong>not</strong> sent in plain text over the wire.</p>
</dd>
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional callback. Called with no arguments on success, or with a single <code>Error</code> argument on failure.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="accounts_forgotpassword" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_forgotpassword">Accounts.forgotPassword(options, [callback])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Request a forgot password email.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional callback. Called with no arguments on success, or with a single <code>Error</code> argument on failure.</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">email</span> <span class="type">String</span></dt>
<dd>
<p>The email address to send a password reset link.</p>
</dd>
</dl>
</div>
<p>This triggers a call to <a href="http://localhost:3000/#accounts_sendresetpasswordemail"><code>Accounts.sendResetPasswordEmail</code></a> on the server. When the user visits the link in this email, the callback registered with <a href="http://localhost:3000/#Accounts-onResetPasswordLink"><code>Accounts.onResetPasswordLink</code></a> will be called.</p>
<p>If you are using the <a href="http://localhost:3000/#accountsui"><code>accounts-ui</code> package</a>, this is handled automatically. Otherwise, it is your responsiblity to prompt the user for the new password and call <code>resetPassword</code>.</p>
<div class="api new-api-box">
<h3 id="accounts_resetpassword" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_resetpassword">Accounts.resetPassword(token, newPassword, [callback])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Reset the password for a user using a token received in email. Logs the user in afterwards.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">token</span> <span class="type">String</span></dt>
<dd>
<p>The token retrieved from the reset password URL.</p>
</dd>
<dt><span class="name">newPassword</span> <span class="type">String</span></dt>
<dd>
<p>A new password for the user. This is <strong>not</strong> sent in plain text over the wire.</p>
</dd>
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional callback. Called with no arguments on success, or with a single <code>Error</code> argument on failure.</p>
</dd>
</dl>
</div>
<p>This function accepts tokens passed into the callbacks registered with <a href="http://localhost:3000/#Accounts-onResetPasswordLink"><code>Accounts.onResetPasswordLink</code></a> and <a href="http://localhost:3000/#Accounts-onEnrollmentLink"><code>Accounts.onEnrollmentLink</code></a>.</p>
<div class="api new-api-box">
<h3 id="accounts_setpassword" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_setpassword">Accounts.setPassword(userId, newPassword, [options])</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Forcibly change the password for a user.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">userId</span> <span class="type">String</span></dt>
<dd>
<p>The id of the user to update.</p>
</dd>
<dt><span class="name">newPassword</span> <span class="type">String</span></dt>
<dd>
<p>A new password for the user.</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">logout</span> <span class="type">Object</span></dt>
<dd>
<p>Logout all current connections with this userId (default: true)</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="accounts_verifyemail" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_verifyemail">Accounts.verifyEmail(token, [callback])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Marks the user's email address as verified. Logs the user in afterwards.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">token</span> <span class="type">String</span></dt>
<dd>
<p>The token retrieved from the verification URL.</p>
</dd>
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional callback. Called with no arguments on success, or with a single <code>Error</code> argument on failure.</p>
</dd>
</dl>
</div>
<p>This function accepts tokens passed into the callback registered with <a href="http://localhost:3000/#Accounts-onEmailVerificationLink"><code>Accounts.onEmailVerificationLink</code></a>.</p>
<div class="api new-api-box">
<h3 id="accounts_sendresetpasswordemail" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_sendresetpasswordemail">Accounts.sendResetPasswordEmail(userId, [email])</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Send an email with a link the user can use to reset their password.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">userId</span> <span class="type">String</span></dt>
<dd>
<p>The id of the user to send email to.</p>
</dd>
<dt><span class="name">email</span> <span class="type">String</span></dt>
<dd>
<p>Optional. Which address of the user's to send the email to. This address must be in the user's <code>emails</code> list. Defaults to the first email in the list.</p>
</dd>
</dl>
</div>
<p>When the user visits the link in this email, the callback registered with <a href="http://localhost:3000/#Accounts-onResetPasswordLink"><code>Accounts.onResetPasswordLink</code></a> will be called.</p>
<p>To customize the contents of the email, see <a href="http://localhost:3000/#accounts_emailtemplates"><code>Accounts.emailTemplates</code></a>.</p>
<div class="api new-api-box">
<h3 id="accounts_sendenrollmentemail" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_sendenrollmentemail">Accounts.sendEnrollmentEmail(userId, [email])</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Send an email with a link the user can use to set their initial password.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">userId</span> <span class="type">String</span></dt>
<dd>
<p>The id of the user to send email to.</p>
</dd>
<dt><span class="name">email</span> <span class="type">String</span></dt>
<dd>
<p>Optional. Which address of the user's to send the email to. This address must be in the user's <code>emails</code> list. Defaults to the first email in the list.</p>
</dd>
</dl>
</div>
<p>When the user visits the link in this email, the callback registered with <a href="http://localhost:3000/#Accounts-onEnrollmentLink"><code>Accounts.onEnrollmentLink</code></a> will be called.</p>
<p>To customize the contents of the email, see <a href="http://localhost:3000/#accounts_emailtemplates"><code>Accounts.emailTemplates</code></a>.</p>
<div class="api new-api-box">
<h3 id="accounts_sendverificationemail" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_sendverificationemail">Accounts.sendVerificationEmail(userId, [email])</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Send an email with a link the user can use verify their email address.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">userId</span> <span class="type">String</span></dt>
<dd>
<p>The id of the user to send email to.</p>
</dd>
<dt><span class="name">email</span> <span class="type">String</span></dt>
<dd>
<p>Optional. Which address of the user's to send the email to. This address must be in the user's <code>emails</code> list. Defaults to the first unverified email in the list.</p>
</dd>
</dl>
</div>
<p>When the user visits the link in this email, the callback registered with <a href="http://localhost:3000/#Accounts-onEmailVerificationLink"><code>Accounts.onEmailVerificationLink</code></a> will be called.</p>
<p>To customize the contents of the email, see <a href="http://localhost:3000/#accounts_emailtemplates"><code>Accounts.emailTemplates</code></a>.</p>
<div class="api new-api-box">
<h3 id="Accounts-onResetPasswordLink" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/Accounts-onResetPasswordLink">Accounts.onResetPasswordLink(callback)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Register a function to call when a reset password link is clicked in an email sent by <a href="http://localhost:3000/#accounts_sendresetpasswordemail"><code>Accounts.sendResetPasswordEmail</code></a>. This function should be called in top-level code, not inside <code>Meteor.startup()</code>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>The function to call. It is given two arguments:</p>
<ol>
<li><code>token</code>: A password reset token that can be passed to <a href="http://localhost:3000/#accounts_resetpassword"><code>Accounts.resetPassword</code></a>.</li>
<li><code>done</code>: A function to call when the password reset UI flow is complete. The normal login process is suspended until this function is called, so that the password for user A can be reset even if user B was logged in.</li>
</ol>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="Accounts-onEnrollmentLink" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/Accounts-onEnrollmentLink">Accounts.onEnrollmentLink(callback)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Register a function to call when an account enrollment link is clicked in an email sent by <a href="http://localhost:3000/#accounts_sendenrollmentemail"><code>Accounts.sendEnrollmentEmail</code></a>. This function should be called in top-level code, not inside <code>Meteor.startup()</code>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>The function to call. It is given two arguments:</p>
<ol>
<li><code>token</code>: A password reset token that can be passed to <a href="http://localhost:3000/#accounts_resetpassword"><code>Accounts.resetPassword</code></a> to give the newly enrolled account a password.</li>
<li><code>done</code>: A function to call when the enrollment UI flow is complete. The normal login process is suspended until this function is called, so that user A can be enrolled even if user B was logged in.</li>
</ol>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="Accounts-onEmailVerificationLink" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/Accounts-onEmailVerificationLink">Accounts.onEmailVerificationLink(callback)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Register a function to call when an email verification link is clicked in an email sent by <a href="http://localhost:3000/#accounts_sendverificationemail"><code>Accounts.sendVerificationEmail</code></a>. This function should be called in top-level code, not inside <code>Meteor.startup()</code>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>The function to call. It is given two arguments:</p>
<ol>
<li><code>token</code>: An email verification token that can be passed to <a href="http://localhost:3000/#accounts_verifyemail"><code>Accounts.verifyEmail</code></a>.</li>
<li><code>done</code>: A function to call when the email verification UI flow is complete. The normal login process is suspended until this function is called, so that the user can be notified that they are verifying their email before being logged in.</li>
</ol>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="accounts_emailtemplates" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/accounts_emailtemplates">Accounts.emailTemplates</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Options to customize emails sent from the Accounts system.</p>
</div>
</div>
<p>This is an <code>Object</code> with several fields that are used to generate text/html for the emails sent by <code>sendResetPasswordEmail</code>, <code>sendEnrollmentEmail</code>, and <code>sendVerificationEmail</code>.</p>
<p>Override fields of the object by assigning to them:</p>
<ul>
<li><code>from</code>: A <code>String</code> with an <a href="http://tools.ietf.org/html/rfc5322">RFC5322</a> From address. By default, the email is sent from <code>no-reply@meteor.com</code>. If you wish to receive email from users asking for help with their account, be sure to set this to an email address that you can receive email at.</li>
<li><code>siteName</code>: The public name of your application. Defaults to the DNS name of the application (eg: <code>awesome.meteor.com</code>).</li>
<li><code>headers</code>: An <code>Object</code> for custom email headers as described in <a href="http://localhost:3000/#email_send"><code>Email.send</code></a>.</li>
<li><code>resetPassword</code>: An <code>Object</code> with two fields:
<ul>
<li><code>resetPassword.from</code>: A <code>Function</code> used to override the <code>from</code> address defined by the <code>emailTemplates.from</code> field.</li>
<li><code>resetPassword.subject</code>: A <code>Function</code> that takes a user object and returns a <code>String</code> for the subject line of a reset password email.</li>
<li><code>resetPassword.text</code>: A <code>Function</code> that takes a user object and a url, and returns the body text for a reset password email.</li>
<li><code>resetPassword.html</code>: An optional <code>Function</code> that takes a user object and a url, and returns the body html for a reset password email.</li>
</ul>
</li>
<li><code>enrollAccount</code>: Same as <code>resetPassword</code>, but for initial password setup for new accounts.</li>
<li><code>verifyEmail</code>: Same as <code>resetPassword</code>, but for verifying the users email address.</li>
</ul>
<p>Example:</p>
<pre><code class="hljs js">Accounts.emailTemplates.siteName = <span class="hljs-string">"AwesomeSite"</span>;
Accounts.emailTemplates.from = <span class="hljs-string">"AwesomeSite Admin &lt;accounts@example.com&gt;"</span>;
Accounts.emailTemplates.enrollAccount.subject = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(user)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Welcome to Awesome Town, "</span> + user.profile.name;
};
Accounts.emailTemplates.enrollAccount.text = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(user, url)</span> </span>{
   <span class="hljs-keyword">return</span> <span class="hljs-string">"You have been selected to participate in building a better future!"</span>
     + <span class="hljs-string">" To activate your account, simply click the link below:\n\n"</span>
     + url;
};
</code></pre>
<h2 id="templates_api">Templates</h2>
<p>When you write a template as <code>&lt;template name="foo"&gt; ... &lt;/template&gt;</code> in an HTML file in your app, Meteor generates a "template object" named <code>Template.foo</code>.</p>
<p>The same template may occur many times on a page, and these occurrences are called template instances. Template instances have a life cycle of being created, put into the document, and later taken out of the document and destroyed. Meteor manages these stages for you, including determining when a template instance has been removed or replaced and should be cleaned up. You can associate data with a template instance, and you can access its DOM nodes when it is in the document.</p>
<div class="api new-api-box">
<h3 id="template_events" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_events"><em>Template.myTemplate</em>.events(eventMap)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Specify event handlers for this template.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">eventMap</span> <span class="type"><a href="http://localhost:3000/#eventmaps">Event Map</a></span></dt>
<dd>
<p>Event handlers to associate with this template.</p>
</dd>
</dl>
</div>
<p>Declare event handlers for instances of this template. Multiple calls add new event handlers in addition to the existing ones.</p>
<p>See <a href="http://localhost:3000/#eventmaps">Event Maps</a> for a detailed description of the event map format and how event handling works in Meteor.</p>
<div class="api new-api-box">
<h3 id="template_helpers" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_helpers"><em>Template.myTemplate</em>.helpers(helpers)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Specify template helpers available to this template.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">helpers</span> <span class="type">Object</span></dt>
<dd>
<p>Dictionary of helper functions by name.</p>
</dd>
</dl>
</div>
<p>Each template has a local dictionary of helpers that are made available to it, and this call specifies helpers to add to the template's dictionary.</p>
<p>Example:</p>
<pre><code class="hljs css"><span class="hljs-tag">Template</span><span class="hljs-class">.myTemplate</span><span class="hljs-class">.helpers</span>(<span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">foo</span>:<span class="hljs-value"> function () {
    return Session.<span class="hljs-function">get</span>(<span class="hljs-string">"foo"</span>)</span></span>;
  <span class="hljs-rule">}</span></span>
});
</code></pre>
<p>Now you can invoke this helper with <code>{{foo}}</code> in the template defined with <code>&lt;template name="myTemplate"&gt;</code>.</p>
<p>Helpers can accept positional and keyword arguments:</p>
<pre><code class="hljs javascript">Template.myTemplate.helpers({
  displayName: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(firstName, lastName, keyword)</span> </span>{
    <span class="hljs-keyword">var</span> prefix = keyword.hash.title ? keyword.hash.title + <span class="hljs-string">" "</span> : <span class="hljs-string">""</span>;
    <span class="hljs-keyword">return</span> prefix + firstName + <span class="hljs-string">" "</span> + lastName;
  }
});
</code></pre>
<p>Then you can call this helper from template like this:</p>
<pre><code class="hljs javascript">{{displayName <span class="hljs-string">"John"</span> <span class="hljs-string">"Doe"</span> title=<span class="hljs-string">"President"</span>}}
</code></pre>
<p>You can learn more about arguments to helpers in <a href="https://atmospherejs.com/meteor/spacebars">Spacebars Readme</a>.</p>
<p>Under the hood, each helper starts a new <a href="http://localhost:3000/#/full/tracker_autorun"><code>Tracker.autorun</code></a>. When its reactive dependencies change, the helper is rerun. Helpers depend on their data context, passed arguments and other reactive data sources accessed during execution.</p>
<p>To create a helper that can be used in any template, use <a href="http://localhost:3000/#template_registerhelper"><code>Template.registerHelper</code></a>.</p>
<div class="api new-api-box">
<h3 id="template_onRendered" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_onRendered"><em>Template.myTemplate</em>.onRendered</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Register a function to be called when an instance of this template is inserted into the DOM.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>A function to be added as a callback.</p>
</dd>
</dl>
</div>
<p>Callbacks added with this method are called once when an instance of Template.<em>myTemplate</em> is rendered into DOM nodes and put into the document for the first time.</p>
<p>In the body of a callback, <code>this</code> is a <a href="http://localhost:3000/#template_inst">template instance</a> object that is unique to this occurrence of the template and persists across re-renderings. Use the <code>onCreated</code> and <code>onDestroyed</code> callbacks to perform initialization or clean-up on the object.</p>
<p>Because your template has been rendered, you can use functions like <a href="http://localhost:3000/#template_findAll"><code>this.findAll</code></a> which look at its DOM nodes.</p>
<div class="api new-api-box">
<h3 id="template_onCreated" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_onCreated"><em>Template.myTemplate</em>.onCreated</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Register a function to be called when an instance of this template is created.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>A function to be added as a callback.</p>
</dd>
</dl>
</div>
<p>Callbacks added with this method called before your template's logic is evaluated for the first time. Inside a callback, <code>this</code> is the new <a href="http://localhost:3000/#template_inst">template instance</a> object. Properties you set on this object will be visible from the callbacks added with <code>onRendered</code> and <code>onDestroyed</code> methods and from event handlers.</p>
<p>These callbacks fire once and are the first group of callbacks to fire. Handling the <code>created</code> event is a useful way to set up values on template instance that are read from template helpers using <code>Template.instance()</code>.</p>
<div class="api new-api-box">
<h3 id="template_onDestroyed" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_onDestroyed"><em>Template.myTemplate</em>.onDestroyed</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Register a function to be called when an instance of this template is removed from the DOM and destroyed.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>A function to be added as a callback.</p>
</dd>
</dl>
</div>
<p>These callbacks are called when an occurrence of a template is taken off the page for any reason and not replaced with a re-rendering. Inside a callback, <code>this</code> is the <a href="http://localhost:3000/#template_inst">template instance</a> object being destroyed.</p>
<p>This group of callbacks is most useful for cleaning up or undoing any external effects of <code>created</code> or <code>rendered</code> groups. This group fires once and is the last callback to fire.</p>
<h2 id="template_inst">Template instances</h2>
<p>A template instance object represents an occurrence of a template in the document. It can be used to access the DOM and it can be assigned properties that persist as the template is reactively updated.</p>
<p>Template instance objects are found as the value of <code>this</code> in the <code>onCreated</code>, <code>onRendered</code>, and <code>onDestroyed</code> template callbacks, and as an argument to event handlers. You can access the current template instance from helpers using <a href="http://localhost:3000/#template_instance"><code>Template.instance()</code></a>.</p>
<p>In addition to the properties and functions described below, you can assign additional properties of your choice to the object. Use the <a href="http://localhost:3000/#template_onCreated"><code>onCreated</code></a> and <a href="http://localhost:3000/#template_onDestroyed"><code>onDestroyed</code></a> methods to add callbacks performing initialization or clean-up on the object.</p>
<p>You can only access <code>findAll</code>, <code>find</code>, <code>firstNode</code>, and <code>lastNode</code> from the <code>onRendered</code> callback and event handlers, not from <code>onCreated</code> and <code>onDestroyed</code>, because they require the template instance to be in the DOM.</p>
<p>Template instance objects are <code>instanceof Blaze.TemplateInstance</code>.</p>
<div class="api new-api-box">
<h3 id="template_findAll" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_findAll"><em>template</em>.findAll(selector)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Find all elements matching <code>selector</code> in this template instance.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">selector</span> <span class="type">String</span></dt>
<dd>
<p>The CSS selector to match, scoped to the template contents.</p>
</dd>
</dl>
</div>
<p><code>template.findAll</code> returns an array of DOM elements matching <code>selector</code>.</p>
<div class="api new-api-box">
<h3 id="template_$" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_$"><em>template</em>.$(selector)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Find all elements matching <code>selector</code> in this template instance, and return them as a JQuery object.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">selector</span> <span class="type">String</span></dt>
<dd>
<p>The CSS selector to match, scoped to the template contents.</p>
</dd>
</dl>
</div>
<p><code>template.$</code> returns a <a href="http://api.jquery.com/Types/#jQuery">jQuery object</a> of those same elements. jQuery objects are similar to arrays, with additional methods defined by the jQuery library.</p>
<p>The template instance serves as the document root for the selector. Only elements inside the template and its sub-templates can match parts of the selector.</p>
<div class="api new-api-box">
<h3 id="template_find" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_find"><em>template</em>.find(selector)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Find one element matching <code>selector</code> in this template instance.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">selector</span> <span class="type">String</span></dt>
<dd>
<p>The CSS selector to match, scoped to the template contents.</p>
</dd>
</dl>
</div>
<p>Returns one DOM element matching <code>selector</code>, or <code>null</code> if there are no such elements.</p>
<p>The template instance serves as the document root for the selector. Only elements inside the template and its sub-templates can match parts of the selector.</p>
<div class="api new-api-box">
<h3 id="template_firstNode" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_firstNode"><em>template</em>.firstNode</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>The first top-level DOM node in this template instance.</p>
</div>
</div>
<p>The two nodes <code>firstNode</code> and <code>lastNode</code> indicate the extent of the rendered template in the DOM. The rendered template includes these nodes, their intervening siblings, and their descendents. These two nodes are siblings (they have the same parent), and <code>lastNode</code> comes after <code>firstNode</code>, or else they are the same node.</p>
<div class="api new-api-box">
<h3 id="template_lastNode" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_lastNode"><em>template</em>.lastNode</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>The last top-level DOM node in this template instance.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="template_data" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_data"><em>template</em>.data</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>The data context of this instance's latest invocation.</p>
</div>
</div>
<p>This property provides access to the data context at the top level of the template. It is updated each time the template is re-rendered. Access is read-only and non-reactive.</p>
<div class="api new-api-box">
<h3 id="template_autorun" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_autorun"><em>template</em>.autorun(runFunc)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>A version of <a href="http://localhost:3000/#tracker_autorun">Tracker.autorun</a> that is stopped when the template is destroyed.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">runFunc</span> <span class="type">Function</span></dt>
<dd>
<p>The function to run. It receives one argument: a Tracker.Computation object.</p>
</dd>
</dl>
</div>
<p>You can use <code>this.autorun</code> from an <a href="http://localhost:3000/#template_onCreated"><code>onCreated</code></a> or <a href="http://localhost:3000/#template_onRendered"><code>onRendered</code></a> callback to reactively update the DOM or the template instance. You can use <code>Template.currentData()</code> inside of this callback to access reactive data context of the template instance. The Computation is automatically stopped when the template is destroyed.</p>
<p>Alias for <code>template.view.autorun</code>.</p>
<div class="api new-api-box">
<h3 id="Blaze-TemplateInstance-subscribe" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/Blaze-TemplateInstance-subscribe"><em>template</em>.subscribe(name, [arg1, arg2...], [callbacks])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>A version of <a href="http://localhost:3000/#meteor_subscribe">Meteor.subscribe</a> that is stopped when the template is destroyed.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">name</span> <span class="type">String</span></dt>
<dd>
<p>Name of the subscription. Matches the name of the server's <code>publish()</code> call.</p>
</dd>
<dt><span class="name">arg1, arg2...</span> <span class="type">Any</span></dt>
<dd>
<p>Optional arguments passed to publisher function on server.</p>
</dd>
<dt><span class="name">callbacks</span> <span class="type">Function or Object</span></dt>
<dd>
<p>Optional. May include <code>onStop</code> and <code>onReady</code> callbacks. If a function is passed instead of an object, it is interpreted as an <code>onReady</code> callback.</p>
</dd>
</dl>
</div>
<p>You can use <code>this.subscribe</code> from an <a href="http://localhost:3000/#template_onCreated"><code>onCreated</code></a> callback to specify which data publications this template depends on. The subscription is automatically stopped when the template is destroyed.</p>
<p>There is a complementary function <code>Template.instance().subscriptionsReady()</code> which returns true when all of the subscriptions called with <code>this.subscribe</code> are ready.</p>
<p>Inside the template's HTML, you can use the built-in helper <code>Template.subscriptionsReady</code>, which is an easy pattern for showing loading indicators in your templates when they depend on data loaded from subscriptions.</p>
<p>Example:</p>
<pre><code class="hljs js">Template.notifications.onCreated(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// Use this.subscribe inside onCreated callback</span>
  <span class="hljs-keyword">this</span>.subscribe(<span class="hljs-string">"notifications"</span>);
});
</code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"notifications"</span>&gt;</span>
  {{#if Template.subscriptionsReady}}
    <span class="hljs-comment">&lt;!-- This is displayed when all data is ready. --&gt;</span>
    {{#each notifications}}
      {{&gt; notification}}
    {{/each}}
  {{else}}
    Loading...
  {{/if}}
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>
<p>Another example where the subscription depends on the data context:</p>
<pre><code class="hljs js">Template.comments.onCreated(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

  <span class="hljs-comment">// Use self.subscribe with the data context reactively</span>
  self.autorun(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> dataContext = Template.currentData();
    self.subscribe(<span class="hljs-string">"comments"</span>, dataContext.postId);
  });
});
</code></pre>
<pre><code class="hljs html">{{#with post}}
  {{&gt; comments postId=_id}}
{{/with}}
</code></pre>
<div class="api new-api-box">
<h3 id="template_view" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_view"><em>template</em>.view</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>The <a href="http://localhost:3000/#blaze_view">View</a> object for this invocation of the template.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="template_registerhelper" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_registerhelper">Template.registerHelper(name, function)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Defines a <a href="http://localhost:3000/#template_helpers">helper function</a> which can be used from all templates.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">name</span> <span class="type">String</span></dt>
<dd>
<p>The name of the helper function you are defining.</p>
</dd>
<dt><span class="name">function</span> <span class="type">Function</span></dt>
<dd>
<p>The helper function itself.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="template_instance" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_instance">Template.instance()</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>The <a href="http://localhost:3000/#template_inst">template instance</a> corresponding to the current template helper, event handler, callback, or autorun. If there isn't one, <code>null</code>.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="template_currentdata" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_currentdata">Template.currentData()</a> <span class="locus">Client</span></h3>
<div class="desc">
<ul>
<li>Inside an <code>onCreated</code>, <code>onRendered</code>, or <code>onDestroyed</code> callback, returns the data context of the template.</li>
<li>Inside an event handler, returns the data context of the template on which this event handler was defined.</li>
<li>Inside a helper, returns the data context of the DOM node where the helper was used.</li>
</ul>
<p>Establishes a reactive dependency on the result.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="template_parentdata" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_parentdata">Template.parentData([numLevels])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Accesses other data contexts that enclose the current data context.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">numLevels</span> <span class="type">Integer</span></dt>
<dd>
<p>The number of levels beyond the current data context to look. Defaults to 1.</p>
</dd>
</dl>
</div>
<p>For example, <code>Template.parentData(0)</code> is equivalent to <code>Template.currentData()</code>. <code>Template.parentData(2)</code> is equivalent to <code>{{../..}}</code> in a template.</p>
<div class="api new-api-box">
<h3 id="template_body" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_body">Template.body</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>The <a href="http://localhost:3000/#templates_api">template object</a> representing your <code>&lt;body&gt;</code> tag.</p>
</div>
</div>
<p>You can define helpers and event maps on <code>Template.body</code> just like on any <code>Template.myTemplate</code> object.</p>
<p>Helpers on <code>Template.body</code> are only available in the <code>&lt;body&gt;</code> tags of your app. To register a global helper, use <a href="http://localhost:3000/#template_registerhelper">Template.registerHelper</a>. Event maps on <code>Template.body</code> don't apply to elements added to the body via <code>Blaze.render</code>, jQuery, or the DOM API, or to the body element itself. To handle events on the body, window, or document, use jQuery or the DOM API.</p>
<div class="api new-api-box">
<h3 id="template_dynamic" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/template_dynamic">{{&gt; Template.dynamic template=template [data=data] }}</a> <span class="locus">Templates</span></h3>
<div class="desc">
<p>Choose a template to include dynamically, by name.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">template</span> <span class="type">String</span></dt>
<dd>
<p>The name of the template to include.</p>
</dd>
<dt><span class="name">data</span> <span class="type">Object</span></dt>
<dd>
<p>Optional. The data context in which to include the template.</p>
</dd>
</dl>
</div>
<p><code>Template.dynamic</code> allows you to include a template by name, where the name may be calculated by a helper and may change reactively. The <code>data</code> argument is optional, and if it is omitted, the current data context is used.</p>
<p>For example, if there is a template named "foo", <code>{{&gt; Template.dynamic template="foo"}}</code> is equivalent to <code>{{&gt; foo}}</code>.</p>
<h3 id="eventmaps" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/eventmaps">Event Maps</a></h3>
<p>An event map is an object where the properties specify a set of events to handle, and the values are the handlers for those events. The property can be in one of several forms:</p>
<dl>
<dt><span class="name"><em>eventtype</em></span></dt>
<dd>
<p>Matches a particular type of event, such as 'click'.</p>
</dd>
<dt><span class="name"><em>eventtype selector</em></span></dt>
<dd>
<p>Matches a particular type of event, but only when it appears on an element that matches a certain CSS selector.</p>
</dd>
<dt><span class="name"><em>event1, event2</em></span></dt>
<dd>
<p>To handle more than one type of event with the same function, use a comma-separated list.</p>
</dd>
</dl>
<p>The handler function receives two arguments: <code>event</code>, an object with information about the event, and <code>template</code>, a <a href="http://localhost:3000/#template_inst">template instance</a> for the template where the handler is defined. The handler also receives some additional context data in <code>this</code>, depending on the context of the current element handling the event. In a template, an element's context is the data context where that element occurs, which is set by block helpers such as <code>#with</code> and <code>#each</code>.</p>
<p>Example:</p>
<pre><code class="hljs coffeescript">{
  <span class="hljs-regexp">//</span> Fires <span class="hljs-keyword">when</span> any element <span class="hljs-keyword">is</span> clicked
  <span class="hljs-string">'click'</span>: <span class="hljs-reserved">function</span> (event) { ... },

  <span class="hljs-regexp">//</span> Fires <span class="hljs-keyword">when</span> any element <span class="hljs-reserved">with</span> the <span class="hljs-string">'accept'</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">is</span> <span class="hljs-title">clicked</span></span>
  <span class="hljs-string">'click .accept'</span>: <span class="hljs-reserved">function</span> (event) { ... },

  <span class="hljs-regexp">//</span> Fires <span class="hljs-keyword">when</span> <span class="hljs-string">'accept'</span> <span class="hljs-keyword">is</span> clicked <span class="hljs-keyword">or</span> focused, <span class="hljs-keyword">or</span> a key <span class="hljs-keyword">is</span> pressed
  <span class="hljs-string">'click .accept, focus .accept, keypress'</span>: <span class="hljs-reserved">function</span> (event) { ... }
}
</code></pre>
<p>Most events bubble up the document tree from their originating element. For example, <code>'click p'</code> catches a click anywhere in a paragraph, even if the click originated on a link, span, or some other element inside the paragraph. The originating element of the event is available as the <code>target</code> property, while the element that matched the selector and is currently handling it is called <code>currentTarget</code>.</p>
<pre><code class="hljs javascript">{
  <span class="hljs-string">'click p'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event)</span> </span>{
    <span class="hljs-keyword">var</span> paragraph = event.currentTarget; <span class="hljs-comment">// always a P</span>
    <span class="hljs-keyword">var</span> clickedElement = event.target; <span class="hljs-comment">// could be the P or a child element</span>
  }
}
</code></pre>
<p>If a selector matches multiple elements that an event bubbles to, it will be called multiple times, for example in the case of <code>'click div'</code> or <code>'click *'</code>. If no selector is given, the handler will only be called once, on the original target element.</p>
<p>The following properties and methods are available on the event object passed to handlers:</p>
<dl class="objdesc">
<dt><span class="name">type</span> <span class="type">String</span></dt>
<dd>
<p>The event's type, such as "click", "blur" or "keypress".</p>
</dd>
<dt><span class="name">target</span> <span class="type">DOM Element</span></dt>
<dd>
<p>The element that originated the event.</p>
</dd>
<dt><span class="name">currentTarget</span> <span class="type">DOM Element</span></dt>
<dd>
<p>The element currently handling the event. This is the element that matched the selector in the event map. For events that bubble, it may be <code>target</code> or an ancestor of <code>target</code>, and its value changes as the event bubbles.</p>
</dd>
<dt><span class="name">which</span> <span class="type">Number</span></dt>
<dd>
<p>For mouse events, the number of the mouse button (1=left, 2=middle, 3=right). For key events, a character or key code.</p>
</dd>
<dt><span class="name">stopPropagation()</span></dt>
<dd>
<p>Prevent the event from propagating (bubbling) up to other elements. Other event handlers matching the same element are still fired, in this and other event maps.</p>
</dd>
<dt><span class="name">stopImmediatePropagation()</span></dt>
<dd>
<p>Prevent all additional event handlers from being run on this event, including other handlers in this event map, handlers reached by bubbling, and handlers in other event maps.</p>
</dd>
<dt><span class="name">preventDefault()</span></dt>
<dd>
<p>Prevents the action the browser would normally take in response to this event, such as following a link or submitting a form. Further handlers are still called, but cannot reverse the effect.</p>
</dd>
<dt><span class="name">isPropagationStopped()</span></dt>
<dd>
<p>Returns whether <code>stopPropagation()</code> has been called for this event.</p>
</dd>
<dt><span class="name">isImmediatePropagationStopped()</span></dt>
<dd>
<p>Returns whether <code>stopImmediatePropagation()</code> has been called for this event.</p>
</dd>
<dt><span class="name">isDefaultPrevented()</span></dt>
<dd>
<p>Returns whether <code>preventDefault()</code> has been called for this event.</p>
</dd>
</dl>
<p>Returning <code>false</code> from a handler is the same as calling both <code>stopImmediatePropagation</code> and <code>preventDefault</code> on the event.</p>
<p>Event types and their uses include:</p>
<dl class="objdesc">
<dt><span class="name"><code>click</code></span></dt>
<dd>
<p>Mouse click on any element, including a link, button, form control, or div. Use <code>preventDefault()</code> to prevent a clicked link from being followed. Some ways of activating an element from the keyboard also fire <code>click</code>.</p>
</dd>
<dt><span class="name"><code>dblclick</code></span></dt>
<dd>
<p>Double-click.</p>
</dd>
<dt><span class="name"><code>focus, blur</code></span></dt>
<dd>
<p>A text input field or other form control gains or loses focus. You can make any element focusable by giving it a <code>tabindex</code> property. Browsers differ on whether links, checkboxes, and radio buttons are natively focusable. These events do not bubble.</p>
</dd>
<dt><span class="name"><code>change</code></span></dt>
<dd>
<p>A checkbox or radio button changes state. For text fields, use <code>blur</code> or key events to respond to changes.</p>
</dd>
<dt><span class="name"><code>mouseenter, mouseleave</code></span></dt>
<dd>
<p>The pointer enters or leaves the bounds of an element. These events do not bubble.</p>
</dd>
<dt><span class="name"><code>mousedown, mouseup</code></span></dt>
<dd>
<p>The mouse button is newly down or up.</p>
</dd>
<dt><span class="name"><code>keydown, keypress, keyup</code></span></dt>
<dd>
<p>The user presses a keyboard key. <code>keypress</code> is most useful for catching typing in text fields, while <code>keydown</code> and <code>keyup</code> can be used for arrow keys or modifier keys.</p>
</dd>
</dl>
<p>Other DOM events are available as well, but for the events above, Meteor has taken some care to ensure that they work uniformly in all browsers.</p>
<h3 id="spacebars" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/spacebars">Spacebars</a></h3>
<p>Spacebars is the language used to write Meteor templates. It is inspired by <a href="http://handlebarsjs.com/">Handlebars</a>. It shares some of the spirit and syntax of Handlebars, but has been tailored to produce reactive Meteor templates when compiled.</p>
<p>For more information about Spacebars, see the <a href="https://github.com/meteor/meteor/blob/devel/packages/spacebars/README.md">Spacebars README</a>.</p>
<h2 id="blaze">Blaze</h2>
<p>Blaze is the package that makes reactive templates possible. You can use the Blaze API directly in order to render templates programmatically and manipulate "Views," the building blocks of reactive templates. For more information, check out the <a href="https://www.meteor.com/blaze">Blaze project page</a>.</p>
<div class="api new-api-box">
<h3 id="blaze_render" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_render">Blaze.render(templateOrView, parentNode, [nextNode], [parentView])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Renders a template or View to DOM nodes and inserts it into the DOM, returning a rendered <a href="http://localhost:3000/#blaze_view">View</a> which can be passed to <a href="http://localhost:3000/#blaze_remove"><code>Blaze.remove</code></a>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">templateOrView</span> <span class="type"><a href="http://localhost:3000/#blaze_template">Blaze.Template</a> or <a href="http://localhost:3000/#blaze_view">Blaze.View</a></span></dt>
<dd>
<p>The template (e.g. <code>Template.myTemplate</code>) or View object to render. If a template, a View object is <a href="http://localhost:3000/#template_constructview">constructed</a>. If a View, it must be an unrendered View, which becomes a rendered View and is returned.</p>
</dd>
<dt><span class="name">parentNode</span> <span class="type"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node">DOM Node</a></span></dt>
<dd>
<p>The node that will be the parent of the rendered template. It must be an Element node.</p>
</dd>
<dt><span class="name">nextNode</span> <span class="type"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node">DOM Node</a></span></dt>
<dd>
<p>Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.</p>
</dd>
<dt><span class="name">parentView</span> <span class="type"><a href="http://localhost:3000/#blaze_view">Blaze.View</a></span></dt>
<dd>
<p>Optional. If provided, it will be set as the rendered View's <a href="http://localhost:3000/#view_parentview"><code>parentView</code></a>.</p>
</dd>
</dl>
</div>
<p>When you render a template, the callbacks added with <a href="http://localhost:3000/#template_onCreated"><code>onCreated</code></a> are invoked immediately, before evaluating the content of the template. The callbacks added with <a href="http://localhost:3000/#template_onRendered"><code>onRendered</code></a> are invoked after the View is rendered and inserted into the DOM.</p>
<p>The rendered template will update reactively in response to data changes until the View is removed using <a href="http://localhost:3000/#blaze_remove"><code>Blaze.remove</code></a> or the View's parent element is removed by Meteor or jQuery.</p>
<div class="warning">
<p>If the View is removed by some other mechanism besides Meteor or jQuery (which Meteor integrates with by default), the View may continue to update indefinitely. Most users will not need to manually render templates and insert them into the DOM, but if you do, be mindful to always call <a href="http://localhost:3000/#blaze_remove"><code>Blaze.remove</code></a> when the View is no longer needed.</p>
</div>
<div class="api new-api-box">
<h3 id="blaze_renderwithdata" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_renderwithdata">Blaze.renderWithData(templateOrView, data, parentNode, [nextNode], [parentView])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Renders a template or View to DOM nodes with a data context. Otherwise identical to <code>Blaze.render</code>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">templateOrView</span> <span class="type"><a href="http://localhost:3000/#blaze_template">Blaze.Template</a> or <a href="http://localhost:3000/#blaze_view">Blaze.View</a></span></dt>
<dd>
<p>The template (e.g. <code>Template.myTemplate</code>) or View object to render.</p>
</dd>
<dt><span class="name">data</span> <span class="type">Object or Function</span></dt>
<dd>
<p>The data context to use, or a function returning a data context. If a function is provided, it will be reactively re-run.</p>
</dd>
<dt><span class="name">parentNode</span> <span class="type"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node">DOM Node</a></span></dt>
<dd>
<p>The node that will be the parent of the rendered template. It must be an Element node.</p>
</dd>
<dt><span class="name">nextNode</span> <span class="type"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node">DOM Node</a></span></dt>
<dd>
<p>Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.</p>
</dd>
<dt><span class="name">parentView</span> <span class="type"><a href="http://localhost:3000/#blaze_view">Blaze.View</a></span></dt>
<dd>
<p>Optional. If provided, it will be set as the rendered View's <a href="http://localhost:3000/#view_parentview"><code>parentView</code></a>.</p>
</dd>
</dl>
</div>
<p><code>Blaze.renderWithData(Template.myTemplate, data)</code> is essentially the same as <code>Blaze.render(Blaze.With(data, function () { return Template.myTemplate; }))</code>.</p>
<div class="api new-api-box">
<h3 id="blaze_remove" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_remove">Blaze.remove(renderedView)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Removes a rendered View from the DOM, stopping all reactive updates and event listeners on it.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">renderedView</span> <span class="type"><a href="http://localhost:3000/#blaze_view">Blaze.View</a></span></dt>
<dd>
<p>The return value from <code>Blaze.render</code> or <code>Blaze.renderWithData</code>.</p>
</dd>
</dl>
</div>
<p>Use <code>Blaze.remove</code> to remove a template or View previously inserted with <code>Blaze.render</code>, in such a way that any behaviors attached to the DOM by Meteor are cleaned up. The rendered template or View is now considered <a href="http://localhost:3000/#template_onDestroyed">"destroyed"</a>, along with all nested templates and Views. In addition, any data assigned via jQuery to the DOM nodes is removed, as if the nodes were passed to jQuery's <code>$(...).remove()</code>.</p>
<p>As mentioned in <a href="http://localhost:3000/#blaze_render"><code>Blaze.render</code></a>, it is important to "remove" all content rendered via <code>Blaze.render</code> using <code>Blaze.remove</code>, unless the parent node of <code>renderedView</code> is removed by a Meteor reactive update or with jQuery.</p>
<p><code>Blaze.remove</code> can be used even if the DOM nodes in question have already been removed from the document, to tell Blaze to stop tracking and updating these nodes.</p>
<div class="api new-api-box">
<h3 id="blaze_getdata" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_getdata">Blaze.getData([elementOrView])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Returns the current data context, or the data context that was used when rendering a particular DOM element or View from a Meteor template.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">elementOrView</span> <span class="type"><a href="https://developer.mozilla.org/en-US/docs/Web/API/element">DOM Element</a> or <a href="http://localhost:3000/#blaze_view">Blaze.View</a></span></dt>
<dd>
<p>Optional. An element that was rendered by a Meteor, or a View.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="blaze_tohtml" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_tohtml">Blaze.toHTML(templateOrView)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Renders a template or View to a string of HTML.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">templateOrView</span> <span class="type"><a href="http://localhost:3000/#blaze_template">Blaze.Template</a> or <a href="http://localhost:3000/#blaze_view">Blaze.View</a></span></dt>
<dd>
<p>The template (e.g. <code>Template.myTemplate</code>) or View object from which to generate HTML.</p>
</dd>
</dl>
</div>
<p>Rendering a template to HTML loses all fine-grained reactivity. The normal way to render a template is to either include it from another template (<code>{{&gt; myTemplate}}</code>) or render and insert it programmatically using <code>Blaze.render</code>. Only occasionally is generating HTML useful.</p>
<p>Because <code>Blaze.toHTML</code> returns a string, it is not able to update the DOM in response to reactive data changes. Instead, any reactive data changes will invalidate the current Computation if there is one (for example, an autorun that is the caller of <code>Blaze.toHTML</code>).</p>
<div class="api new-api-box">
<h3 id="blaze_tohtmlwithdata" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_tohtmlwithdata">Blaze.toHTMLWithData(templateOrView, data)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Renders a template or View to HTML with a data context. Otherwise identical to <code>Blaze.toHTML</code>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">templateOrView</span> <span class="type"><a href="http://localhost:3000/#blaze_template">Blaze.Template</a> or <a href="http://localhost:3000/#blaze_view">Blaze.View</a></span></dt>
<dd>
<p>The template (e.g. <code>Template.myTemplate</code>) or View object from which to generate HTML.</p>
</dd>
<dt><span class="name">data</span> <span class="type">Object or Function</span></dt>
<dd>
<p>The data context to use, or a function returning a data context.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="blaze_view" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_view">new Blaze.View([name], renderFunction)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Constructor for a View, which represents a reactive region of DOM.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">name</span> <span class="type">String</span></dt>
<dd>
<p>Optional. A name for this type of View. See <a href="http://localhost:3000/#view_name"><code>view.name</code></a>.</p>
</dd>
<dt><span class="name">renderFunction</span> <span class="type">Function</span></dt>
<dd>
<p>A function that returns <a href="http://localhost:3000/#renderable_content"><em>renderable content</em></a>. In this function, <code>this</code> is bound to the View.</p>
</dd>
</dl>
</div>
<p>Behind every template or part of a template &mdash; a template tag, say, like <code>{{foo}}</code> or <code>{{#if}}</code> &mdash; is a View object, which is a reactively updating region of DOM.</p>
<p>Most applications do not need to be aware of these Views, but they offer a way to understand and customize Meteor's rendering behavior for more advanced applications and packages.</p>
<p>You can obtain a View object by calling <a href="http://localhost:3000/#blaze_render"><code>Blaze.render</code></a> on a template, or by accessing <a href="http://localhost:3000/#template_view"><code>template.view</code></a> on a template instance.</p>
<p>At the heart of a View is an <a href="http://localhost:3000/#tracker_autorun">autorun</a> that calls the View's <code>renderFunction</code>, uses the result to create DOM nodes, and replaces the contents of the View with these new DOM nodes. A View's content may consist of any number of consecutive DOM nodes (though if it is zero, a placeholder node such as a comment or an empty text node is automatically supplied). Any reactive dependency established by <code>renderFunction</code> causes a full recalculation of the View's contents when the dependency is invalidated. Templates, however, are compiled in such a way that they do not have top-level dependencies and so will only ever render once, while their parts may re-render many times.</p>
<p>When a <code>Blaze.View</code> is constructed by calling the constructor, no hooks are fired and no rendering is performed. In particular, the View is not yet considered to be "created." Only when the View is actually used, by a call to <code>Blaze.render</code> or <code>Blaze.toHTML</code> or by inclusion in another View, is it "created," right before it is rendered for the first time. When a View is created, its <code>.parentView</code> is set if appropriate, and then the <code>onViewCreated</code> hook is fired. The term "unrendered View" means a newly constructed View that has not been "created" or rendered.</p>
<p>The "current View" is kept in <a href="http://localhost:3000/#blaze_currentview"><code>Blaze.currentView</code></a> and is set during View rendering, callbacks, autoruns, and template event handlers. It affects calls such as <a href="http://localhost:3000/#template_currentdata"><code>Template.currentData()</code></a>.</p>
<p>The following properties and methods are available on Blaze.View:</p>
<dl class="objdesc">
<dt><span id="view_name" class="name">name</span> <span class="type">String</span></dt>
<dd>
<p>The name of this type of View. View names may be used to identify particular kinds of Views in code, but more often they simply aid in debugging and comprehensibility of the View tree. Views generated by Meteor have names like "Template.foo" and "if".</p>
</dd>
<dt><span id="view_parentview" class="name">parentView</span> <span class="type">View or null</span></dt>
<dd>
<p>The enclosing View that caused this View to be rendered, if any.</p>
</dd>
<dt><span id="view_iscreated" class="name">isCreated</span> <span class="type">Boolean</span></dt>
<dd>
<p>True if this View has been called on to be rendered by <code>Blaze.render</code> or <code>Blaze.toHTML</code> or another View. Once it becomes true, never becomes false again. A "created" View's <code>.parentView</code> has been set to its final value. <code>isCreated</code> is set to true before <code>onViewCreated</code> hooks are called.</p>
</dd>
<dt><span id="view_isrendered" class="name">isRendered</span> <span class="type">Boolean</span></dt>
<dd>
<p>True if this View has been rendered to DOM by <code>Blaze.render</code> or by the rendering of an enclosing View. Conversion to HTML by <code>Blaze.toHTML</code> doesn't count. Once true, never becomes false.</p>
</dd>
<dt><span id="view_isdestroyed" class="name">isDestroyed</span> <span class="type">Boolean</span></dt>
<dd>
<p>True if this View has been destroyed, such as by <code>Blaze.remove()</code> or by a reactive update that removes it. A destroyed View's autoruns have been stopped, and its DOM nodes have generally been cleaned of all Meteor reactivity and possibly dismantled.</p>
</dd>
<dt><span id="view_rendercount" class="name">renderCount</span> <span class="type">Integer</span></dt>
<dd>
<p>The number of times the View has been rendered, including the current time is the View is in the process of being rendered or re-rendered.</p>
</dd>
<dt><span id="view_autorun" class="name">autorun(runFunc)</span></dt>
<dd>
<p>Like <a href="http://localhost:3000/#tracker_autorun"><code>Tracker.autorun</code></a>, except that the autorun is automatically stopped when the View is destroyed, and the <a href="http://localhost:3000/#blaze_currentview">current View</a> is always set when running <code>runFunc</code>. There is no relationship to the View's internal autorun or render cycle. In <code>runFunc</code>, the View is bound to <code>this</code>.</p>
</dd>
<dt><span id="view_onviewcreated" class="name">onViewCreated(func)</span></dt>
<dd>
<p>If the View hasn't been created yet, calls <code>func</code> when the View is created. In <code>func</code>, the View is bound to <code>this</code>.</p>
<p>This hook is the basis for the <a href="http://localhost:3000/#template_created"><code>created</code></a> template callback.</p>
</dd>
<dt><span id="view_onviewready" class="name">onViewReady(func)</span></dt>
<dd>
<p>Calls <code>func</code> when the View is rendered and inserted into the DOM, after waiting for the end of <a href="http://localhost:3000/#tracker_afterflush">flush time</a>. Does not fire if the View is destroyed at any point before it would fire. May fire multiple times (if the View re-renders). In <code>func</code>, the View is bound to <code>this</code>.</p>
<p>This hook is the basis for the <a href="http://localhost:3000/#template_rendered"><code>rendered</code></a> template callback.</p>
</dd>
<dt><span id="view_onviewdestroyed" class="name">onViewDestroyed(func)</span></dt>
<dd>
<p>If the View hasn't been destroyed yet, calls <code>func</code> when the View is destroyed. A View may be destroyed without ever becoming "ready." In <code>func</code>, the View is bound to <code>this</code>.</p>
<p>This hook is the basis for the <a href="http://localhost:3000/#template_destroyed"><code>destroyed</code></a> template callback.</p>
</dd>
<dt><span id="view_firstnode" class="name">firstNode()</span> <span class="type">DOM node</span></dt>
<dd>
<p>The first node of the View's rendered content. Note that this may be a text node. Requires that the View be rendered. If the View rendered to zero DOM nodes, it may be a placeholder node (comment or text node). The DOM extent of a View consists of the nodes between <code>view.firstNode()</code> and <code>view.lastNode()</code>, inclusive.</p>
</dd>
<dt><span id="view_lastnode" class="name">lastNode()</span> <span class="type">DOM node</span></dt>
<dd>
<p>The last node of the View's rendered content.</p>
<p>See <a href="http://localhost:3000/#view_firstnode"><code>firstNode()</code></a>.</p>
</dd>
<dt><span id="view_template" class="name">template</span> <span class="type">Template</span></dt>
<dd>
<p>For Views created by invoking templates, the original Template object. For example, <code>Blaze.render(Template.foo).template === Template.foo</code>.</p>
</dd>
<dt><span id="view_templateinstance" class="name">templateInstance()</span> <span class="type">Template instance</span></dt>
<dd>
<p>For Views created by invoking templates, returns the <a href="http://localhost:3000/#template_inst">template instance</a> object for this particular View. For example, in a <a href="http://localhost:3000/#template_created"><code>created</code></a> callback, <code>this.view.templateInstance() === this</code>.</p>
<p>Template instance objects have fields like <code>data</code>, <code>firstNode</code>, and <code>lastNode</code> which are not reactive and which are also not automatically kept up to date. Calling <code>templateInstance()</code> causes these fields to be updated.</p>
</dd>
</dl>
<div class="api new-api-box">
<h3 id="blaze_currentview" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_currentview">Blaze.currentView</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>The View corresponding to the current template helper, event handler, callback, or autorun. If there isn't one, <code>null</code>.</p>
</div>
</div>
<p>The "current view" is used by <a href="http://localhost:3000/#template_currentdata"><code>Template.currentData()</code></a> and <a href="http://localhost:3000/#template_instance"><code>Template.instance()</code></a> to determine the contextually relevant data context and template instance.</p>
<div class="api new-api-box">
<h3 id="blaze_getview" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_getview">Blaze.getView([element])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Gets either the current View, or the View enclosing the given DOM element.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">element</span> <span class="type"><a href="https://developer.mozilla.org/en-US/docs/Web/API/element">DOM Element</a></span></dt>
<dd>
<p>Optional. If specified, the View enclosing <code>element</code> is returned.</p>
</dd>
</dl>
</div>
<p>If you don't specify an <code>element</code>, there must be a current View or an error will be thrown. This is in contrast to <a href="http://localhost:3000/#blaze_currentview"><code>Blaze.currentView</code></a>.</p>
<div class="api new-api-box">
<h3 id="blaze_with" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_with">Blaze.With(data, contentFunc)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Constructs a View that renders content with a data context.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">data</span> <span class="type">Object or Function</span></dt>
<dd>
<p>An object to use as the data context, or a function returning such an object. If a function is provided, it will be reactively re-run.</p>
</dd>
<dt><span class="name">contentFunc</span> <span class="type">Function</span></dt>
<dd>
<p>A Function that returns <a href="http://localhost:3000/#renderable_content"><em>renderable content</em></a>.</p>
</dd>
</dl>
</div>
<p>Returns an unrendered View object you can pass to <code>Blaze.render</code>.</p>
<p>Unlike <code>{{#with}}</code> (as used in templates), <code>Blaze.With</code> has no "else" case, and a falsy value for the data context will not prevent the content from rendering.</p>
<div class="api new-api-box">
<h3 id="blaze_if" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_if">Blaze.If(conditionFunc, contentFunc, [elseFunc])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Constructs a View that renders content conditionally.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">conditionFunc</span> <span class="type">Function</span></dt>
<dd>
<p>A function to reactively re-run. Whether the result is truthy or falsy determines whether <code>contentFunc</code> or <code>elseFunc</code> is shown. An empty array is considered falsy.</p>
</dd>
<dt><span class="name">contentFunc</span> <span class="type">Function</span></dt>
<dd>
<p>A Function that returns <a href="http://localhost:3000/#renderable_content"><em>renderable content</em></a>.</p>
</dd>
<dt><span class="name">elseFunc</span> <span class="type">Function</span></dt>
<dd>
<p>Optional. A Function that returns <a href="http://localhost:3000/#renderable_content"><em>renderable content</em></a>. If no <code>elseFunc</code> is supplied, no content is shown in the "else" case.</p>
</dd>
</dl>
</div>
<p>Returns an unrendered View object you can pass to <code>Blaze.render</code>.</p>
<p>Matches the behavior of <code>{{#if}}</code> in templates.</p>
<div class="api new-api-box">
<h3 id="blaze_unless" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_unless">Blaze.Unless(conditionFunc, contentFunc, [elseFunc])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>An inverted <a href="http://localhost:3000/#blaze_if"><code>Blaze.If</code></a>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">conditionFunc</span> <span class="type">Function</span></dt>
<dd>
<p>A function to reactively re-run. If the result is falsy, <code>contentFunc</code> is shown, otherwise <code>elseFunc</code> is shown. An empty array is considered falsy.</p>
</dd>
<dt><span class="name">contentFunc</span> <span class="type">Function</span></dt>
<dd>
<p>A Function that returns <a href="http://localhost:3000/#renderable_content"><em>renderable content</em></a>.</p>
</dd>
<dt><span class="name">elseFunc</span> <span class="type">Function</span></dt>
<dd>
<p>Optional. A Function that returns <a href="http://localhost:3000/#renderable_content"><em>renderable content</em></a>. If no <code>elseFunc</code> is supplied, no content is shown in the "else" case.</p>
</dd>
</dl>
</div>
<p>Returns an unrendered View object you can pass to <code>Blaze.render</code>.</p>
<p>Matches the behavior of <code>{{#unless}}</code> in templates.</p>
<div class="api new-api-box">
<h3 id="blaze_each" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_each">Blaze.Each(argFunc, contentFunc, [elseFunc])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Constructs a View that renders <code>contentFunc</code> for each item in a sequence.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">argFunc</span> <span class="type">Function</span></dt>
<dd>
<p>A function to reactively re-run. The function may return a Cursor, an array, null, or undefined.</p>
</dd>
<dt><span class="name">contentFunc</span> <span class="type">Function</span></dt>
<dd>
<p>A Function that returns <a href="http://localhost:3000/#renderable_content"><em>renderable content</em></a>.</p>
</dd>
<dt><span class="name">elseFunc</span> <span class="type">Function</span></dt>
<dd>
<p>Optional. A Function that returns <a href="http://localhost:3000/#renderable_content"><em>renderable content</em></a> to display in the case when there are no items to display.</p>
</dd>
</dl>
</div>
<p>Returns an unrendered View object you can pass to <code>Blaze.render</code>.</p>
<p>Matches the behavior of <code>{{#each}}</code> in templates.</p>
<div class="api new-api-box">
<h3 id="blaze_template" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_template">new Blaze.Template([viewName], renderFunction)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Constructor for a Template, which is used to construct Views with particular name and content.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">viewName</span> <span class="type">String</span></dt>
<dd>
<p>Optional. A name for Views constructed by this Template. See <a href="http://localhost:3000/#view_name"><code>view.name</code></a>.</p>
</dd>
<dt><span class="name">renderFunction</span> <span class="type">Function</span></dt>
<dd>
<p>A function that returns <a href="http://localhost:3000/#renderable_content"><em>renderable content</em></a>. This function is used as the <code>renderFunction</code> for Views constructed by this Template.</p>
</dd>
</dl>
</div>
<p>Templates defined by the template compiler, such as <code>Template.myTemplate</code>, are objects of type <code>Blaze.Template</code> (aliased as <code>Template</code>).</p>
<p>In addition to methods like <code>events</code> and <code>helpers</code>, documented as part of the <a href="http://localhost:3000/#templates_api">Template API</a>, the following fields and methods are present on template objects:</p>
<dl class="objdesc">
<dt><span id="template_viewname" class="name">viewName</span> <span class="type">String</span></dt>
<dd>
<p>Same as the constructor argument.</p>
</dd>
<dt><span id="template_renderfunction" class="name">renderFunction</span> <span class="type">Function</span></dt>
<dd>
<p>Same as the constructor argument.</p>
</dd>
<dt><span id="template_constructview" class="name">constructView()</span></dt>
<dd>
<p>Constructs and returns an unrendered View object. This method is invoked by Meteor whenever the template is used, such as by <code>Blaze.render</code> or by <code>{{&gt; foo}}</code> where <code>foo</code> resolves to a Template object.</p>
<p><code>constructView()</code> constructs a View using <code>viewName</code> and <code>renderFunction</code> as constructor arguments, and then configures it as a template View, setting up <code>view.template</code>, <code>view.templateInstance()</code>, event maps, and so on.</p>
</dd>
</dl>
<div class="api new-api-box">
<h3 id="blaze_istemplate" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/blaze_istemplate">Blaze.isTemplate(value)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Returns true if <code>value</code> is a template object like <code>Template.myTemplate</code>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">value</span> <span class="type">Any</span></dt>
<dd>
<p>The value to test.</p>
</dd>
</dl>
</div>
<h3 id="renderable_content" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/renderable_content">Renderable Content</a></h3>
<p>A value is <em>renderable content</em> if it is one of the following:</p>
<ul>
<li>A <a href="http://localhost:3000/#templates_api">template object</a> like <code>Template.myTemplate</code></li>
<li>An unrendered <a href="http://localhost:3000/#blaze_view">View</a> object, like the return value of <code>Blaze.With</code></li>
<li><code>null</code> or <code>undefined</code></li>
</ul>
<div class="note">
<p>Internally, renderable content includes objects representing HTML tags as well, but these objects are not yet part of the officially-supported, public API.</p>
</div>
<h2 id="timers">Timers</h2>
<p>Meteor uses global environment variables to keep track of things like the current request's user. To make sure these variables have the right values, you need to use <code>Meteor.setTimeout</code> instead of <code>setTimeout</code> and <code>Meteor.setInterval</code> instead of <code>setInterval</code>.</p>
<p>These functions work just like their native JavaScript equivalents. If you call the native function, you'll get an error stating that Meteor code must always run within a Fiber, and advising to use <code>Meteor.bindEnvironment</code>.</p>
<div class="api new-api-box">
<h3 id="meteor_settimeout" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_settimeout">Meteor.setTimeout(func, delay)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Call a function in the future after waiting for a specified delay.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">func</span> <span class="type">Function</span></dt>
<dd>
<p>The function to run</p>
</dd>
<dt><span class="name">delay</span> <span class="type">Number</span></dt>
<dd>
<p>Number of milliseconds to wait before calling function</p>
</dd>
</dl>
</div>
<p>Returns a handle that can be used by <code>Meteor.clearTimeout</code>.</p>
<div class="api new-api-box">
<h3 id="meteor_setinterval" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_setinterval">Meteor.setInterval(func, delay)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Call a function repeatedly, with a time delay between calls.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">func</span> <span class="type">Function</span></dt>
<dd>
<p>The function to run</p>
</dd>
<dt><span class="name">delay</span> <span class="type">Number</span></dt>
<dd>
<p>Number of milliseconds to wait between each function call.</p>
</dd>
</dl>
</div>
<p>Returns a handle that can be used by <code>Meteor.clearInterval</code>.</p>
<div class="api new-api-box">
<h3 id="meteor_cleartimeout" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_cleartimeout">Meteor.clearTimeout(id)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Cancel a function call scheduled by <code>Meteor.setTimeout</code>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">id</span> <span class="type">Number</span></dt>
<dd>
<p>The handle returned by <code>Meteor.setTimeout</code></p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="meteor_clearinterval" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/meteor_clearinterval">Meteor.clearInterval(id)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Cancel a repeating function call scheduled by <code>Meteor.setInterval</code>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">id</span> <span class="type">Number</span></dt>
<dd>
<p>The handle returned by <code>Meteor.setInterval</code></p>
</dd>
</dl>
</div>
<h2 id="tracker">Tracker</h2>
<p>Meteor has a simple dependency tracking system which allows it to automatically rerun templates and other computations whenever <a href="http://localhost:3000/#session"><code>Session</code></a> variables, database queries, and other data sources change.</p>
<p>Unlike most other systems, you don't have to manually declare these dependencies &mdash; it "just works". The mechanism is simple and efficient. When you call a function that supports reactive updates (such as a database query), it automatically saves the current Computation object, if any (representing, for example, the current template being rendered). Later, when the data changes, the function can "invalidate" the Computation, causing it to rerun (rerendering the template).</p>
<p>Applications will find <a href="http://localhost:3000/#tracker_autorun"><code>Tracker.autorun</code></a> useful, while more advanced facilities such as <code>Tracker.Dependency</code> and <code>onInvalidate</code> callbacks are intended primarily for package authors implementing new reactive data sources.</p>
<p>To learn more about how Tracker works and to explore advanced ways to use it, visit the <a href="http://manual.meteor.com/#tracker"> Tracker</a> chapter in the <a href="http://manual.meteor.com/">Meteor Manual</a>, which describes it in complete detail.</p>
<div class="api new-api-box">
<h3 id="tracker_autorun" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/tracker_autorun">Tracker.autorun(runFunc)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Run a function now and rerun it later whenever its dependencies change. Returns a Computation object that can be used to stop or observe the rerunning.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">runFunc</span> <span class="type">Function</span></dt>
<dd>
<p>The function to run. It receives one argument: the Computation object that will be returned.</p>
</dd>
</dl>
</div>
<p><code>Tracker.autorun</code> allows you to run a function that depends on reactive data sources, in such a way that if there are changes to the data later, the function will be rerun.</p>
<p>For example, you can monitor a cursor (which is a reactive data source) and aggregate it into a session variable:</p>
<pre><code class="hljs javascript">Tracker.autorun(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> oldest = _.max(Monkeys.find().fetch(), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(monkey)</span> </span>{
    <span class="hljs-keyword">return</span> monkey.age;
  });
  <span class="hljs-keyword">if</span> (oldest)
    Session.set(<span class="hljs-string">"oldest"</span>, oldest.name);
});
</code></pre>
<p>Or you can wait for a session variable to have a certain value, and do something the first time it does, calling <code>stop</code> on the computation to prevent further rerunning:</p>
<pre><code class="hljs javascript">Tracker.autorun(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(c)</span> </span>{
  <span class="hljs-keyword">if</span> (! Session.equals(<span class="hljs-string">"shouldAlert"</span>, <span class="hljs-literal">true</span>))
    <span class="hljs-keyword">return</span>;

  c.stop();
  alert(<span class="hljs-string">"Oh no!"</span>);
});
</code></pre>
<p>The function is invoked immediately, at which point it may alert and stop right away if <code>shouldAlert</code> is already true. If not, the function is run again when <code>shouldAlert</code> becomes true.</p>
<p>A change to a data dependency does not cause an immediate rerun, but rather "invalidates" the computation, causing it to rerun the next time a flush occurs. A flush will occur automatically as soon as the system is idle if there are invalidated computations. You can also use <a href="http://localhost:3000/#tracker_flush"><code>Tracker.flush</code></a> to cause an immediate flush of all pending reruns.</p>
<p>If you nest calls to <code>Tracker.autorun</code>, then when the outer call stops or reruns, the inner call will stop automatically. Subscriptions and observers are also automatically stopped when used as part of a computation that is rerun, allowing new ones to be established. See <a href="http://localhost:3000/#meteor_subscribe"><code>Meteor.subscribe</code></a> for more information about subscriptions and reactivity.</p>
<p>If the initial run of an autorun throws an exception, the computation is automatically stopped and won't be rerun.</p>
<div class="api new-api-box">
<h3 id="tracker_flush" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/tracker_flush">Tracker.flush()</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Process all reactive updates immediately and ensure that all invalidated computations are rerun.</p>
</div>
</div>
<p>Normally, when you make changes (like writing to the database), their impact (like updating the DOM) is delayed until the system is idle. This keeps things predictable &mdash; you can know that the DOM won't go changing out from under your code as it runs. It's also one of the things that makes Meteor fast.</p>
<p><code>Tracker.flush</code> forces all of the pending reactive updates to complete. For example, if an event handler changes a Session variable that will cause part of the user interface to rerender, the handler can call <code>flush</code> to perform the rerender immediately and then access the resulting DOM.</p>
<p>An automatic flush occurs whenever the system is idle which performs exactly the same work as <code>Tracker.flush</code>. The flushing process consists of rerunning any invalidated computations. If additional invalidations happen while flushing, they are processed as part of the same flush until there is no more work to be done. Callbacks registered with <a href="http://localhost:3000/#tracker_afterflush"><code>Tracker.afterFlush</code></a> are called after processing outstanding invalidations.</p>
<p>It is illegal to call <code>flush</code> from inside a <code>flush</code> or from a running computation.</p>
<p>The <a href="http://manual.meteor.com/#tracker-theflushcycle">Meteor Manual</a> describes the motivation for the flush cycle and the guarantees made by <code>Tracker.flush</code> and <code>Tracker.afterFlush</code>.</p>
<div class="api new-api-box">
<h3 id="tracker_nonreactive" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/tracker_nonreactive">Tracker.nonreactive(func)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Run a function without tracking dependencies.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">func</span> <span class="type">Function</span></dt>
<dd>
<p>A function to call immediately.</p>
</dd>
</dl>
</div>
<p>Calls <code>func</code> with <code>Tracker.currentComputation</code> temporarily set to <code>null</code> and returns <code>func</code>'s own return value. If <code>func</code> accesses reactive data sources, these data sources will never cause a rerun of the enclosing computation.</p>
<div class="api new-api-box">
<h3 id="tracker_active" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/tracker_active">Tracker.active</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>True if there is a current computation, meaning that dependencies on reactive data sources will be tracked and potentially cause the current computation to be rerun.</p>
</div>
</div>
<p>This value is useful for data source implementations to determine whether they are being accessed reactively or not.</p>
<div class="api new-api-box">
<h3 id="tracker_currentcomputation" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/tracker_currentcomputation">Tracker.currentComputation</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>The current computation, or <code>null</code> if there isn't one. The current computation is the <a href="http://localhost:3000/#tracker_computation"><code>Tracker.Computation</code></a> object created by the innermost active call to <code>Tracker.autorun</code>, and it's the computation that gains dependencies when reactive data sources are accessed.</p>
</div>
</div>
<p>It's very rare to need to access <code>currentComputation</code> directly. The current computation is used implicitly by <a href="http://localhost:3000/#tracker_active"><code>Tracker.active</code></a> (which tests whether there is one), <a href="http://localhost:3000/#dependency_depend"><code>dependency.depend()</code></a> (which registers that it depends on a dependency), and <a href="http://localhost:3000/#tracker_oninvalidate"><code>Tracker.onInvalidate</code></a> (which registers a callback with it).</p>
<div class="api new-api-box">
<h3 id="tracker_oninvalidate" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/tracker_oninvalidate">Tracker.onInvalidate(callback)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Registers a new <a href="http://localhost:3000/#computation_oninvalidate"><code>onInvalidate</code></a> callback on the current computation (which must exist), to be called immediately when the current computation is invalidated or stopped.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>A callback function that will be invoked as <code>func(c)</code>, where <code>c</code> is the computation on which the callback is registered.</p>
</dd>
</dl>
</div>
<p>See <a href="http://localhost:3000/#computation_oninvalidate"><em><code>computation</code></em><code>.onInvalidate</code></a> for more details.</p>
<div class="api new-api-box">
<h3 id="tracker_afterflush" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/tracker_afterflush">Tracker.afterFlush(callback)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Schedules a function to be called during the next flush, or later in the current flush if one is in progress, after all invalidated computations have been rerun. The function will be run once and not on subsequent flushes unless <code>afterFlush</code> is called again.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>A function to call at flush time.</p>
</dd>
</dl>
</div>
<p>Functions scheduled by multiple calls to <code>afterFlush</code> are guaranteed to run in the order that <code>afterFlush</code> was called. Functions are guaranteed to be called at a time when there are no invalidated computations that need rerunning. This means that if an <code>afterFlush</code> function invalidates a computation, that computation will be rerun before any other <code>afterFlush</code> functions are called.</p>
<h2 id="tracker_computation">Tracker.Computation</h2>
<p>A Computation object represents code that is repeatedly rerun in response to reactive data changes. Computations don't have return values; they just perform actions, such as rerendering a template on the screen. Computations are created using <a href="http://localhost:3000/#tracker_autorun"><code>Tracker.autorun</code></a>. Use <a href="http://localhost:3000/#computation_stop"><code>stop</code></a> to prevent further rerunning of a computation.</p>
<p>Each time a computation runs, it may access various reactive data sources that serve as inputs to the computation, which are called its dependencies. At some future time, one of these dependencies may trigger the computation to be rerun by invalidating it. When this happens, the dependencies are cleared, and the computation is scheduled to be rerun at flush time.</p>
<p>The <em>current computation</em> (<a href="http://localhost:3000/#tracker_currentcomputation"><code>Tracker.currentComputation</code></a>) is the computation that is currently being run or rerun (computed), and the one that gains a dependency when a reactive data source is accessed. Data sources are responsible for tracking these dependencies using <a href="http://localhost:3000/#tracker_dependency"><code>Tracker.Dependency</code></a> objects.</p>
<p>Invalidating a computation sets its <code>invalidated</code> property to true and immediately calls all of the computation's <code>onInvalidate</code> callbacks. When a flush occurs, if the computation has been invalidated and not stopped, then the computation is rerun by setting the <code>invalidated</code> property to <code>false</code> and calling the original function that was passed to <code>Tracker.autorun</code>. A flush will occur when the current code finishes running, or sooner if <code>Tracker.flush</code> is called.</p>
<p>Stopping a computation invalidates it (if it is valid) for the purpose of calling callbacks, but ensures that it will never be rerun.</p>
<p>Example:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// if we're in a computation, then perform some clean-up</span>
<span class="hljs-comment">// when the current computation is invalidated (rerun or</span>
<span class="hljs-comment">// stopped)</span>
<span class="hljs-keyword">if</span> (Tracker.active) {
  Tracker.onInvalidate(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    x.destroy();
    y.finalize();
  });
}
</code></pre>
<div class="api new-api-box">
<h3 id="computation_stop" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/computation_stop"><em>computation</em>.stop()</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Prevents this computation from rerunning.</p>
</div>
</div>
<p>Stopping a computation is irreversible and guarantees that it will never be rerun. You can stop a computation at any time, including from the computation's own run function. Stopping a computation that is already stopped has no effect.</p>
<p>Stopping a computation causes its <code>onInvalidate</code> callbacks to run immediately if it is not currently invalidated.</p>
<p>Nested computations are stopped automatically when their enclosing computation is rerun.</p>
<div class="api new-api-box">
<h3 id="computation_invalidate" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/computation_invalidate"><em>computation</em>.invalidate()</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Invalidates this computation so that it will be rerun.</p>
</div>
</div>
<p>Invalidating a computation marks it to be rerun at <a href="http://localhost:3000/#tracker_flush">flush time</a>, at which point the computation becomes valid again. It is rare to invalidate a computation manually, because reactive data sources invalidate their calling computations when they change. Reactive data sources in turn perform this invalidation using one or more <a href="http://localhost:3000/#tracker_dependency"><code>Tracker.Dependency</code></a> objects.</p>
<p>Invalidating a computation immediately calls all <code>onInvalidate</code> callbacks registered on it. Invalidating a computation that is currently invalidated or is stopped has no effect. A computation can invalidate itself, but if it continues to do so indefinitely, the result will be an infinite loop.</p>
<div class="api new-api-box">
<h3 id="computation_oninvalidate" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/computation_oninvalidate"><em>computation</em>.onInvalidate(callback)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Registers <code>callback</code> to run when this computation is next invalidated, or runs it immediately if the computation is already invalidated. The callback is run exactly once and not upon future invalidations unless <code>onInvalidate</code> is called again after the computation becomes valid again.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">callback</span> <span class="type">Function</span></dt>
<dd>
<p>Function to be called on invalidation. Receives one argument, the computation that was invalidated.</p>
</dd>
</dl>
</div>
<p><code>onInvalidate</code> registers a one-time callback that either fires immediately or as soon as the computation is next invalidated or stopped. It is used by reactive data sources to clean up resources or break dependencies when a computation is rerun or stopped.</p>
<p>To get a callback after a computation has been recomputed, you can call <a href="http://localhost:3000/#tracker_afterflush"><code>Tracker.afterFlush</code></a> from <code>onInvalidate</code>.</p>
<div class="api new-api-box">
<h3 id="computation_stopped" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/computation_stopped"><em>computation</em>.stopped</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>True if this computation has been stopped.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="computation_invalidated" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/computation_invalidated"><em>computation</em>.invalidated</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>True if this computation has been invalidated (and not yet rerun), or if it has been stopped.</p>
</div>
</div>
<p>This property is initially false. It is set to true by <code>stop()</code> and <code>invalidate()</code>. It is reset to false when the computation is recomputed at flush time.</p>
<div class="api new-api-box">
<h3 id="computation_firstrun" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/computation_firstrun"><em>computation</em>.firstRun</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>True during the initial run of the computation at the time <code>Tracker.autorun</code> is called, and false on subsequent reruns and at other times.</p>
</div>
</div>
<p>This property is a convenience to support the common pattern where a computation has logic specific to the first run.</p>
<h2 id="tracker_dependency">Tracker.Dependency</h2>
<p>A Dependency represents an atomic unit of reactive data that a computation might depend on. Reactive data sources such as Session or Minimongo internally create different Dependency objects for different pieces of data, each of which may be depended on by multiple computations. When the data changes, the computations are invalidated.</p>
<p>Dependencies don't store data, they just track the set of computations to invalidate if something changes. Typically, a data value will be accompanied by a Dependency object that tracks the computations that depend on it, as in this example:</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> weather = <span class="hljs-string">"sunny"</span>;
<span class="hljs-keyword">var</span> weatherDep = <span class="hljs-keyword">new</span> Tracker.Dependency;

<span class="hljs-keyword">var</span> getWeather = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  weatherDep.depend()
  <span class="hljs-keyword">return</span> weather;
};

<span class="hljs-keyword">var</span> setWeather = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(w)</span> </span>{
  weather = w;
  <span class="hljs-comment">// (could add logic here to only call changed()</span>
  <span class="hljs-comment">// if the new value is different from the old)</span>
  weatherDep.changed();
};
</code></pre>
<p>This example implements a weather data source with a simple getter and setter. The getter records that the current computation depends on the <code>weatherDep</code> dependency using <code>depend()</code>, while the setter signals the dependency to invalidate all dependent computations by calling <code>changed()</code>.</p>
<p>The reason Dependencies do not store data themselves is that it can be useful to associate multiple Dependencies with the same piece of data. For example, one Dependency might represent the result of a database query, while another might represent just the number of documents in the result. A Dependency could represent whether the weather is sunny or not, or whether the temperature is above freezing. <a href="http://localhost:3000/#session_equals"><code>Session.equals</code></a> is implemented this way for efficiency. When you call <code>Session.equals("weather", "sunny")</code>, the current computation is made to depend on an internal Dependency that does not change if the weather goes from, say, "rainy" to "cloudy".</p>
<p>Conceptually, the only two things a Dependency can do are gain a dependent and change.</p>
<p>A Dependency's dependent computations are always valid (they have <code>invalidated === false</code>). If a dependent is invalidated at any time, either by the Dependency itself or some other way, it is immediately removed.</p>
<p>See the <a href="http://manual.meteor.com/#tracker-reactivevaluewithdependency"> Meteor Manual</a> to learn how to create a reactive data source using Tracker.Dependency.</p>
<div class="api new-api-box">
<h3 id="dependency_changed" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/dependency_changed"><em>dependency</em>.changed()</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Invalidate all dependent computations immediately and remove them as dependents.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="dependency_depend" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/dependency_depend"><em>dependency</em>.depend([fromComputation])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Declares that the current computation (or <code>fromComputation</code> if given) depends on <code>dependency</code>. The computation will be invalidated the next time <code>dependency</code> changes.</p>
<p>If there is no current computation and <code>depend()</code> is called with no arguments, it does nothing and returns false.</p>
<p>Returns true if the computation is a new dependent of <code>dependency</code> rather than an existing one.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">fromComputation</span> <span class="type"><a href="http://localhost:3000/#tracker_computation">Tracker.Computation</a></span></dt>
<dd>
<p>An optional computation declared to depend on <code>dependency</code> instead of the current computation.</p>
</dd>
</dl>
</div>
<p><code>dep.depend()</code> is used in reactive data source implementations to record the fact that <code>dep</code> is being accessed from the current computation.</p>
<div class="api new-api-box">
<h3 id="dependency_hasdependents" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/dependency_hasdependents"><em>dependency</em>.hasDependents()</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>True if this Dependency has one or more dependent Computations, which would be invalidated if this Dependency were to change.</p>
</div>
</div>
<p>For reactive data sources that create many internal Dependencies, this function is useful to determine whether a particular Dependency is still tracking any dependency relationships or if it can be cleaned up to save memory.</p>
<h2 id="reactivevar_pkg">ReactiveVar</h2>
<p>To use <code>ReactiveVar</code>, add the <code>reactive-var</code> package to your project with <code>$ meteor add reactive-var</code>.</p>
<div class="api new-api-box">
<h3 id="reactivevar" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/reactivevar">new ReactiveVar(initialValue, [equalsFunc])</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Constructor for a ReactiveVar, which represents a single reactive variable.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">initialValue</span> <span class="type">Any</span></dt>
<dd>
<p>The initial value to set. <code>equalsFunc</code> is ignored when setting the initial value.</p>
</dd>
<dt><span class="name">equalsFunc</span> <span class="type">Function</span></dt>
<dd>
<p>Optional. A function of two arguments, called on the old value and the new value whenever the ReactiveVar is set. If it returns true, no set is performed. If omitted, the default <code>equalsFunc</code> returns true if its arguments are <code>===</code> and are of type number, boolean, string, undefined, or null.</p>
</dd>
</dl>
</div>
<p>A ReactiveVar holds a single value that can be get and set, such that calling <code>set</code> will invalidate any Computations that called <code>get</code>, according to the usual contract for reactive data sources.</p>
<p>A ReactiveVar is similar to a Session variable, with a few differences:</p>
<ul>
<li>
<p>ReactiveVars don't have global names, like the "foo" in <code>Session.get("foo")</code>. Instead, they may be created and used locally, for example attached to a template instance, as in: <code>this.foo.get()</code>.</p>
</li>
<li>
<p>ReactiveVars are not automatically migrated across hot code pushes, whereas Session state is.</p>
</li>
<li>
<p>ReactiveVars can hold any value, while Session variables are limited to JSON or EJSON.</p>
</li>
</ul>
<p>An important property of ReactiveVars &mdash; which is sometimes a reason for using one &mdash; is that setting the value to the same value as before has no effect; it does not trigger any invalidations. So if one autorun sets a ReactiveVar, and another autorun gets the ReactiveVar, a re-run of the first autorun won't necessarily trigger the second. By default, only primitive values are compared this way, while calling <code>set</code> on an argument that is an <em>object</em> (not a primitive) always counts as a change. You can configure this behavior using the <code>equalsFunc</code> argument.</p>
<div class="api new-api-box">
<h3 id="reactivevar_get" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/reactivevar_get"><em>reactiveVar</em>.get()</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Returns the current value of the ReactiveVar, establishing a reactive dependency.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="reactivevar_set" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/reactivevar_set"><em>reactiveVar</em>.set(newValue)</a> <span class="locus">Client</span></h3>
<div class="desc">
<p>Sets the current value of the ReactiveVar, invalidating the Computations that called <code>get</code> if <code>newValue</code> is different from the old value.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">newValue</span> <span class="type">Any</span></dt>
<dd></dd>
</dl>
</div>
<h2 id="ejson">EJSON</h2>
<p>EJSON is an extension of JSON to support more types. It supports all JSON-safe types, as well as:</p>
<ul>
<li><strong>Date</strong> (JavaScript <code>Date</code>)</li>
<li><strong>Binary</strong> (JavaScript <code>Uint8Array</code> or the result of <a href="http://localhost:3000/#ejson_new_binary"><code>EJSON.newBinary</code></a>)</li>
<li><strong>User-defined types</strong> (see <a href="http://localhost:3000/#ejson_add_type"><code>EJSON.addType</code></a>. For example, <a href="http://localhost:3000/#mongo_object_id"><code>Mongo.ObjectID</code></a> is implemented this way.)</li>
</ul>
<p>All EJSON serializations are also valid JSON. For example an object with a date and a binary buffer would be serialized in EJSON as:</p>
<pre><code class="hljs json">{
  "<span class="hljs-attribute">d</span>": <span class="hljs-value">{"<span class="hljs-attribute">$date</span>": <span class="hljs-number">1358205756553</span>}</span>,
  "<span class="hljs-attribute">b</span>": <span class="hljs-value">{"<span class="hljs-attribute">$binary</span>": <span class="hljs-string">"c3VyZS4="</span>}
</span>}
</code></pre>
<p>Meteor supports all built-in EJSON data types in publishers, method arguments and results, Mongo databases, and <a href="http://localhost:3000/#session"><code>Session</code></a> variables.</p>
<div class="api new-api-box">
<h3 id="ejson_parse" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/ejson_parse">EJSON.parse(str)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Parse a string into an EJSON value. Throws an error if the string is not valid EJSON.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">str</span> <span class="type">String</span></dt>
<dd>
<p>A string to parse into an EJSON value.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="ejson_stringify" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/ejson_stringify">EJSON.stringify(val, [options])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Serialize a value to a string.</p>
<p>For EJSON values, the serialization fully represents the value. For non-EJSON values, serializes the same way as <code>JSON.stringify</code>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">val</span> <span class="type"><a href="http://localhost:3000/#ejson">EJSON-able Object</a></span></dt>
<dd>
<p>A value to stringify.</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">indent</span> <span class="type">Boolean, Integer, or String</span></dt>
<dd>
<p>Indents objects and arrays for easy readability. When <code>true</code>, indents by 2 spaces; when an integer, indents by that number of spaces; and when a string, uses the string as the indentation pattern.</p>
</dd>
<dt><span class="name">canonical</span> <span class="type">Boolean</span></dt>
<dd>
<p>When <code>true</code>, stringifies keys in an object in sorted order.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="ejson_from_json_value" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/ejson_from_json_value">EJSON.fromJSONValue(val)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Deserialize an EJSON value from its plain JSON representation.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">val</span> <span class="type">JSON-compatible Object</span></dt>
<dd>
<p>A value to deserialize into EJSON.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="ejson_to_json_value" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/ejson_to_json_value">EJSON.toJSONValue(val)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Serialize an EJSON-compatible value into its plain JSON representation.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">val</span> <span class="type"><a href="http://localhost:3000/#ejson">EJSON-able Object</a></span></dt>
<dd>
<p>A value to serialize to plain JSON.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="ejson_equals" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/ejson_equals">EJSON.equals(a, b, [options])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Return true if <code>a</code> and <code>b</code> are equal to each other. Return false otherwise. Uses the <code>equals</code> method on <code>a</code> if present, otherwise performs a deep comparison.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">a</span> <span class="type"><a href="http://localhost:3000/#ejson">EJSON-able Object</a></span></dt>
<dd></dd>
<dt><span class="name">b</span> <span class="type"><a href="http://localhost:3000/#ejson">EJSON-able Object</a></span></dt>
<dd></dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">keyOrderSensitive</span> <span class="type">Boolean</span></dt>
<dd>
<p>Compare in key sensitive order, if supported by the JavaScript implementation. For example, <code>{a: 1, b: 2}</code> is equal to <code>{b: 2, a: 1}</code> only when <code>keyOrderSensitive</code> is <code>false</code>. The default is <code>false</code>.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="ejson_clone" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/ejson_clone">EJSON.clone(val)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Return a deep copy of <code>val</code>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">val</span> <span class="type"><a href="http://localhost:3000/#ejson">EJSON-able Object</a></span></dt>
<dd>
<p>A value to copy.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="ejson_new_binary" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/ejson_new_binary">EJSON.newBinary</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Allocate a new buffer of binary data that EJSON can serialize.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">size</span> <span class="type">Number</span></dt>
<dd>
<p>The number of bytes of binary data to allocate.</p>
</dd>
</dl>
</div>
<p>Buffers of binary data are represented by <code>Uint8Array</code> instances on JavaScript platforms that support them. On implementations of JavaScript that do not support <code>Uint8Array</code>, binary data buffers are represented by standard arrays containing numbers ranging from 0 to 255, and the <code>$Uint8ArrayPolyfill</code> key set to <code>true</code>.</p>
<div class="api new-api-box">
<h3 id="ejson_is_binary" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/ejson_is_binary">EJSON.isBinary(x)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Returns true if <code>x</code> is a buffer of binary data, as returned from <a href="http://localhost:3000/#ejson_new_binary"><code>EJSON.newBinary</code></a>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">x</span> <span class="type">Object</span></dt>
<dd>
<p>The variable to check.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="ejson_add_type" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/ejson_add_type">EJSON.addType(name, factory)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Add a custom datatype to EJSON.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">name</span> <span class="type">String</span></dt>
<dd>
<p>A tag for your custom type; must be unique among custom data types defined in your project, and must match the result of your type's <code>typeName</code> method.</p>
</dd>
<dt><span class="name">factory</span> <span class="type">Function</span></dt>
<dd>
<p>A function that deserializes a JSON-compatible value into an instance of your type. This should match the serialization performed by your type's <code>toJSONValue</code> method.</p>
</dd>
</dl>
</div>
<p>When you add a type to EJSON, Meteor will be able to use that type in:</p>
<ul>
<li>publishing objects of your type if you pass them to publish handlers.</li>
<li>allowing your type in the return values or arguments to <a href="http://localhost:3000/#methods_header">methods</a>.</li>
<li>storing your type client-side in Minimongo.</li>
<li>allowing your type in <a href="http://localhost:3000/#session"><code>Session</code></a> variables.</li>
</ul>
<p>Instances of your type must implement <a href="http://localhost:3000/#ejson_type_typeName"><code>typeName</code></a> and <a href="http://localhost:3000/#ejson_type_toJSONValue"><code>toJSONValue</code></a> methods, and may implement <a href="http://localhost:3000/#ejson_type_clone"><code>clone</code></a> and <a href="http://localhost:3000/#ejson_type_equals"><code>equals</code></a> methods if the default implementations are not sufficient.</p>
<div class="api new-api-box">
<h3 id="ejson_type_typeName" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/ejson_type_typeName"><em>customType</em>.typeName()</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Return the tag used to identify this type. This must match the tag used to register this type with <a href="http://localhost:3000/#ejson_add_type"><code>EJSON.addType</code></a>.</p>
</div>
</div>
<div class="api new-api-box">
<h3 id="ejson_type_toJSONValue" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/ejson_type_toJSONValue"><em>customType</em>.toJSONValue()</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Serialize this instance into a JSON-compatible value.</p>
</div>
</div>
<p>For example, the <code>toJSONValue</code> method for <a href="http://localhost:3000/#mongo_object_id"><code>Mongo.ObjectID</code></a> could be:</p>
<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toHexString();
};
</code></pre>
<div class="api new-api-box">
<h3 id="ejson_type_clone" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/ejson_type_clone"><em>customType</em>.clone()</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Return a value <code>r</code> such that <code>this.equals(r)</code> is true, and modifications to <code>r</code> do not affect <code>this</code> and vice versa.</p>
</div>
</div>
<p>If your type does not have a <code>clone</code> method, <code>EJSON.clone</code> will use <a href="http://localhost:3000/#ejson_type_toJSONValue"><code>toJSONValue</code></a> and the factory instead.</p>
<div class="api new-api-box">
<h3 id="ejson_type_equals" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/ejson_type_equals"><em>customType</em>.equals(other)</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Return <code>true</code> if <code>other</code> has a value equal to <code>this</code>; <code>false</code> otherwise.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">other</span> <span class="type">Object</span></dt>
<dd>
<p>Another object to compare this to.</p>
</dd>
</dl>
</div>
<p>The <code>equals</code> method should define an <a href="http://en.wikipedia.org/wiki/Equivalence_relation">equivalence relation</a>. It should have the following properties:</p>
<ul>
<li><em>Reflexivity</em> - for any instance <code>a</code>: <code>a.equals(a)</code> must be true.</li>
<li><em>Symmetry</em> - for any two instances <code>a</code> and <code>b</code>: <code>a.equals(b)</code> if and only if <code>b.equals(a)</code>.</li>
<li><em>Transitivity</em> - for any three instances <code>a</code>, <code>b</code>, and <code>c</code>: <code>a.equals(b)</code> and <code>b.equals(c)</code> implies <code>a.equals(c)</code>.</li>
</ul>
<p>If your type does not have an <code>equals</code> method, <code>EJSON.equals</code> will compare the result of calling <a href="http://localhost:3000/#ejson_type_toJSONValue"><code>toJSONValue</code></a> instead.</p>
<h2 id="http">HTTP</h2>
<p><code>HTTP</code> provides an HTTP request API on the client and server. To use these functions, add the HTTP package to your project with <code>$ meteor add http</code>.</p>
<div class="api new-api-box">
<h3 id="http_call" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/http_call">HTTP.call(method, url, [options], [asyncCallback])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Perform an outbound HTTP request.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">method</span> <span class="type">String</span></dt>
<dd>
<p>The <a href="http://en.wikipedia.org/wiki/HTTP_method">HTTP method</a> to use, such as "<code>GET</code>", "<code>POST</code>", or "<code>HEAD</code>".</p>
</dd>
<dt><span class="name">url</span> <span class="type">String</span></dt>
<dd>
<p>The URL to retrieve.</p>
</dd>
<dt><span class="name">asyncCallback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional callback. If passed, the method runs asynchronously, instead of synchronously, and calls asyncCallback. On the client, this callback is required.</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">content</span> <span class="type">String</span></dt>
<dd>
<p>String to use as the HTTP request body.</p>
</dd>
<dt><span class="name">data</span> <span class="type">Object</span></dt>
<dd>
<p>JSON-able object to stringify and use as the HTTP request body. Overwrites <code>content</code>.</p>
</dd>
<dt><span class="name">query</span> <span class="type">String</span></dt>
<dd>
<p>Query string to go in the URL. Overwrites any query string in <code>url</code>.</p>
</dd>
<dt><span class="name">params</span> <span class="type">Object</span></dt>
<dd>
<p>Dictionary of request parameters to be encoded and placed in the URL (for GETs) or request body (for POSTs). If <code>content</code> or <code>data</code> is specified, <code>params</code> will always be placed in the URL.</p>
</dd>
<dt><span class="name">auth</span> <span class="type">String</span></dt>
<dd>
<p>HTTP basic authentication string of the form <code>"username:password"</code></p>
</dd>
<dt><span class="name">headers</span> <span class="type">Object</span></dt>
<dd>
<p>Dictionary of strings, headers to add to the HTTP request.</p>
</dd>
<dt><span class="name">timeout</span> <span class="type">Number</span></dt>
<dd>
<p>Maximum time in milliseconds to wait for the request before failing. There is no timeout by default.</p>
</dd>
<dt><span class="name">followRedirects</span> <span class="type">Boolean</span></dt>
<dd>
<p>If <code>true</code>, transparently follow HTTP redirects. Cannot be set to <code>false</code> on the client. Default <code>true</code>.</p>
</dd>
<dt><span class="name">npmRequestOptions</span> <span class="type">Object</span></dt>
<dd>
<p>On the server, <code>HTTP.call</code> is implemented by using the <a href="https://www.npmjs.com/package/request">npm <code>request</code> module</a>. Any options in this object will be passed directly to the <code>request</code> invocation.</p>
</dd>
</dl>
</div>
<p>This function initiates an HTTP request to a remote server.</p>
<p>On the server, this function can be run either synchronously or asynchronously. If the callback is omitted, it runs synchronously and the results are returned once the request completes successfully. If the request was not successful, an error is thrown. This is useful when making server-to-server HTTP API calls from within Meteor methods, as the method can succeed or fail based on the results of the synchronous HTTP call. In this case, consider using <a href="http://localhost:3000/#method_unblock"><code>this.unblock()</code></a> to allow other methods on the same connection to run in the mean time. On the client, this function must be used asynchronously by passing a callback.</p>
<p>Both HTTP and HTTPS protocols are supported. The <code>url</code> argument must be an absolute URL including protocol and host name on the server, but may be relative to the current host on the client. The <code>query</code> option replaces the query string of <code>url</code>. Parameters specified in <code>params</code> that are put in the URL are appended to any query string. For example, with a <code>url</code> of <code>"/path?query"</code> and <code>params</code> of <code>{foo:"bar"}</code>, the final URL will be <code>"/path?query&amp;foo=bar"</code>.</p>
<p>The <code>params</code> are put in the URL or the request body, depending on the type of request. In the case of request with no bodies, like GET and HEAD, the parameters will always go in the URL. For a POST or other type of request, the parameters will be encoded into the body with a standard <code>x-www-form-urlencoded</code> content type, unless the <code>content</code> or <code>data</code> option is used to specify a body, in which case the parameters will be appended to the URL instead.</p>
<p>When run in asynchronous mode, the callback receives two arguments, <code>error</code> and <code>result</code>. The <code>error</code> argument will contain an Error if the request fails in any way, including a network error, time-out, or an HTTP status code in the 400 or 500 range. In case of a 4xx/5xx HTTP status code, the <code>response</code> property on <code>error</code> matches the contents of the result object. When run in synchronous mode, either <code>result</code> is returned from the function, or <code>error</code> is thrown.</p>
<p>Contents of the result object:</p>
<dl class="objdesc">
<dt><span class="name">statusCode</span> <span class="type">Number</span></dt>
<dd>Numeric HTTP result status code, or <code>null</code> on error.</dd>
<dt><span class="name">content</span> <span class="type">String</span></dt>
<dd>The body of the HTTP response as a string.</dd>
<dt><span class="name">data</span> <span class="type">Object or <code>null</code></span></dt>
<dd>If the response headers indicate JSON content, this contains the body of the document parsed as a JSON object.</dd>
<dt><span class="name">headers</span> <span class="type">Object</span></dt>
<dd>A dictionary of HTTP headers from the response.</dd>
</dl>
<p>Example server method:</p>
<pre><code class="hljs javascript">Meteor.methods({checkTwitter: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(userId)</span> </span>{
  check(userId, <span class="hljs-built_in">String</span>);
  <span class="hljs-keyword">this</span>.unblock();
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">var</span> result = HTTP.call(<span class="hljs-string">"GET"</span>, <span class="hljs-string">"http://api.twitter.com/xyz"</span>,
                           {params: {user: userId}});
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-comment">// Got a network error, time-out or HTTP error in the 400 or 500 range.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
}});
</code></pre>
<p>Example asynchronous HTTP call:</p>
<pre><code class="hljs javascript">HTTP.call(<span class="hljs-string">"POST"</span>, <span class="hljs-string">"http://api.twitter.com/xyz"</span>,
          {data: {some: <span class="hljs-string">"json"</span>, stuff: <span class="hljs-number">1</span>}},
          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error, result)</span> </span>{
            <span class="hljs-keyword">if</span> (!error) {
              Session.set(<span class="hljs-string">"twizzled"</span>, <span class="hljs-literal">true</span>);
            }
          });
</code></pre>
<div class="api new-api-box">
<h3 id="http_get" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/http_get">HTTP.get(url, [callOptions], [asyncCallback])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Send an HTTP <code>GET</code> request. Equivalent to calling <a href="http://localhost:3000/#http_call"><code>HTTP.call</code></a> with "GET" as the first argument.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">url</span> <span class="type">String</span></dt>
<dd>
<p>The URL to which the request should be sent.</p>
</dd>
<dt><span class="name">callOptions</span> <span class="type">Object</span></dt>
<dd>
<p>Options passed on to <a href="http://localhost:3000/#http_call"><code>HTTP.call</code></a>.</p>
</dd>
<dt><span class="name">asyncCallback</span> <span class="type">Function</span></dt>
<dd>
<p>Callback that is called when the request is completed. Required on the client.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="http_post" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/http_post">HTTP.post(url, [callOptions], [asyncCallback])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Send an HTTP <code>POST</code> request. Equivalent to calling <a href="http://localhost:3000/#http_call"><code>HTTP.call</code></a> with "POST" as the first argument.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">url</span> <span class="type">String</span></dt>
<dd>
<p>The URL to which the request should be sent.</p>
</dd>
<dt><span class="name">callOptions</span> <span class="type">Object</span></dt>
<dd>
<p>Options passed on to <a href="http://localhost:3000/#http_call"><code>HTTP.call</code></a>.</p>
</dd>
<dt><span class="name">asyncCallback</span> <span class="type">Function</span></dt>
<dd>
<p>Callback that is called when the request is completed. Required on the client.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="http_put" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/http_put">HTTP.put(url, [callOptions], [asyncCallback])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Send an HTTP <code>PUT</code> request. Equivalent to calling <a href="http://localhost:3000/#http_call"><code>HTTP.call</code></a> with "PUT" as the first argument.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">url</span> <span class="type">String</span></dt>
<dd>
<p>The URL to which the request should be sent.</p>
</dd>
<dt><span class="name">callOptions</span> <span class="type">Object</span></dt>
<dd>
<p>Options passed on to <a href="http://localhost:3000/#http_call"><code>HTTP.call</code></a>.</p>
</dd>
<dt><span class="name">asyncCallback</span> <span class="type">Function</span></dt>
<dd>
<p>Callback that is called when the request is completed. Required on the client.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="http_del" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/http_del">HTTP.del(url, [callOptions], [asyncCallback])</a> <span class="locus">Anywhere</span></h3>
<div class="desc">
<p>Send an HTTP <code>DELETE</code> request. Equivalent to calling <a href="http://localhost:3000/#http_call"><code>HTTP.call</code></a> with "DELETE" as the first argument. (Named <code>del</code> to avoid conflic with the Javascript keyword <code>delete</code>)</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">url</span> <span class="type">String</span></dt>
<dd>
<p>The URL to which the request should be sent.</p>
</dd>
<dt><span class="name">callOptions</span> <span class="type">Object</span></dt>
<dd>
<p>Options passed on to <a href="http://localhost:3000/#http_call"><code>HTTP.call</code></a>.</p>
</dd>
<dt><span class="name">asyncCallback</span> <span class="type">Function</span></dt>
<dd>
<p>Callback that is called when the request is completed. Required on the client.</p>
</dd>
</dl>
</div>
<h2 id="email">Email</h2>
<p>The <code>email</code> package allows sending email from a Meteor app. To use it, add the package to your project with <code>$ meteor add email</code>.</p>
<p>The server reads from the <code>MAIL_URL</code> environment variable to determine how to send mail. Currently, Meteor supports sending mail over SMTP; the <code>MAIL_URL</code> environment variable should be of the form <code>smtp://USERNAME:PASSWORD@HOST:PORT/</code>. For apps deployed with <code>meteor deploy</code>, <code>MAIL_URL</code> defaults to an account (provided by <a href="http://www.mailgun.com/">Mailgun</a>) which allows apps to send up to 200 emails per day; you may override this default by assigning to <code>process.env.MAIL_URL</code> before your first call to <code>Email.send</code>.</p>
<p>If <code>MAIL_URL</code> is not set (eg, when running your application locally), <code>Email.send</code> outputs the message to standard output instead.</p>
<div class="api new-api-box">
<h3 id="email_send" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/email_send">Email.send(options)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Send an email. Throws an <code>Error</code> on failure to contact mail server or if mail server returns an error. All fields should match <a href="http://tools.ietf.org/html/rfc5322">RFC5322</a> specification.</p>
</div>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">from</span> <span class="type">String</span></dt>
<dd>
<p>"From:" address (required)</p>
</dd>
<dt><span class="name">to, cc, bcc, replyTo</span> <span class="type">String or Array of Strings</span></dt>
<dd>
<p>"To:", "Cc:", "Bcc:", and "Reply-To:" addresses</p>
</dd>
<dt><span class="name">subject</span> <span class="type">String</span></dt>
<dd>
<p>"Subject:" line</p>
</dd>
<dt><span class="name">text, html</span> <span class="type">String</span></dt>
<dd>
<p>Mail body (in plain text and/or HTML)</p>
</dd>
<dt><span class="name">headers</span> <span class="type">Object</span></dt>
<dd>
<p>Dictionary of custom headers</p>
</dd>
</dl>
</div>
<p>You must provide the <code>from</code> option and at least one of <code>to</code>, <code>cc</code>, and <code>bcc</code>; all other options are optional.</p>
<p><code>Email.send</code> only works on the server. Here is an example of how a client could use a server method call to send an email. (In an actual application, you'd need to be careful to limit the emails that a client could send, to prevent your server from being used as a relay by spammers.)</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// In your server code: define a method that the client can call</span>
Meteor.methods({
  sendEmail: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(to, from, subject, text)</span> </span>{
    check([to, from, subject, text], [<span class="hljs-built_in">String</span>]);

    <span class="hljs-comment">// Let other method calls from the same client start running,</span>
    <span class="hljs-comment">// without waiting for the email sending to complete.</span>
    <span class="hljs-keyword">this</span>.unblock();

    Email.send({
      to: to,
      from: from,
      subject: subject,
      text: text
    });
  }
});

<span class="hljs-comment">// In your client code: asynchronously send an email</span>
Meteor.call(<span class="hljs-string">'sendEmail'</span>,
            <span class="hljs-string">'alice@example.com'</span>,
            <span class="hljs-string">'bob@example.com'</span>,
            <span class="hljs-string">'Hello from Meteor!'</span>,
            <span class="hljs-string">'This is a test of Email.send.'</span>);
</code></pre>
<h2 id="assets">Assets</h2>
<p><code>Assets</code> allows server code in a Meteor application to access static server assets, which are located in the <code>private</code> subdirectory of an application's tree. Assets are not processed as source files and are copied directly into your application's bundle.</p>
<div class="api new-api-box">
<h3 id="assets_getText" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/assets_getText">Assets.getText(assetPath, [asyncCallback])</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Retrieve the contents of the static server asset as a UTF8-encoded string.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">assetPath</span> <span class="type">String</span></dt>
<dd>
<p>The path of the asset, relative to the application's <code>private</code> subdirectory.</p>
</dd>
<dt><span class="name">asyncCallback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional callback, which is called asynchronously with the error or result after the function is complete. If not provided, the function runs synchronously.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="assets_getBinary" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/assets_getBinary">Assets.getBinary(assetPath, [asyncCallback])</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Retrieve the contents of the static server asset as an <a href="http://localhost:3000/#ejson_new_binary">EJSON Binary</a>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">assetPath</span> <span class="type">String</span></dt>
<dd>
<p>The path of the asset, relative to the application's <code>private</code> subdirectory.</p>
</dd>
<dt><span class="name">asyncCallback</span> <span class="type">Function</span></dt>
<dd>
<p>Optional callback, which is called asynchronously with the error or result after the function is complete. If not provided, the function runs synchronously.</p>
</dd>
</dl>
</div>
<p>Static server assets are included by placing them in the application's <code>private</code> subdirectory. For example, if an application's <code>private</code> subdirectory includes a directory called <code>nested</code> with a file called <code>data.txt</code> inside it, then server code can read <code>data.txt</code> by running:</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> data = Assets.getText(<span class="hljs-string">'nested/data.txt'</span>);
</code></pre>
<h2 id="packagejs">Package.js</h2>
<p>A package is a directory containing a package.js file, which contains roughly three major sections: a basic description, a package definition, and a test definition. By default, the directory name is the name of the package.</p>
<p>The <code>package.js</code> file below is an example of how to use the packaging API. The rest of this section will explain the specific API commands in greater detail.</p>
<pre><code class="hljs php"><span class="hljs-comment">/* Information about this package */</span>
Package.describe({
  <span class="hljs-comment">// Short two-sentence summary.</span>
  summary: <span class="hljs-string">"What this does"</span>,
  <span class="hljs-comment">// Version number.</span>
  version: <span class="hljs-string">"1.0.0"</span>,
  <span class="hljs-comment">// Optional.  Default is package directory name.</span>
  name: <span class="hljs-string">"username:package-name"</span>,
  <span class="hljs-comment">// Optional github URL to your source repository.</span>
  git: <span class="hljs-string">"https://github.com/something/something.git"</span>,
});

<span class="hljs-comment">/* This defines your actual package */</span>
Package.onUse(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(api)</span> </span>{
  <span class="hljs-comment">// If no version is specified for an 'api.use' dependency, use the</span>
  <span class="hljs-comment">// one defined in Meteor 0.9.0.</span>
  api.versionsFrom(<span class="hljs-string">'0.9.0'</span>);
  <span class="hljs-comment">// Use Underscore package, but only on the server.</span>
  <span class="hljs-comment">// Version not specified, so it will be as of Meteor 0.9.0.</span>
  api.<span class="hljs-keyword">use</span>(<span class="hljs-string">'underscore'</span>, <span class="hljs-string">'server'</span>);
  <span class="hljs-comment">// Use iron:router package, version 1.0.0 or newer.</span>
  api.<span class="hljs-keyword">use</span>(<span class="hljs-string">'iron:router@1.0.0'</span>);
  <span class="hljs-comment">// Give users of this package access to the Templating package.</span>
  api.imply(<span class="hljs-string">'templating'</span>)
  <span class="hljs-comment">// Export the object 'Email' to packages or apps that use this package.</span>
  api.export(<span class="hljs-string">'Email'</span>, <span class="hljs-string">'server'</span>);
  <span class="hljs-comment">// Specify the source code for the package.</span>
  api.addFiles(<span class="hljs-string">'email.js'</span>, <span class="hljs-string">'server'</span>);
});

<span class="hljs-comment">/* This defines the tests for the package */</span>
Package.onTest(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(api)</span> </span>{
  <span class="hljs-comment">// Sets up a dependency on this package</span>
  api.<span class="hljs-keyword">use</span>(<span class="hljs-string">'username:package-name'</span>);
  <span class="hljs-comment">// Allows you to use the 'tinytest' framework</span>
  api.<span class="hljs-keyword">use</span>(<span class="hljs-string">'tinytest@1.0.0'</span>);
  <span class="hljs-comment">// Specify the source code for the package tests</span>
  api.addFiles(<span class="hljs-string">'email_tests.js'</span>, <span class="hljs-string">'server'</span>);
});

<span class="hljs-comment">/* This lets you use npm packages in your package*/</span>
Npm.depends({
  simplesmtp: <span class="hljs-string">"0.3.10"</span>,
  <span class="hljs-string">"stream-buffers"</span>: <span class="hljs-string">"0.2.5"</span>});
</code></pre>
<p>Build plugins are created with <a href="http://localhost:3000/#Package-registerBuildPlugin"><code>Package.registerBuildPlugin</code></a>. See the coffeescript package for an example. Build plugins are fully-fledged Meteor programs in their own right and have their own namespace, package dependencies, source files and npm requirements.</p>
<h3 id="packagedescription">Package Description</h3>
<p>Provide basic package information with <code>Package.describe(options)</code>. To publish a package, you must define <code>summary</code> and <code>version</code>.</p>
<div class="api new-api-box">
<h3 id="Package-describe" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/Package-describe">Package.describe(options)</a> <span class="locus">package.js</span></h3>
<div class="desc">
<p>Provide basic package information.</p>
</div>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">summary</span> <span class="type">String</span></dt>
<dd>
<p>A concise 1-2 sentence description of the package, required for publication.</p>
</dd>
<dt><span class="name">version</span> <span class="type">String</span></dt>
<dd>
<p>The (extended) <a href="http://www.semver.org">semver</a> version for your package. Additionally, Meteor allows a wrap number: a positive integer that follows the version number. If you are porting another package that uses semver versioning, you may want to use the original version, postfixed with <code>_wrapnumber</code>. For example, <code>1.2.3_1</code> or <code>2.4.5-rc1_4</code>. Wrap numbers sort after the original numbers: <code>1.2.3</code> &lt; <code>1.2.3_1</code> &lt; <code>1.2.3_2</code> &lt; <code>1.2.4-rc.0</code>. If no version is specified, this field defaults to <code>0.0.0</code>. If you want to publish your package to the package server, you must specify a version.</p>
</dd>
<dt><span class="name">name</span> <span class="type">String</span></dt>
<dd>
<p>Optional name override. By default, the package name comes from the name of its directory.</p>
</dd>
<dt><span class="name">git</span> <span class="type">String</span></dt>
<dd>
<p>Optional Git URL to the source repository.</p>
</dd>
<dt><span class="name">documentation</span> <span class="type">String</span></dt>
<dd>
<p>Optional Filepath to documentation. Set to 'README.md' by default. Set this to null to submit no documentation.</p>
</dd>
</dl>
</div>
<h3 id="packagedefinition">Package Definition</h3>
<p>Define dependencies and expose package methods with the <code>Package.onUse</code> handler. This section lets you define what packages your package depends on, what packages are implied by your package, and what object your package is exported to.</p>
<div class="api new-api-box">
<h3 id="pack_onUse" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/pack_onUse">Package.onUse(func)</a> <span class="locus">package.js</span></h3>
<div class="desc">
<p>Define package dependencies and expose package methods.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">func</span> <span class="type">Function</span></dt>
<dd>
<p>A function that takes in the package control <code>api</code> object, which keeps track of dependencies and exports.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="pack_versions" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/pack_versions"><em>api</em>.versionsFrom(meteorRelease)</a> <span class="locus">package.js</span></h3>
<div class="desc">
<p>Use versions of core packages from a release. Unless provided, all packages will default to the versions released along with <code>meteorRelease</code>. This will save you from having to figure out the exact versions of the core packages you want to use. For example, if the newest release of meteor is <code>METEOR@0.9.0</code> and it includes <code>jquery@1.0.0</code>, you can write <code>api.versionsFrom('METEOR@0.9.0')</code> in your package, and when you later write <code>api.use('jquery')</code>, it will be equivalent to <code>api.use('jquery@1.0.0')</code>. You may specify an array of multiple releases, in which case the default value for constraints will be the "or" of the versions from each release: <code>api.versionsFrom(['METEOR@0.9.0', 'METEOR@0.9.5'])</code> may cause <code>api.use('jquery')</code> to be interpreted as <code>api.use('jquery@1.0.0 || 2.0.0')</code>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">meteorRelease</span> <span class="type">String or Array of Strings</span></dt>
<dd>
<p>Specification of a release: track@version. Just 'version' (e.g. <code>"0.9.0"</code>) is sufficient if using the default release track <code>METEOR</code>.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="pack_use" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/pack_use"><em>api</em>.use(packageNames, [architecture], [options])</a> <span class="locus">package.js</span></h3>
<div class="desc">
<p>Depend on package <code>packagename</code>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">packageNames</span> <span class="type">String or Array of Strings</span></dt>
<dd>
<p>Packages being depended on. Package names may be suffixed with an @version tag.</p>
<p>In general, you must specify a package's version (e.g., <code>'accounts@1.0.0'</code> to use version 1.0.0 or a higher compatible version (ex: 1.0.1, 1.5.0, etc.) of the <code>accounts</code> package). If you are sourcing core packages from a Meteor release with <code>versionsFrom</code>, you may leave off version names for core packages. You may also specify constraints, such as <code>my:forms@=1.0.0</code> (this package demands <code>my:forms</code> at <code>1.0.0</code> exactly), or <code>my:forms@1.0.0 || =2.0.1</code> (<code>my:forms</code> at <code>1.x.y</code>, or exactly <code>2.0.1</code>).</p>
</dd>
<dt><span class="name">architecture</span> <span class="type">String</span></dt>
<dd>
<p>If you only use the package on the server (or the client), you can pass in the second argument (e.g., <code>'server'</code>, <code>'client'</code>, <code>'web.browser'</code>, <code>'web.cordova'</code>) to specify what architecture the package is used with.</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">weak</span> <span class="type">Boolean</span></dt>
<dd>
<p>Establish a weak dependency on a package. If package A has a weak dependency on package B, it means that including A in an app does not force B to be included too &mdash; but, if B is included or by another package, then B will load before A. You can use this to make packages that optionally integrate with or enhance other packages if those packages are present. When you weakly depend on a package you don't see its exports. You can detect if the possibly-present weakly-depended-on package is there by seeing if <code>Package.foo</code> exists, and get its exports from the same place.</p>
</dd>
<dt><span class="name">unordered</span> <span class="type">Boolean</span></dt>
<dd>
<p>It's okay to load this dependency after your package. (In general, dependencies specified by <code>api.use</code> are loaded before your package.) You can use this option to break circular dependencies.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="pack_api_imply" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/pack_api_imply"><em>api</em>.imply(packageSpecs)</a> <span class="locus">package.js</span></h3>
<div class="desc">
<p>Give users of this package access to another package (by passing in the string <code>packagename</code>) or a collection of packages (by passing in an array of strings [<code>packagename1</code>, <code>packagename2</code>]</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">packageSpecs</span> <span class="type">String or Array of Strings</span></dt>
<dd>
<p>Name of a package, or array of package names, with an optional @version component for each.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="pack_export" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/pack_export"><em>api</em>.export(exportedObject, [architecture])</a> <span class="locus">package.js</span></h3>
<div class="desc">
<p>Export package-level variables in your package. The specified variables (declared without <code>var</code> in the source code) will be available to packages that use this package.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">exportedObject</span> <span class="type">String</span></dt>
<dd>
<p>Name of the object.</p>
</dd>
<dt><span class="name">architecture</span> <span class="type">String</span></dt>
<dd>
<p>If you only want to export the object on the server (or the client), you can pass in the second argument (e.g., 'server', 'client', 'web.browser', 'web.cordova') to specify what architecture the export is used with.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="pack_addFiles" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/pack_addFiles"><em>api</em>.addFiles(filename, [architecture])</a> <span class="locus">package.js</span></h3>
<div class="desc">
<p>Specify the source code for your package.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">filename</span> <span class="type">String or Array of Strings</span></dt>
<dd>
<p>Name of the source file, or array of strings of source file names.</p>
</dd>
<dt><span class="name">architecture</span> <span class="type">String</span></dt>
<dd>
<p>If you only want to export the file on the server (or the client), you can pass in the second argument (e.g., 'server', 'client', 'web.browser', 'web.cordova') to specify what architecture the file is used with.</p>
</dd>
</dl>
</div>
<h3 id="packagetests">Unit Tests</h3>
<p>Set up your tests with the <code>Package.onTest</code> handler, which has an interface that's parallel to that of the <code>onUse</code> handler. The tests will need to depend on the package that you have just created. For example, if your package is the <code>email</code> package, you have to call <code>api.use('email')</code> in order to test the package.</p>
<p>If you used <code>meteor create</code> to set up your package, Meteor will create the required scaffolding in <code>package.js</code>, and you'll only need to add unit test code in the <code>_test.js</code> file that was created.</p>
<div class="api new-api-box">
<h3 id="Package-onTest" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/Package-onTest">Package.onTest(func)</a> <span class="locus">package.js</span></h3>
<div class="desc">
<p>Define dependencies and expose package methods for unit tests.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">func</span> <span class="type">Function</span></dt>
<dd>
<p>A function that takes in the package control 'api' object, which keeps track of dependencies and exports.</p>
</dd>
</dl>
</div>
<h3>External Packages and Plugins</h3>
<p>Meteor packages can include NPM packages and Cordova plugins by using <code>Npm.depends</code> and <code>Cordova.depends</code> in the <code>package.js</code> file.</p>
<div class="api new-api-box">
<h3 id="Npm-depends" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/Npm-depends">Npm.depends(dependencies)</a> <span class="locus">package.js</span></h3>
<div class="desc">
<p>Specify which <a href="https://www.npmjs.org/">NPM</a> packages your Meteor package depends on.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">dependencies</span> <span class="type">Object</span></dt>
<dd>
<p>An object where the keys are package names and the values are version numbers in string form. You can only depend on exact versions of NPM packages. Example:</p>
<pre class="prettyprint source lang-js"><code class="hljs javascript">Npm.depends({moment: <span class="hljs-string">"2.8.3"</span>});</code></pre>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="Npm-require" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/Npm-require">Npm.require(name)</a> <span class="locus">Server</span></h3>
<div class="desc">
<p>Require a package that was specified using <code>Npm.depends()</code>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">name</span> <span class="type">String</span></dt>
<dd>
<p>The name of the package to require.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="Cordova-depends" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/Cordova-depends">Cordova.depends(dependencies)</a> <span class="locus">package.js</span></h3>
<div class="desc">
<p>Specify which <a href="http://cordova.apache.org/">Cordova / PhoneGap</a> plugins your Meteor package depends on.</p>
<p>Plugins are installed from <a href="http://plugins.cordova.io/">plugins.cordova.io</a>, so the plugins and versions specified must exist there. Alternatively, the version can be replaced with a GitHub tarball URL as described in the <a href="https://github.com/meteor/meteor/wiki/Meteor-Cordova-Phonegap-integration#meteor-packages-with-cordovaphonegap-dependencies">Cordova / PhoneGap</a> page of the Meteor wiki on GitHub.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">dependencies</span> <span class="type">Object</span></dt>
<dd>
<p>An object where the keys are plugin names and the values are version numbers or GitHub tarball URLs in string form. Example:</p>
<pre class="prettyprint source lang-js"><code class="hljs javascript">Cordova.depends({
  <span class="hljs-string">"org.apache.cordova.camera"</span>: <span class="hljs-string">"0.3.0"</span>
});</code></pre>
<p>Alternatively, with a GitHub URL:</p>
<pre class="prettyprint source lang-js"><code class="hljs javascript">Cordova.depends({
  <span class="hljs-string">"org.apache.cordova.camera"</span>:
    <span class="hljs-string">"https://github.com/apache/cordova-plugin-camera/tarball/d84b875c"</span>
});</code></pre>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="Package-registerBuildPlugin" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/Package-registerBuildPlugin">Package.registerBuildPlugin([options])</a> <span class="locus">package.js</span></h3>
<div class="desc">
<p>Define a build plugin. A build plugin extends the build process for apps and packages that use this package. For example, the <code>coffeescript</code> package uses a build plugin to compile CoffeeScript source files into JavaScript.</p>
</div>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">name</span> <span class="type">String</span></dt>
<dd>
<p>A cosmetic name, must be unique in the package.</p>
</dd>
<dt><span class="name">use</span> <span class="type">String or Array of Strings</span></dt>
<dd>
<p>Meteor packages that this plugin uses, independent of the packages specified in <a href="http://localhost:3000/#pack_onUse">api.onUse</a>.</p>
</dd>
<dt><span class="name">sources</span> <span class="type">Array of Strings</span></dt>
<dd>
<p>The source files that make up the build plugin, independent from <a href="http://localhost:3000/#pack_addFiles">api.addFiles</a>.</p>
</dd>
<dt><span class="name">npmDependencies</span> <span class="type">Object</span></dt>
<dd>
<p>An object where the keys are NPM package names, and the keys are the version numbers of required NPM packages, just like in <a href="http://localhost:3000/#Npm-depends">Npm.depends</a>.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="Plugin-registerSourceHandler" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/Plugin-registerSourceHandler">Plugin.registerSourceHandler(fileExtension, handler)</a> <span class="locus">Build Plugin</span></h3>
<div class="desc">
<p>Inside a build plugin source file specified in <a href="http://localhost:3000/#Package-registerBuildPlugin">Package.registerBuildPlugin</a>, add a handler to compile files with a certain file extension.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">fileExtension</span> <span class="type">String</span></dt>
<dd>
<p>The file extension that this plugin should handle, without the first dot. Examples: <code>"coffee"</code>, <code>"coffee.md"</code>.</p>
</dd>
<dt><span class="name">handler</span> <span class="type">Function</span></dt>
<dd>
<p>A function that takes one argument, a CompileStep object.</p>
<p>Documentation for CompileStep is available <a href="https://github.com/meteor/meteor/wiki/CompileStep-API-for-Build-Plugin-Source-Handlers">on the GitHub Wiki</a>.</p>
</dd>
</dl>
</div>
<h2 id="mobileconfigjs">Mobile Config File</h2>
<p>If your Meteor application targets mobile platforms such as iOS or Android, you can configure your app's metadata and build process in a special top-level file called <code>mobile-config.js</code> which is <em>not</em> included in your application and is used only for this configuration.</p>
<p>The code snippet below is an example <code>mobile-config.js</code> file. The rest of this section will explain the specific API commands in greater detail.</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// This section sets up some basic app metadata,</span>
<span class="hljs-comment">// the entire section is optional.</span>
App.info({
  id: <span class="hljs-string">'com.example.matt.uber'</span>,
  name: <span class="hljs-string">'&uuml;ber'</span>,
  description: <span class="hljs-string">'Get &uuml;ber power in one button click'</span>,
  author: <span class="hljs-string">'Matt Development Group'</span>,
  email: <span class="hljs-string">'contact@example.com'</span>,
  website: <span class="hljs-string">'http://example.com'</span>
});

<span class="hljs-comment">// Set up resources such as icons and launch screens.</span>
App.icons({
  <span class="hljs-string">'iphone'</span>: <span class="hljs-string">'icons/icon-60.png'</span>,
  <span class="hljs-string">'iphone_2x'</span>: <span class="hljs-string">'icons/icon-60@2x.png'</span>,
  <span class="hljs-comment">// ... more screen sizes and platforms ...</span>
});

App.launchScreens({
  <span class="hljs-string">'iphone'</span>: <span class="hljs-string">'splash/Default~iphone.png'</span>,
  <span class="hljs-string">'iphone_2x'</span>: <span class="hljs-string">'splash/Default@2x~iphone.png'</span>,
  <span class="hljs-comment">// ... more screen sizes and platforms ...</span>
});

<span class="hljs-comment">// Set PhoneGap/Cordova preferences</span>
App.setPreference(<span class="hljs-string">'BackgroundColor'</span>, <span class="hljs-string">'0xff0000ff'</span>);
App.setPreference(<span class="hljs-string">'HideKeyboardFormAccessoryBar'</span>, <span class="hljs-literal">true</span>);

<span class="hljs-comment">// Pass preferences for a particular PhoneGap/Cordova plugin</span>
App.configurePlugin(<span class="hljs-string">'com.phonegap.plugins.facebookconnect'</span>, {
  APP_ID: <span class="hljs-string">'1234567890'</span>,
  API_KEY: <span class="hljs-string">'supersecretapikey'</span>
});
</code></pre>
<div class="api new-api-box">
<h3 id="App-info" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/App-info">App.info(options)</a></h3>
<div class="desc">
<p>Set your mobile app's core configuration information.</p>
</div>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">id, version, name, description, author, email, website</span> <span class="type">String</span></dt>
<dd>
<p>Each of the options correspond to a key in the app's core configuration as described in the <a href="http://docs.phonegap.com/en/3.5.0/config_ref_index.md.html#The%20config.xml%20File_core_configuration_elements">PhoneGap documentation</a>.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="App-setPreference" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/App-setPreference">App.setPreference(name, value)</a></h3>
<div class="desc">
<p>Add a preference for your build as described in the <a href="http://docs.phonegap.com/en/3.5.0/config_ref_index.md.html#The%20config.xml%20File_global_preferences">PhoneGap documentation</a>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">name</span> <span class="type">String</span></dt>
<dd>
<p>A preference name supported by Phonegap's <code>config.xml</code>.</p>
</dd>
<dt><span class="name">value</span> <span class="type">String</span></dt>
<dd>
<p>The value for that preference.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="App-accessRule" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/App-accessRule">App.accessRule(domainRule, [options])</a></h3>
<div class="desc">
<p>Set a new access rule based on origin domain for your app. By default your application has a limited list of servers it can contact. Use this method to extend this list.</p>
<p>Default access rules:</p>
<ul>
<li><code>tel:*</code>, <code>geo:*</code>, <code>mailto:*</code>, <code>sms:*</code>, <code>market:*</code> are allowed and launch externally (phone app, or an email client on Android)</li>
<li><code>gap:*</code>, <code>cdv:*</code>, <code>file:</code> are allowed (protocols required to access local file-system)</li>
<li><code>http://meteor.local/*</code> is allowed (a domain Meteor uses to access app's assets)</li>
<li>The domain of the server passed to the build process (or local ip address in the development mode) is used to be able to contact the Meteor app server.</li>
</ul>
<p>Read more about domain patterns in <a href="http://cordova.apache.org/docs/en/4.0.0/guide_appdev_whitelist_index.md.html">Cordova docs</a>.</p>
<p>Starting with Meteor 1.0.4 access rule for all domains and protocols (<code>&lt;access origin="*"/&gt;</code>) is no longer set by default due to <a href="http://cordova.apache.org/announcements/2014/08/04/android-351.html">certain kind of possible attacks</a>.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">domainRule</span> <span class="type">String</span></dt>
<dd>
<p>The pattern defining affected domains or URLs.</p>
</dd>
</dl>
<h4>Options</h4>
<dl class="args">
<dt><span class="name">launchExternal</span> <span class="type">Boolean</span></dt>
<dd>
<p>Set to true if the matching URL should be handled externally (e.g. phone app or email client on Android).</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="App-configurePlugin" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/App-configurePlugin">App.configurePlugin(pluginName, config)</a></h3>
<div class="desc">
<p>Set the build-time configuration for a Phonegap plugin.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">pluginName</span> <span class="type">String</span></dt>
<dd>
<p>The identifier of the plugin you want to configure.</p>
</dd>
<dt><span class="name">config</span> <span class="type">Object</span></dt>
<dd>
<p>A set of key-value pairs which will be passed at build-time to configure the specified plugin.</p>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="App-icons" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/App-icons">App.icons(icons)</a></h3>
<div class="desc">
<p>Set the icons for your mobile app.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">icons</span> <span class="type">Object</span></dt>
<dd>
<p>An Object where the keys are different devices and screen sizes, and values are image paths relative to the project root directory.</p>
<p>Valid key values:</p>
<ul>
<li><code>iphone</code></li>
<li><code>iphone_2x</code></li>
<li><code>iphone_3x</code></li>
<li><code>ipad</code></li>
<li><code>ipad_2x</code></li>
<li><code>android_ldpi</code></li>
<li><code>android_mdpi</code></li>
<li><code>android_hdpi</code></li>
<li><code>android_xhdpi</code></li>
</ul>
</dd>
</dl>
</div>
<div class="api new-api-box">
<h3 id="App-launchScreens" class="api-title"><a class="name selflink" href="http://localhost:3000/#/full/App-launchScreens">App.launchScreens(launchScreens)</a></h3>
<div class="desc">
<p>Set the launch screen images for your mobile app.</p>
</div>
<h4>Arguments</h4>
<dl class="args">
<dt><span class="name">launchScreens</span> <span class="type">Object</span></dt>
<dd>
<p>A dictionary where keys are different devices, screen sizes, and orientations, and the values are image paths relative to the project root directory.</p>
<p>For Android, launch screen images should be special "Nine-patch" image files that specify how they should be stretched. See the <a href="https://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch">Android docs</a>.</p>
<p>Valid key values:</p>
<ul>
<li><code>iphone</code></li>
<li><code>iphone_2x</code></li>
<li><code>iphone5</code></li>
<li><code>iphone6</code></li>
<li><code>iphone6p_portrait</code></li>
<li><code>iphone6p_landscape</code></li>
<li><code>ipad_portrait</code></li>
<li><code>ipad_portrait_2x</code></li>
<li><code>ipad_landscape</code></li>
<li><code>ipad_landscape_2x</code></li>
<li><code>android_ldpi_portrait</code></li>
<li><code>android_ldpi_landscape</code></li>
<li><code>android_mdpi_portrait</code></li>
<li><code>android_mdpi_landscape</code></li>
<li><code>android_hdpi_portrait</code></li>
<li><code>android_hdpi_landscape</code></li>
<li><code>android_xhdpi_portrait</code></li>
<li><code>android_xhdpi_landscape</code></li>
</ul>
</dd>
</dl>
</div>
<h1 id="packages">Packages</h1>
<p>Meteor supports a variety of add-on packages and third party libraries. While you can build great applications using only the Meteor core functionality, optional packages can make development even faster and better.</p>
<p>Packages can be added to a Meteor project with:</p>
<pre><code class="hljs ruby"><span class="hljs-prompt">$ meteor add &lt;package_name&gt;</span>
</code></pre>
<p>and removed with:</p>
<pre><code class="hljs ruby"><span class="hljs-prompt">$ meteor remove &lt;package_name&gt;</span>
</code></pre>
<p>Some of the packages that Meteor Development Group maintains include:</p>
<h2 id="appcache"><code>appcache</code></h2>
<p>The <code>appcache</code> package stores the static parts of a Meteor application (the client side Javascript, HTML, CSS, and images) in the browser's <a href="https://en.wikipedia.org/wiki/AppCache">application cache</a>. To enable caching simply add the <code>appcache</code> package to your project.</p>
<ul>
<li>
<p>Once a user has visited a Meteor application for the first time and the application has been cached, on subsequent visits the web page loads faster because the browser can load the application out of the cache without contacting the server first.</p>
</li>
<li>
<p>Hot code pushes are loaded by the browser in the background while the app continues to run. Once the new code has been fully loaded the browser is able to switch over to the new code quickly.</p>
</li>
<li>
<p>The application cache allows the application to be loaded even when the browser doesn't have an Internet connection, and so enables using the app offline.</p>
</li>
</ul>
<p>(Note however that the <code>appcache</code> package by itself doesn't make <em>data</em> available offline: in an application loaded offline, a Meteor Collection will appear to be empty in the client until the Internet becomes available and the browser is able to establish a DDP connection).</p>
<p>To turn AppCache off for specific browsers use:</p>
<pre><code class="hljs css"><span class="hljs-tag">Meteor</span><span class="hljs-class">.AppCache</span><span class="hljs-class">.config</span>(<span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">chrome</span>:<span class="hljs-value"> false,
  firefox: false
</span></span></span>});
</code></pre>
<p>The supported browsers that can be enabled or disabled include, but are not limited to, <code>android</code>, <code>chrome</code>, <code>chromium</code>, <code>chromeMobileIOS</code>, <code>firefox</code>, <code>ie</code>, <code>mobileSafari</code> and <code>safari</code>.</p>
<p>Browsers limit the amount of data they will put in the application cache, which can vary due to factors such as how much disk space is free. Unfortunately if your application goes over the limit rather than disabling the application cache altogether and running the application online, the browser will instead fail that particular <em>update</em> of the cache, leaving your users running old code.</p>
<p>Thus it's best to keep the size of the cache below 5MB. The <code>appcache</code> package will print a warning on the Meteor server console if the total size of the resources being cached is over 5MB.</p>
<p>If you have files too large to fit in the cache you can disable caching by URL prefix. For example,</p>
<pre><code class="hljs css"><span class="hljs-tag">Meteor</span><span class="hljs-class">.AppCache</span><span class="hljs-class">.config</span>(<span class="hljs-rules">{<span class="hljs-rule"><span class="hljs-attribute">onlineOnly</span>:<span class="hljs-value"> [<span class="hljs-string">'/online/'</span>]</span></span></span>});
</code></pre>
<p>causes files in your <code>public/online</code> directory to not be cached, and so they will only be available online. You can then move your large files into that directory and refer to them at the new URL:</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"/online/bigimage.jpg"</span>&gt;</span>
</code></pre>
<p>If you'd prefer not to move your files, you can use the file names themselves as the URL prefix:</p>
<pre><code class="hljs css"><span class="hljs-tag">Meteor</span><span class="hljs-class">.AppCache</span><span class="hljs-class">.config</span>(<span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">onlineOnly</span>:<span class="hljs-value"> [
    <span class="hljs-string">'/bigimage.jpg'</span>,
    <span class="hljs-string">'/largedata.json'</span>
  ]
</span></span></span>});
</code></pre>
<p>though keep in mind that since the exclusion is by prefix (this is a limitation of the application cache manifest), excluding <code>/largedata.json</code> will also exclude such URLs as <code>/largedata.json.orig</code> and <code>/largedata.json/file1</code>.</p>
<p>For more information about how Meteor interacts with the application cache, see the <a href="https://github.com/meteor/meteor/wiki/AppCache">AppCache page</a> in the Meteor wiki.</p>
<h2 id="accountsui"><code>accounts-ui</code></h2>
<p>A turn-key user interface for Meteor Accounts.</p>
<p>To add Accounts and a set of login controls to an application, add the <code>accounts-ui</code> package and at least one login provider package: <code>accounts-password</code>, <code>accounts-facebook</code>, <code>accounts-github</code>, <code>accounts-google</code>, <code>accounts-twitter</code>, or <code>accounts-weibo</code>.</p>
<p>Then simply add the <code>{{&gt; loginButtons}}</code> helper to an HTML file. This will place a login widget on the page. If there is only one provider configured and it is an external service, this will add a login/logout button. If you use <code>accounts-password</code> or use multiple external login services, this will add a "Sign in" link which opens a dropdown menu with login options. If you plan to position the login dropdown in the right edge of the screen, use <code>{{&gt; loginButtons align="right"}}</code> in order to get the dropdown to lay itself out without expanding off the edge of the screen.</p>
<p>To configure the behavior of <code>{{&gt; loginButtons}}</code>, use <a href="http://localhost:3000/#accounts_ui_config"><code>Accounts.ui.config</code></a>.</p>
<p><code>accounts-ui</code> also includes modal popup dialogs to handle links from <a href="http://localhost:3000/#accounts_sendresetpasswordemail"><code>sendResetPasswordEmail</code></a>, <a href="http://localhost:3000/#accounts_sendverificationemail"><code>sendVerificationEmail</code></a>, and <a href="http://localhost:3000/#accounts_sendenrollmentemail"><code>sendEnrollmentEmail</code></a>. These do not have to be manually placed in HTML: they are automatically activated when the URLs are loaded.</p>
<h2 id="auditargumentchecks"><code>audit-argument-checks</code></h2>
<p>This package causes Meteor to require that all arguments passed to methods and publish functions are <a href="http://localhost:3000/#check"><code>check</code>ed</a>. Any method that does not pass each one of its arguments to <code>check</code> will throw an error, which will be logged on the server and which will appear to the client as a <code>500 Internal server error</code>. This is a simple way to help ensure that your app has complete check coverage.</p>
<p>Methods and publish functions that do not need to validate their arguments can simply run <code>check(arguments, [Match.Any])</code> to satisfy the <code>audit-argument-checks</code> coverage checker.</p>
<h2 id="coffeescript"><code>coffeescript</code></h2>
<p><a href="http://coffeescript.org/">CoffeeScript</a> is a little language that compiles into JavaScript. It provides a simple syntax without lots of braces and parentheses. The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime.</p>
<p>CoffeeScript is supported on both the client and the server. Files ending with <code>.coffee</code>, <code>.litcoffee</code>, or <code>.coffee.md</code> are automatically compiled to JavaScript.</p>
<h3 id="namespacingandcoffeescript">Namespacing and CoffeeScript</h3>
<p>Here's how CoffeeScript works with Meteor's namespacing.</p>
<ul>
<li>
<p>Per the usual CoffeeScript convention, CoffeeScript variables are file-scoped by default (visible only in the <code>.coffee</code> file where they are defined.)</p>
</li>
<li>
<p>When writing a package, CoffeeScript-defined variables can be exported like any other variable (see <a href="http://localhost:3000/#writingpackages">Writing Packages</a>). Exporting a variable pulls it up to package scope, meaning that it will be visible to all of the code in your app or package (both <code>.js</code> and <code>.coffee</code> files).</p>
</li>
<li>
<p>Package-scope variables declared in <code>.js</code> files are visible in any <code>.coffee</code> files in the same app or project.</p>
</li>
<li>
<p>There is no way to make a package-scope variable from a <code>.coffee</code> file other than exporting it. We couldn't figure out a way to make this fit naturally inside the CoffeeScript language. If you want to use package-scope variables with CoffeeScript, one way is to make a short <code>.js</code> file that declares all of your package-scope variables. They can then be used and assigned to from <code>.coffee</code> files.</p>
</li>
<li>
<p>If you want to share variables between <code>.coffee</code> files in the same package, and don't want to separately declare them in a <code>.js</code> file, we have an experimental feature that you may like. An object called <code>share</code> is visible in CoffeeScript code and is shared across all <code>.coffee</code> files in the same package. So, you can write <code>share.foo</code> for a value that is shared between all CoffeeScript code in a package, but doesn't escape that package.</p>
</li>
</ul>
<p>Heavy CoffeeScript users, please let us know how this arrangement works for you, whether <code>share</code> is helpful for you, and anything else you'd like to see changed.</p>
<h2 id="jquery"><code>jquery</code></h2>
<p><a href="http://jquery.com/">jQuery</a> is a fast and concise JavaScript Library that simplifies HTML document traversing, event handling, animating, and Ajax interactions for rapid web development.</p>
<p>The <code>jquery</code> package adds the jQuery library to the client JavaScript bundle. It has no effect on the server.</p>
<p>In addition to the <code>jquery</code> package, Meteor provides several jQuery plugins as separate packages. These include:</p>
<ul>
<li><a href="https://github.com/balupton/history.js"><code>jquery-history</code></a></li>
<li><a href="http://layout.jquery-dev.net/"><code>jquery-layout</code></a></li>
<li><a href="http://imakewebthings.com/jquery-waypoints/"><code>jquery-waypoints</code></a></li>
</ul>
<h2 id="less"><code>less</code></h2>
<p><a href="http://lesscss.org/">LESS</a> extends CSS with dynamic behavior such as variables, mixins, operations and functions. It allows for more compact stylesheets and helps reduce code duplication in CSS files.</p>
<p>With the <code>less</code> package installed, <code>.less</code> files in your application are automatically compiled to CSS and the results are included in the client CSS bundle.</p>
<div class="note">
<p>If you want to <code>@import</code> a file, give it the extension <code>.import.less</code> to prevent Meteor from processing it independently.</p>
</div>
<h2 id="markdown"><code>markdown</code></h2>
<p>This package lets you use Markdown in your templates. It's easy: just put your markdown inside <code>{{#markdown}} ... {{/markdown}}</code> tags. You can still use all of the usual Meteor template features inside a Markdown block, such as <code>{{#each}}</code>, and you still get reactivity.</p>
<p>Example:</p>
<p><code>{{#markdown}}I am using __markdown__.{{/markdown}}</code></p>
<p>outputs</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>I am using <span class="hljs-tag">&lt;<span class="hljs-title">strong</span>&gt;</span>markdown<span class="hljs-tag">&lt;/<span class="hljs-title">strong</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
</code></pre>
<h2 id="oauthencryption"><code>oauth-encryption</code></h2>
<p>Encrypts sensitive account credential information stored in the database. See packages/oauth-encryption/README.md for details.</p>
<h2 id="random"><code>random</code></h2>
<p>The <code>random</code> package provides several functions for generating random numbers. It uses a cryptographically strong pseudorandom number generator when possible, but falls back to a weaker random number generator when cryptographically strong randomness is not available (on older browsers or on servers that don't have enough entropy to seed the cryptographically strong generator).</p>
<dl class="callbacks">
<dt><span class="name">Random.id([n])</span></dt>
<dd>
<p>Returns a unique identifier, such as <code>"Jjwjg6gouWLXhMGKW"</code>, that is likely to be unique in the whole world. The optional argument <code>n</code> specifies the length of the identifier in characters and defaults to 17.</p>
</dd>
<dt><span class="name">Random.secret([n])</span></dt>
<dd>
<p>Returns a random string of printable characters with 6 bits of entropy per character. The optional argument <code>n</code> specifies the length of the secret string and defaults to 43 characters, or 256 bits of entropy. Use <code>Random.secret</code> for security-critical secrets that are intended for machine, rather than human, consumption.</p>
</dd>
<dt><span class="name">Random.fraction()</span></dt>
<dd>
<p>Returns a number between 0 and 1, like <code>Math.random</code>.</p>
</dd>
<dt><span class="name">Random.choice(arrayOrString)</span></dt>
<dd>
<p>Returns a random element of the given array or string.</p>
</dd>
<dt><span class="name">Random.hexString(n)</span></dt>
<dd>
<p>Returns a random string of <code>n</code> hexadecimal digits.</p>
</dd>
</dl>
<h2 id="underscore"><code>underscore</code></h2>
<p><a href="http://underscorejs.org/">Underscore</a> is a utility-belt library for JavaScript that provides support for functional programming. It is invaluable for writing clear, concise JavaScript in a functional style.</p>
<p>The <code>underscore</code> package defines the <code>_</code> namespace on both the client and the server.</p>
<div class="warning">
<p>Currently, underscore is included in all projects, as the Meteor core depends on it. _ is available in the global namespace on both the client and the server even if you do not include this package. However if you do use underscore in your application, you should still add the package as we will remove the default underscore in the future.</p>
</div>
<div class="warning">
<p>We have slightly modified the way Underscore differentiates between objects and arrays in <a href="http://underscorejs.org/#each">collection functions</a>. The original Underscore logic is to treat any object with a numeric <code>length</code> property as an array (which helps it work properly on <a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList"><code>NodeList</code>s</a>). In Meteor's version of Underscore, objects with a numeric <code>length</code> property are treated as objects if they have no prototype (specifically, if <code>x.constructor === Object</code>.</p>
</div>
<h2 id="webapp"><code>webapp</code></h2>
<p>The <code>webapp</code> package is what lets your Meteor app serve content to a web browser. It is included in the <code>meteor-platform</code> set of packages that is automatically added when you run <code>meteor create</code>. You can easily build a Meteor app without it - for example if you wanted to make a command-line tool that still used the Meteor package system and DDP.</p>
<p>This package also allows you to add handlers for HTTP requests. This lets other services access your app's data through an HTTP API, allowing it to easily interoperate with tools and frameworks that don't yet support DDP.</p>
<p><code>webapp</code> exposes the <a href="https://github.com/senchalabs/connect">connect</a> API for handling requests through <code>WebApp.connectHandlers</code>. Here's an example that will let you handle a specific URL:</p>
<pre><code class="hljs js"><span class="hljs-comment">// Listen to incoming HTTP requests, can only be used on the server</span>
WebApp.connectHandlers.use(<span class="hljs-string">"/hello"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res, next)</span> </span>{
  res.writeHead(<span class="hljs-number">200</span>);
  res.end(<span class="hljs-string">"Hello world from: "</span> + Meteor.release);
});
</code></pre>
<p><code>WebApp.connectHandlers.use([path], handler)</code> has two arguments:</p>
<p><strong>path</strong> - an optional path field. This handler will only be called on paths that match this string. The match has to border on a <code>/</code> or a <code>.</code>. For example, <code>/hello</code> will match <code>/hello/world</code> and <code>/hello.world</code>, but not <code>/hello_world</code>.</p>
<p><strong>handler</strong> - this is a function that takes three arguments:</p>
<ul>
<li><strong>req</strong> - a Node.js <a href="http://nodejs.org/api/http.html#http_http_incomingmessage">IncomingMessage</a> object with some extra properties. This argument can be used to get information about the incoming request.</li>
<li><strong>res</strong> - a Node.js <a href="http://nodejs.org/api/http.html#http_class_http_serverresponse">ServerResponse</a> object. Use this to write data that should be sent in response to the request, and call <code>res.end()</code> when you are done.</li>
<li><strong>next</strong> - a function. Calling this function will pass on the handling of this request to the next relevant handler.</li>
</ul>
<div>
<h1 id="commandline">Command line</h1>
<p>The following are some of the more commonly used commands in the <code>meteor</code> command-line tool. This is just an overview and does not mention every command or every option to every command; for more details, use the <code>meteor help</code> command.</p>
<h3 id="meteorhelp">meteor help</h3>
<p>Get help on meteor command line usage. Running <code>meteor help</code> by itself will list the common meteor commands. Running <code>meteor help <em>command</em></code> will print detailed help about the command.</p>
<h3 id="meteorrun">meteor run</h3>
<p>Run a meteor development server in the current project. Searches upward from the current directory for the root directory of a Meteor project. Whenever you change any of the application's source files, the changes are automatically detected and applied to the running application.</p>
<p>You can use the application by pointing your web browser at <a href="http://localhost:3000">localhost:3000</a>. No internet connection is required.</p>
<p>This is the default command. Simply running <code>meteor</code> is the same as <code>meteor run</code>.</p>
<p>To pass additional options to Node.js use the <code>NODE_OPTIONS</code> environment variable. For example: <code>NODE_OPTIONS='--debug'</code> or <code>NODE_OPTIONS='--debug-brk'</code></p>
<p>Run <code>meteor help run</code> to see the full list of options.</p>
<h3 id="meteordebug">meteor debug</h3>
<p>Run the project, but suspend the server process for debugging.</p>
<p>The server process will be suspended just before the first statement of server code that would normally execute. In order to continue execution of server code, use either the web-based Node Inspector or the command-line debugger (further instructions will be printed in the console).</p>
<p>Breakpoints can be set using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger" target="_blank"><code>debugger</code> keyword</a>, or through the web UI of Node Inspector ("Sources" tab).</p>
<p>The server process debugger will listen for incoming connections from debugging clients, such as node-inspector, on port 5858 by default. To specify a different port use the <code>--debug-port &lt;port&gt;</code> option.</p>
<p>The same debugging functionality can be achieved by adding the <code>--debug-port &lt;port&gt;</code> option to other <code>meteor</code> tool commands, such as <code>meteor run</code> and <code>meteor test-packages</code>.</p>
<h3 id="meteorcreate">meteor create <em>name</em></h3>
<p>Create a new Meteor project. By default, makes a subdirectory named <em>name</em> and copies in the template app. You can pass an absolute or relative path.</p>
<p>You can use the --package option, to create a new package. If used in an existing app, this command will create a package in the packages directory.</p>
<h3 id="meteordeploy">meteor deploy <em>site</em></h3>
<p>Deploy the project in your current directory to Meteor's servers.</p>
<p>You can deploy to any available name under <code>meteor.com</code> without any additional configuration, for example, <code>myapp.meteor.com</code>. If you deploy to a custom domain, such as <code>myapp.mydomain.com</code>, then you'll need to make sure the DNS for that domain is configured to point at <code>origin.meteor.com</code>.</p>
<p>The first time you deploy an app you'll be prompted for an email address &mdash; follow the link in your email to finish setting up your account.</p>
<p>Once you have your account you can log in and log out from the command line, check your username with <code>meteor whoami</code>, and run <code>meteor authorized</code> to give other Meteor developers permissions to deploy your app and access its database and logs.</p>
<p>You can deploy in debug mode by passing <code>--debug</code>. This will leave your source code readable by your favorite in-browser debugger, just like it is in local development mode.</p>
<p>To delete an application you've deployed, specify the <code>--delete</code> option along with the site.</p>
<div class="warning">
<p>If you use a domain name other than <code>meteor.com</code> you must ensure that the name resolves to <code>origin.meteor.com</code>. If you want a top-level domain like myapp.com, you'll need a DNS A record, matching the IP address of origin.meteor.com.</p>
</div>
<p>You can add information specific to a particular deployment of your application by using the <code>--settings</code> option. The argument to <code>--settings</code> is a file containing any JSON string. The object in your settings file will appear on the server side of your application in <a href="http://localhost:3000/#meteor_settings"><code>Meteor.settings</code></a>.</p>
<p>Settings are persistent. When you redeploy your app, the old value will be preserved unless you explicitly pass new settings using the <code>--settings</code> option. To unset <code>Meteor.settings</code>, pass an empty settings file.</p>
<h3 id="meteorlogs">meteor logs <em>site</em></h3>
<p>Retrieves the server logs for the named Meteor application.</p>
<p>Meteor redirects the output of <code>console.log()</code> in your server code into a logging server. <code>meteor logs</code> displays those logs. In client code, the output of <code>console.log()</code> is available in your web browser's inspector, just like any other client-side JavaScript.</p>
<h3 id="meteorupdate">meteor update</h3>
<p>Attempts to bring you to the latest version of Meteor, and then to upgrade your packages to their latest versions. By default, update will not break compatibility.</p>
<p>For example, let's say packages A and B both depend on version 1.1.0 of package X. If a new version of A depends on X@2.0.0, but there is no new version of package B, running <code>meteor update</code> will not update A, because doing so will break package B.</p>
<p>You can pass in the flag <code>--packages-only</code> to update only the packages, and not the release itself. Similarly, you can pass in names of packages (<code>meteor update foo:kittens baz:cats</code>) to only update specific packages.</p>
<p>Every project is pinned to a specific release of Meteor. You can temporarily try using your package with another release by passing the <code>--release</code> option to any command; <code>meteor update</code> changes the pinned release.</p>
<p>Sometimes, Meteor will ask you to run <code>meteor update --patch</code>. Patch releases are special releases that contain only very minor change (usually crucial bug fixes) from previous releases. We highly recommend that you always run <code>update --patch</code> when prompted.</p>
<p>You may also pass the <code>--release</code> flag to act as an override to update to a specific release. This is an override: if it cannot find compatible versions of packages, it will log a warning, but perform the update anyway. This will only change your package versions if nessesary.</p>
<h3 id="meteoradd">meteor add <em>package</em></h3>
<p>Add packages to your Meteor project. By convention, names of community packages include the name of the maintainer. For example: <code>meteor add iron:router</code>. You can add multiple packages with one command</p>
<p>Optionally, adds version constraints. Running <code>meteor add package@1.1.0</code> will add the package at version <code>1.1.0</code> or higher (but not <code>2.0.0</code> or higher). If you want to use version <code>1.1.0</code> exactly, use <code>meteor add package@=1.1.0</code>. You can also 'or' constraints together: for example, <code>meteor add 'package@=1.0.0 || =2.0.1'</code> means either 1.0.0 (exactly) or 2.0.1 (exactly).</p>
<p>To remove a version constraint for a specific package, run <code>meteor add</code> again without specifying a version. For example above, to stop using version <code>1.1.0</code> exactly, run <code>meteor add package</code>.</p>
<h3 id="meteorremove">meteor remove <em>package</em></h3>
<p>Removes a package previously added to your Meteor project. For a list of the packages that your application is currently using, run <code>meteor list</code>.</p>
<p>This removes the package entirely. To continue using the package, but remove its version constraint, use <a href="http://localhost:3000/#meteoradd"><code>meteor add</code></a>.</p>
<p>Meteor does not downgrade transitive dependencies unless it's necessary. This means that if running <code>meteor add A</code> upgrades A's parent package X to a new version, your project will continue to use X at the new version even after you run <code>meteor remove A</code>.</p>
<h3 id="meteorlist">meteor list</h3>
<p>Lists all the packages that you have added to your project. For each package, lists the version that you are using. Lets you know if a newer version of that package is available.</p>
<h3 id="meteoraddplatform">meteor add-platform <em>platform</em></h3>
<p>Adds platforms to your Meteor project. You can add multiple platforms with one command. Once a platform has been added, you can use 'meteor run <em>platform</em>' to run on the platform, and 'meteor build' to build the Meteor project for every added platform.</p>
<h3 id="meteorremoveplatform">meteor remove-platform <em>platform</em></h3>
<p>Removes a platform previously added to your Meteor project. For a list of the platforms that your application is currently using, see 'meteor list-platforms'.</p>
<h3 id="meteorlistplatforms">meteor list-platforms</h3>
<p>Lists all of the platforms that have been explicitly added to your project.</p>
<h3 id="meteormongo">meteor mongo</h3>
<p>Open a MongoDB shell on your local development database, so that you can view or manipulate it directly.</p>
<div class="warning">
<p>For now, you must already have your application running locally with <code>meteor run</code>. This will be easier in the future.</p>
</div>
<h3 id="meteorreset">meteor reset</h3>
<p>Reset the current project to a fresh state. Removes the local mongo database.</p>
<div class="warning">
<p>This deletes your data! Make sure you do not have any information you care about in your local mongo database by running <code>meteor mongo</code>. From the mongo shell, use <code>show collections</code> and <code>db.<em>collection</em>.find()</code> to inspect your data.</p>
</div>
<div class="warning">
<p>For now, you can not run this while a development server is running. Quit all running meteor applications before running this.</p>
</div>
<h3 id="meteorbuild">meteor build</h3>
<p>Package this project up for deployment. The output is a directory with several build artifacts:</p>
<ul>
<li>a tarball that includes everything necessary to run the application server (see `README` in the tarball for details)</li>
<li>an unassigned `apk` bundle and a project source if Android is targetted as a mobile platform</li>
<li>a directory with an Xcode project source if iOS is targetted as a mobile platform</li>
</ul>
<p>You can use the application server bundle to host a Meteor application on your own server, instead of deploying to Meteor's servers. You will have to deal with logging, monitoring, backups, load-balancing, etc, all of which we handle for you if you use <code>meteor deploy</code>.</p>
<p>Unassigned <code>apk</code> bundle and the outputted Xcode project can be used to deploy your mobile apps to Android Play Store and Apple App Store.</p>
<p>By default, your application is bundled for your current architecture. This may cause difficulties if your app contains binary code due to, for example, npm packages. You can try to override that behavior with the --architecture flag.</p>
<h3 id="meteorsearch">meteor search</h3>
<p>Searches for Meteor packages and releases, whose names contain the specified regular expression.</p>
<h3 id="meteorshow">meteor show</h3>
<p>Shows more information about a specific package or release: name, summary, the usernames of its maintainers, and, if specified, its homepage and git URL.</p>
<h3 id="meteorpublish">meteor publish</h3>
<p>Publishes your package. To publish, you must cd into the package directory, log in with your Meteor Developer Account and run <code>meteor publish</code>. By convention, published package names must begin with the maintainer's Meteor Development Accounts username and a colon, like so: <code>iron:router</code>.</p>
<p>To publish a package for the first time, use <code>meteor publish --create</code>.</p>
<p>Sometimes packages may contain binary code specific to an architecture (for example, they may use an npm package). In that case, running publish will only upload the build to the architecture that you were using to publish it. You can use <code>publish-for-arch</code> to upload a build to a different architecture from a different machine.</p>
<h3 id="meteorpublishforarch">meteor publish-for-arch</h3>
<p>Publishes a build of an existing package version from a different architecture.</p>
<p>Some packages contain code specific to an architecture. Running <code>publish</code> by itself, will upload the build to the architecture that you were using to publish. You need to run <code>publish-for-arch</code> from a different architecture to upload a different build.</p>
<p>For example, let's say you published name:cool-binary-blob from a Mac. If you want people to be able to use cool-binary-blob from Linux, you should log into a Linux machine and then run <code>meteor publish-for-arch name:cool-binary-blob@version</code>. It will notice that you are on a linux machine, and that there is no Linux-compatible build for your package and publish one.</p>
<p>Currently, the supported architectures for Meteor are 32-bit Linux, 64-bit Linux and Mac OS. The servers for <code>meteor deploy</code> run 64-bit Linux.</p>
<h3 id="meteorpublishrelease">meteor publish-release</h3>
<p>Publishes a release of Meteor. Takes in a json configuration file.</p>
<p>Meteor releases are divided into tracks. While only MDG members can publish to the default Meteor track, anyone can create a track of their own and publish to it. Running <code>meteor update</code> without specifying the <code>--release</code> option will not cause the user to switch tracks.</p>
<p>To publish to a release track for the first time, use the <code>create-track</code> flag.</p>
<p>The JSON configuration file must contain the name of the release track (<code>track</code>), the release version (<code>version</code>), various metadata, the packages specified by the release as mapped to versions (<code>packages</code>), and the package &amp; version of the Meteor command-line tool (<code>tool</code>). Note that this means that forks of the meteor tool can be published as packages and people can use them by switching to a corresponding release. For more information, run <code>meteor help publish-release</code>.</p>
<h3 id="meteortestpackages">meteor test-packages</h3>
<p>Test Meteor packages, either by name, or by directory. Not specifying an argument will run tests for all local packages. The results are displayed in an app that runs at <code>localhost:3000</code> by default. If you need to, you can pass the <code>--settings</code> and <code>--port</code> arguments.</p>
<h3 id="meteoradmin">meteor admin</h3>
<p>Catch-all for miscellaneous commands that require authorization to use.</p>
<p>Some example uses of <code>meteor admin</code> include adding and removing package maintainers and setting a homepage for a package. It also includes various helpful functions for managing a Meteor release. Run <code>meteor help admin</code> for more information.</p>
</div>
</div>
</div>
</div>
</div>
</body>
</html>